{
  "id": "10018",
  "year": "2021",
  "url": "https://developer.apple.com/videos/play/wwdc2021/10018/",
  "title": "What's new in SwiftUI",
  "speakers": [],
  "duration": "",
  "topics": [
    "Essentials"
  ],
  "hasTranscript": true,
  "hasCode": true,
  "transcript": {
    "fullText": "♪ Bass music playing ♪  ♪ Matt Ricketson: Welcome to “What’s New in SwiftUI.” I’m Matt, and later on, I’ll be joined by Taylor. This session is all about SwiftUI, Apple’s declarative UI framework. SwiftUI is still young, but we’ve come so far already. SwiftUI was first released in 2019, introducing a powerful new way to build user interfaces in a declarative, state-driven style. We took the next big step with SwiftUI’s second release, enabling 100 percent SwiftUI apps with the new App and Scene APIs. This year we’re focused on supporting even deeper adoption of SwiftUI in your apps with a great set of rich new features. Now if you haven’t yet had a chance to try out SwiftUI yourself, that’s OK! Only you know what’s best for your app. But here are a few tips to keep in mind as you learn about all the new features available this year. A good way to dip your toes into SwiftUI is to use it to create brand-new features in an existing app, like how it powers the new activity stream in Notes for iOS, iPadOS, and macOS. Or the new avatar picker in macOS, also built with SwiftUI. Remember, you can mix in SwiftUI alongside your existing UIKit or AppKit code. SwiftUI is also a useful tool for expanding your app to new platforms, like how SwiftUI was used to build the new Shortcuts app on macOS. With SwiftUI, you can easily share common code between platforms while still crafting a unique experience for each device. And when you’re ready to redesign your app, that’s the perfect time to bring in SwiftUI to help. The all-new Apple Pay purchase flow was redesigned using SwiftUI, which was also used to bring a fresh coat of paint to the new Help Viewer on macOS and the Tips app on watchOS. And finally, we can’t forget the gorgeous new Weather app for iOS, also rebuilt from the ground up in SwiftUI. These are just several examples of how SwiftUI is helping build the next generation of apps. For this session, we’d like to share some of the great new APIs that made it all possible. We’ll start by walking through improvements to how we build collections of content with lists and grids. Next, we’ll go beyond lists, introducing new features to take your data-driven apps to the next level. Third, we’ll show off some stunning new tools for driving graphics and visual effects. We’ll talk about enhancements to text, keyboards, and focus-based navigation. And finally, we’ll give some love to buttons. So let’s dive in, beginning with lists and grids, which are critical features for organizing and displaying data within SwiftUI apps. This year, we’re making it even easier to write rich, interactive lists and grids. Let’s start with a fun one. SwiftUI now has built-in support for loading images asynchronously. SwiftUI makes loading these images feel easy with the new AsyncImage view. Just give it a URL, and SwiftUI will automatically fetch and display the remote image for you, and even provide a default placeholder. AsyncImage can also be customized. For example, we can add modifiers to the loaded image and also define custom placeholders, like I’m doing here to add some fun colors. We can even add custom animations and error handling! And AsyncImage is available on all platforms. We hope you check it out. AsyncImage loads its content immediately, but sometimes your app needs to load content on-request, like when showing a feed. This is a great use case for supporting pull-to-refresh on iOS and iPadOS, using the new refreshable modifier. This modifier configures a refresh action and passes down through the environment. Lists on iOS and iPadOS use this action to automatically add pull-to-refresh, but you can also use it to build your own custom refresh behaviors. You may have noticed this new await keyword, which is one of the new concurrency language features in Swift 5.5. This indicates that the updateItems method is an async action, which lets us refresh our list without blocking the UI. Another new concurrency-related SwiftUI feature is the task modifier. This API lets you attach an async task to the lifetime of your view. That means the task will kick off when the view first loads and automatically cancel itself when the view is removed. This is a great way for us to load the first batch of photos automatically. These new concurrency modifiers look simple on the surface, but can be used to build sophisticated async behaviors into your app. For example, here I’ve set up a task for loading the newest photos as they become available. I’ve written just a regular for loop, but you’ll notice the await keyword used here as well. That’s because newestCandidates is actually an async sequence, which is another new concurrency feature in Swift 5.5. This means we’ll wait for the newest candidate asynchronously, iterating the loop only when the next candidate is available. That means we’re actually packing a ton of functionality into just this single modifier. The view starts a task that listens for candidates asynchronously as soon as it appears, updating the list every time a new candidate becomes available and then automatically canceling the task when the view disappears, all without blocking our app’s UI. There’s a lot more to learn about Swift concurrency and how to take advantage of it in SwiftUI, so we’ve prepared a few other talks to dig into the details. “Discover concurrency in SwiftUI” will explain how concurrency relates to SwiftUI’s update model and demo some the new features we just discussed. And in “Swift concurrency: Update a sample app,” we walk you step by step through upgrading an existing project with async model code. Next up, we’re giving you new and better ways to build interactivity into your list content. In this example, I’ve written a simple list for sharing the directions to my super secret hideout. This looks nice, but the text isn’t editable. Let’s fix that. We can make text editable by swapping it out for a text field instead. However, a text field requires a binding to the text. Within our list’s content closure, we’re only given a plain value for each element in our collection, not a binding. In situations like this, it can be tricky to figure out how to get a binding to the collection element for each row. One common approach is to iterate over the indices of the collection instead, using a subscript to get a binding to the element at that index. However, this technique is not recommended, because SwiftUI will be forced to reload the entire list when anything changes. In fact, we’ve prepared a whole talk discussing this topic in much more detail. To learn more, I’d recommend watching “Demystify SwiftUI.” For now, let’s undo these changes and take a look at a better solution. This year, SwiftUI is providing a much easier way to get access to bindings for individual elements within a collection. Simply pass a binding to your collection into the list, using the normal dollar sign operator, and SwiftUI will pass back a binding to each individual element within the closure. Code that only needs to read the value can stay exactly the same as before, just like you’re used to. But now we can easily add interactive controls like a text field using the normal binding syntax that we’re used to, which means I can finally fill in the super secret door code I forgot to include earlier. This new syntax is part of the Swift language, so it works everywhere you would expect, not just lists. For example, we can use the same technique in a ForEach view within our list instead. And better yet, you can even back-deploy this code to any prior release supported by SwiftUI. But we’re not just making your existing code easier to write. Lists are gaining some great new features too! Let’s start with some new ways to visually customize your lists. With the new listRowSeparatorTint modifier, you can change the color of individual row separators, like I’ve done here to align the separator and icon colors for each row. SwiftUI also has an equivalent modifier for section separators. For this app though, all those separators seem a little distracting. I want my directions to feel like a single, unified flow. Maybe we should try removing them, which we can now do with the new listRowSeparator modifier, configuring our separators to be hidden. Now our directions feel much less cluttered. Let’s look at another app I’m making...\n\n...which helps comic book authors keep track of all their superheroes and villains. This app uses swipe actions to quickly and conveniently pin and delete characters, but without cluttering up our UI with extra controls. New this year, SwiftUI allows you to define completely custom swipe actions using the new swipeActions modifier. You configure swipe actions just like any other kind of menu in SwiftUI, defining actions using buttons. You can also customize their color by adding the new tint modifier, which I’m using to make my pin action yellow. By default, SwiftUI shows swipe actions on the trailing edge of the row. But you can switch them to the leading side using modifier’s edge parameter. You can even support both leading and trailing swipe actions by adding multiple modifiers with different edge configurations. And lastly, the swipeActions modifier is available on every platform that supports them, making it easy to share code within your multiplatform app. Speaking of other platforms, let’s check in on the macOS version of my app. It shows a multicolumn interface, which makes use of the extra space available on the Mac. Instead of cramming all of my data into the sidebar, I have an overview tab that lists all of my characters. That lets me just keep my pinned characters in the sidebar. This list does feel a little plain though. Let’s try to spruce it up a bit. Here’s my existing code. I’m currently using the inset list style to smoothly fit the list within my window. And we’re able to express this style beautifully in code using the new enum-like syntax available on all view styles this year. Also new this year, the inset list style is gaining a new trick. It is now able to alternate the backgrounds of the rows by just modifying the style with the alternatesRowBackgrounds flag. Our list is looking a lot better now, with each row clearly distinguished from the other. But for a macOS app, it still feels like we’re not taking full advantage of all that space in our window. So for the next section, let’s go beyond lists to get even more out of your app. To help us make better use of all this space, let’s upgrade our list to a rich, multicolumn table! With four columns, I now get four lists for the price of one! But the best part is that a moderately complex table like this can be declared with so little code it fits on a single slide. That’s because tables use the same kind of declarative construction that you’re used to throughout SwiftUI. Just like with lists, you can create a table from a single collection of content. But unlike a list, a table is made up of TableColumns that define content within each visual column. Each of these columns are visually labeled and use data from the collection to define their visual content with some shorthand conveniences for common cases like just displaying text. But tables are also interactive, supporting row selection both for single rows and multiple rows, just like in regular lists. Tables also support sorting with the help of key paths to sortable values on the columns. Now, tables support several other features, including multiple different visual styles as well as fine-tuning the appearance of each column. But let’s talk more about the data you provide to a table or list. This year, we have several new enhancements to SwiftUI’s support for CoreData fetch requests. FetchRequests now provide a binding to their sort descriptors, which we can pass on to the Table, allowing us to write a fully Core Data-driven table, complete with selection and sortable columns, in just a few lines of code. SwiftUI now also offers a sectioned fetch request, allowing for complex, multisection lists like the one on the right to be driven from a single request. In this example, we partition our data into sections based on whether or not they're pinned. We use multiple SortDescriptors to arrange the data, first to split it into pinned and unpinned sections, and second to order recently modified characters last. Next we specify that any changes should be animated. And finally we construct the sections and rows of our list dynamically, based on the results of the request. All together, this single request is able to drive the animated list on the right. For more information on building apps for macOS, working with tables, and integrating Core Data with SwiftUI, be sure to check out these other talks. The “SwiftUI on the Mac” two-part series will take you step-by-step through building an app that’s optimized for the Mac. And “Bring Core Data concurrency to Swift and SwiftUI” will cover the new Core Data fetch request APIs in much more detail. Now it’s time to step back and think about how we can help users find what they need amidst all of this data. Of course, I’m talking about search. Search is a critical part of all of our platforms. It helps users find what they need exactly when they need it. You’ll find it on large devices like the Apple TV, even all the way down to the smallest devices, like the Apple Watch. So since search is a multiplatform problem, it needs a multiplatform solution that can scale across all these devices. Luckily, adding search to your app couldn’t be easier; just add the searchable modifier, like we’ve done here on our NavigationView. With this one modifier, SwiftUI will automatically add a search field to the appropriate location in your app and optionally show suggestions in a platform- and context-appropriate way. The modifier takes a binding to the search text, allowing you to filter your data based on the current value. Now, there is a lot more to say about search in SwiftUI, but luckily we have a whole session to walk you through how to think about search capabilities on multiple platforms. Check out “Craft search experiences in SwiftUI” to learn more. So far we’ve explored how to load, display, organize, and search through your app’s data using lists and grids. Now let’s talk about how to share that data beyond your app. One of the simplest methods of sharing data is by just dragging it out of your app. In my Heroes & Villains app, I’ve configured the character icon on the detail screen to be draggable using the existing onDrag modifier. New this year, you can now add custom previews to your draggable views. This preview is shown instead of the view while it’s being dragged. Drag and drop is powered by item providers, which allow data to be copied and shared between different processes. This year, SwiftUI is providing several more ways to use item providers to integrate with other apps and services such as configuring your app to support importing item providers from external services, using the new importsItemProviders modifier. In this example, we’ve configured our view to be able to import images, and add them as attachments to our story characters. We can pair this capability a new macOS feature: Continuity Camera. By adding the “Import from Devices” commands to our app’s main menu, we’re now able to use an iPhone or iPad to just take photos to import into our Mac app. Let’s try it out! The symbol of the View Builder superhero is her trusty hammer. It would be great to attach a picture of it to her profile. Luckily, I happen to have it right here!  From within my app, I can access the “Import from devices” commands in the File menu. Then, I can choose to take a picture using my iPhone...\n\n....which automatically opens the Camera app so we can quickly take a picture.\n\nAnd the new photo is imported and added to my app, using the importsItemProviders modifier we showed earlier. SwiftUI also supports exporting data out of our app. Exporting data allows you to take advantage of other services, such as being able to trigger shortcuts from directly within your app. In SwiftUI, you can export data using the new exportsItemProviders modifier. This exposes your app’s data to the rest of the system, for example, allowing it to be used by services and shortcuts on macOS. Let’s take a look at how this appears for people using the app. I can now see quick actions show up in my app’s Services menu when I’ve selected one of my pinned characters. This is a handy shortcut for adding a title banner to the most recent photo, which I can use to share my latest superhero ideas with my friends. I found this great photo to use for my Stylizer superhero, who happens to also be an adorable dog. My custom shortcut added this fun banner to the top and overlaid the hero’s name. My shortcut also lets me share the photo. I’d love to get Taylor’s feedback, since he knows a thing or two about cool graphics. I can just add Taylor as a recipient and type in a quick message and send it off! What do you think, Taylor? Taylor Kelly: Thank you, Matt. It looks perfect. And it's definitely going to be your new contact photo. This adorable image is a great segue to the next section, Advanced Graphics. There's a bunch of exciting enhancements this year: from symbol updates, materials and vibrancy, to a powerful new canvas view. First up are symbols. SF Symbols are a great and easy way of adding beautiful iconography throughout your app. Not only are there many new ones this year, but they come with several new features to make their use in your app even easier and more expressive. There are two new rendering modes that give you even more control over how symbols are styled. Hierarchical uses the current foreground style to color the symbol, just like monochrome, but automatically adds multiple levels of opacity to really emphasize the key elements of the symbol. And palette gives you even more fine-grained control over individual layers of a symbol with custom fills. Check out \"What's new in SF Symbols\" for more information and design guidance on these new modes. Pairing perfectly with these is an update to the set of colors available in SwiftUI. These colors are optimized for all the different configurations they appear in: light and Dark Mode, specific appearances over blurs, and even the specific platform they’re shown on. In addition to different colors, symbols come in many different shapes. Many symbols have modifiers to show up as filled, circled, and more. Previously you had to hardcode these variants. But more than that, you had to know which variant was right to use in which context. The iOS Human Interface Guidelines describes how in tab bars, filled variants should be preferred, so you had to specifically include that .fill modifier in the name. This year, you don’t have to worry that. SwiftUI will automatically choose the right variant for you based on the context you use it in. All you have to do is provide the base symbol you’d like to use. And by not over-specifying the exact configuration you want, you also get code that is more reusable. For example, if we run this same code on macOS, we get the correct variant for that platform: outlines. To learn how to take advantage of this automatic support in your own custom views, as well as more symbol enhancements, check out \"SF Symbols in SwiftUI.\" There are now a lot of SF Symbols, so I wanted to build a cool visualizer to browse through all of them. This is a great use for SwiftUI's new Canvas view. Canvas supports immediate-mode drawing similar to drawRect from UIKit or AppKit. When composing lots of graphical elements that don't need individual tracking or invalidation, this is a great tool. Here I have a canvas displaying every single SF Symbol that comes with the OS. And for all 3166 of them, it draws each of them into their own frame. Canvas works on every platform. And since Canvas is a view like any other, we can also attach gestures, accessibility information, and update it based on state or the environment such as adapting to Dark Mode. Here, I've added a gesture that lets me set a focalPoint to zoom in on. And I'll update the frame and opacity of each symbol based on that. Now I can click and drag around and every symbol smoothly updates as the cursor moves around the screen. We can also make sure this is fully accessible by taking advantage of a new accessibilityChildren modifier. What’s so cool is that you reuse the same views you're used to using in SwiftUI to refine how it comes across through accessibility features. In this case, the symbols can now be enumerated like someone would otherwise browse elements in a list, speaking each element as they navigate through. This modifier isn’t restricted to just Canvas, but can be used with any view to really polish its accessibility experience. One final thing we can add to our canvas is updating over time, using the new TimelineView. A refinement to make for tvOS is to have that focalPoint animatedly move around the screen, acting like a screensaver. TimelineView is created with a schedule -- in this case, the animation schedule -- and it provides the current time it's rendering for. And so we can use that time to update the focalPoint in the transform, creating our beautiful symbol screensaver. This TimelineView can do so much more. A really cool feature of the Apple Watch is its Always On display. Previously your app would be blurred with the time overlaid when it enters the Always On state. And with watchOS 8 your app now dims by default, and you have more control over how it appears with SwiftUI giving you the tools you need, one of which is TimelineView. Once the watch goes into its Always On state, TimelineView can preload the display of your views at future dates. And as we move into the future, those view will automatically be displayed onscreen without ever taking your app from the background. A critical part of this is the TimelineSchedule. In this example, I'm using the simple everyMinute schedule so TimelineView will preload out the display of each minute on the minute, showing me the next symbol in the browser. There are several other kinds of schedules as well to help suit the needs of your app, such as a collection of explicit of dates, which works great for when there will be events at specific times. Now, another important aspect of this mode is hiding user-sensitive information since it could be visible to others. I'd really like to keep my favorite symbol private. And by simply adding the privacySensitive modifier, it will automatically be redacted when the watch enters the Always On state. Check out \"What's new in watchOS 8\" for more information on the Always On display and more. And this privacy-sensitive modifier also works in widgets as well. Widgets that are added to the Lock screen will use this to hide sensitive information while the device is still locked, and reveal once the device is unlocked. \"Principals of great widgets\" will go into more detail on this and other ways of building wonderful widgets for your apps. Materials are used across all of Apple’s platforms and apps to create beautiful visual effects that really emphasize their content, and now you can create them directly in SwiftUI! I've been experimenting with adding color and materials to my Symbol Browser, and I'm adding a material-backed overlay to display the number of symbols. Adding a material is as easy as adding a background. I'm using the ultraThinMaterial, and can give it any custom shape to fill. These materials automatically come with the expected vibrant blending of content on top of them when using primary, secondary, tertiary, and now even quaternary foreground styles. And emojis are automatically excluded from that, so they look exactly as they should. On the Mac, system context like sidebars and popovers automatically have blur material backgrounds and will also now have that expected vibrant appearance for the content within them. These new materials work great in conjunction with the new safeAreaInset modifier, which allows you to place content on top of a scrollable view and have the content position still start and end as expected. The \"rich graphics\" session goes into a lot more detail on canvas, materials, and more. And to wrap it up, complementing new ways to define these beautiful custom views are a couple of enhancements to SwiftUI previews in Xcode. First is a new preview orientation modifier that allows you to specify the orientation of the iOS device in the previews, and even mix and match previews across different orientations. And second is a big improvement to how you edit and view your app's accessibility in previews. The property editor now has a curated list of accessibility modifiers, making it even easier to polish views' accessibility behavior. And there is an entirely new way of viewing your previews with a new Accessibility Preview tab. You'll be shown a live, textual representation of the accessibility elements and their properties. This is the same information that powers accessibility features, but is now presented to you in a format that might be more familiar to you. Check out the \"SwiftUI Accessibility\" session for more information on this and much more about how to create an amazing accessibility experience for your app! Now, up next is a range of enhancements to text, text-related controls, and keyboard navigation. Text is so fundamental to every app. It’s one of the main ways your app communicates to people; it’s often the very first view you write. And this year, its gaining a lot of new exciting features from styling to localization, to interactions and formatting. First up is Markdown support. Text can now contain Markdown formatting directly inline. This can be used to add strong emphasis, links -- which can be interacted with -- and even code-style presentation. And this is all built on top of the new, powerful Swift-based AttributedString in Foundation. In addition to Markdown support, it brings an entire suite of rich, type-safe attributes, and the ability to define your own attributes and even use them within Markdown syntax. For more information on this and the amazing new Automatic Grammar agreement, check out \"What's new in Foundation.\" Importantly, text also localizes its content so that people across the world can use your app. And this is true of the new Markdown support as well, allowing language-sensitive attributes to be properly localized. Another great improvement to localization comes from Xcode 13. It now uses the Swift compiler to generate strings and localization catalogs from every use of LocalizedStringKey and the new localizedString and attributedString initializers. To learn more about this and other localization tips and tricks, check out \"Localize Your SwiftUI app.\" Now, in addition to these new ways of displaying text, there are new ways of making text even more dynamic. The first is an important accessibility feature: Dynamic Type. SwiftUI has supported Dynamic Type since its inception, and this year has a new API to allow restricting the range of type sizes a UI supports to keep it from getting too big or too small. This shows what our header looks like at the default large size. I personally use Dynamic Type to get some extra information density into my content, and this shows how the header stayed the same size at the small type size, since it's restricted to be, at minimum, the large size. At the other end of the spectrum, using the accessibility sizes does result in our header growing larger, but only up to the extra extra large size. While macOS doesn't support Dynamic Type, it does support another important text interaction: selectable text. This allows people to take action on noneditable text from your app, and that can now be enabled using the textSelection modifier. That modifier can be applied to any view, and it applies to all the text within it -- in this example, now applying to the text in the header. And we also introduced this modifier on iOS and iPadOS where it enables text to be copied or shared on long-press. Finally, Foundation's new format-style APIs make formatting text so much simpler, yet still allowing precise presentation. Here we have a date that applies the default formatting. And this is a variant that displays only the time, as used in the activity list. And finally, an expanded format that allows specifying the exact components to display. Our activity list also featured formatting an array of people into a properly localized presentation. Let's quickly walk through this. We're mapping our person values into an array of PersonNameComponents and formatting it using a list format style. And for each member in the list, using the PersonNameComponent format with a short style, showing just the first name. And finally, joining it with an \"and\" conjunction. All together, creating a performant and type-safe expression of formatting that properly handles any number of people. TextField has also gained support for these new format styles, allowing you to add editable formatted text with a type-safe binding to some underlying value. The new attendee field is bound to a PersonNameComponents value, and it's formatted using the standard name format. This takes care of parsing the input and producing the resulting person name. \"What’s new in Foundation\" also goes into detail on the power of these new format styles. TextField now also supports adding an explicit prompt, separate from its label, to let users know what kind of content a field is expecting. And when adding TextField to forms on macOS, they’ll align their labels similar to other controls and use the prompt as its placeholder content. Now, the entire point of a text field is adding text, and keyboards are our tool to do that. From software keyboards on iPhone to the iPad, which supports both software and hardware keyboards, and of course, macOS, which always has a hardware keyboard. This year, there’s several enhancements to make the experience of using a keyboard even better. With the new onSubmit modifier, you can easily add supplementary actions for when the field’s text is submitted by the user, such as by pressing the Return key. This modifier provides some extra flexibility in that it can even be applied to an entire form of controls. And to help give users a hint of what kind of action will occur when submitting a field, there's the new submitLabel modifier. On software keyboards, this will be used as the label for the Return key. And finally, we’ve made it possible to add accessory views to the keyboard using the new keyboard toolbar placement. These views will be shown in a toolbar above the software keyboard on iOS and iPadOS or in the Touch Bar on macOS. This is a great way to give users quick access to actions above the keyboard without dismissing it to avoid interrupting your app’s editing experience. Keyboards also serve another important role of navigation and focus, and this functionality exists on every platform; from using focus on watchOS to direct Digital Crown input, to using the Siri Remote to navigate around content on tvOS. For most things, SwiftUI just takes care of what views are focusable and how it moves between them. But sometimes there are extra refinements you can make to create even smoother experiences in your app. To help with that, SwiftUI has a new, powerful tool called FocusState. This is a property wrapper that both reflects the state of focus and provides precise control over it. At its simplest, it can reflect a Boolean value. This can be tied to a focusable view using the focused modifier. When that view is focused, the value will be true, and false when not. This value can also be written to, to control focus. For instance, in response to someone pressing a button. This example can act as an accelerator, allowing the user to immediately start typing after performing a related action. This Boolean version is a convenience for its full form, which is representing any hashable type. This code is functionally equivalent to the previous slide but with some increased flexibility. Let's walk through it. First, I've defined a simple enumeration of the fields that I might want to know are focused. The FocusState property uses that type to reflect the current state. It's optional to indicate potentially none of those having focused. Our focused modifier is still bound to that same focus state, but only when it equals addAttendee. And finally, when we want to focus that field, we set our focus state value to addAttendee. This new flexibility allows adding additional functionality, such as building the toolbar buttons from before, moving focus between each of the fields, and reflecting if focus reaches the beginning or the end. Focus state also provides a great way for iOS apps to dismiss the software keyboard by clearing out its value. If you're interested in learning more about other ways to refine the focus experience in your app, check out this year’s session, \"Direct and reflect focus in SwiftUI.\" Last, we’re going to focus in on buttons because buttons are important. We all know what a typical button looks like; it varies from platform to platform, and it is one of the simplest ways of allowing people to interact with your app. And especially in SwiftUI, buttons are used for a lot of things. Matt discussed earlier how swipe actions are composed out of buttons. And this year, there is a lot new with buttons. First, SwiftUI now has standard bordered buttons on iOS. You can make a button bordered just by adding a buttonStyle modifier, like I'm doing with this Add button. Like other style modifiers, this can be added to a group of controls and applies to all of them. It supports tinting for cases where you want a specific appearance for a given button. But for this UI, I like the default appearance that uses the accent color. There's more customization built in as well. First up is control size and prominence. I'm using these to customize the buttons representing the tags. They're using the new standard small control size and have a tint with increased prominence to really make them stand out. We can use these same modifiers to create another common kind of button: these large sized ones now built in to SwiftUI. By specifying the large control size, you'll automatically get these beautiful, rounded rectangle buttons. And to give them a sense of hierarchy, I modified the most important one to have increased prominence, filling it with a high-contrast accent color. And the secondary button can still be tinted but has a lower contrast. These buttons have few modifiers to make them great on the iPad, too. The text labels have a maximum width so that the overall button is flexible but doesn't get comically large. And the primary button has a default action keyboard shortcut, so when using the app with a keyboard, I can quickly hit the Return key to add this button to my jar. Now, many of this API has already existed on macOS, making it even easier to build apps for multiple platforms. The one new addition is adding increased prominent tint support to let you tastefully add these bright buttons to your apps. Note that nonprominent buttons, like these Add buttons, do not display any tint since their chrome is what indicates their interactivity on macOS. Having learned about prominence, I might be tempted to go and apply that to all of my Add buttons, but it can get overwhelming and confusing to have so many prominent buttons onscreen. It's best to reserve it for singular primary actions. The lower prominence tint is a great alternative for adding a splash of color on iOS. Now, my favorite thing about these new button styles is they automatically have the expected pressed and disabled states, Dark Mode support, and of course are fully accessible and compatible with Dynamic Type. And they help give consistency between apps. And buttons' new API doesn't stop here. SwiftUI has also added first-class support for buttons with additional semantics, such as marking a button as destructive, which will automatically give them the expected red tint. One new context this can also be used in are confirmation dialogs, which lets users confirm actions that have serious impact to their data. On iOS, this shows as an action sheet, on iPad as a popover, and on macOS as an alert. SwiftUI automatically handles following the design sensibilities of each platform. Next, let's talk about buttons that aren't \"capital B\" buttons. Currently, the app's Add buttons just add to the user's default jar. But for avid collectors, I want to support adding to specific jars. This is a perfect use case for a menu button. We'll use the same \"Add\" label, but present a menu of all of the possible jars once the button is clicked. However, these menu buttons visually carry a lot of prominence. We could hide the indicators using a new menuIndicator modifier added this year. And even without an indicator, this button still presents a menu on click. But for these buttons, ideally we'd get the best of both worlds: with a simple single click to add to the default jar and the flexibility of showing the menu of others. New this year is the ability to customize a menu's primary action to help with this kind of case. By default, a menu with a primary action has a two-segmented appearance on macOS. The main part of the button triggers the primary action in the indicator presenting the menu. And when the indicator is hidden, it again looks visually just like the button that I started with but has a behavioral distinction. A click triggers the primary action and a long-press shows the menu. And what's great is that this same thing works on iOS, too! Now these menus give a lot of flexibility, really catering to how your app needs to use them. Another new example of a control gaining a button style is Toggle. This creates a button that when tapped, visually turns on and off and can be used just like any other toggle. And joining these new control styles is a container that groups related controls; aptly called ControlGroup. On iOS, the controls in a group are organized a little tighter in the toolbar. And on macOS, there are visual affordances indicating the two grouped buttons. And to wrap this all up, naturally all of these things can be composed together. For instance, these standard back/forward buttons are a ControlGroup of two menus. Each of these menus have a primaryAction that is performed when clicked. And once the menu is long-pressed, they'll present their contents. Now, with just a few additional customizations on buttons and these new styles, a lot of flexibility has opened up on how you can use these controls in your apps. We ran through a lot in this session, and there’s even more that we didn’t have time to cover. We’re excited for you to take advantage of these new features in your own SwiftUI apps and adopt SwiftUI in even more places. Thank you and have a great rest of your 2021! ♪",
    "segments": []
  },
  "codeExamples": [
    {
      "timestamp": "3:29",
      "title": "AsyncImage",
      "language": "swift",
      "code": "struct ContentView: View {\n  @StateObject private var photoStore = PhotoStore()\n\n  var body: some View {\n    NavigationView {\n      ScrollView {\n        LazyVGrid(columns: [GridItem(.adaptive(minimum: 420))]) {\n          ForEach(photoStore.photos) { photo in\n            AsyncImage(url: photo.url)\n              .frame(width: 400, height: 266)\n              .mask(RoundedRectangle(cornerRadius: 16))\n          }\n        }\n        .padding()\n      }\n      .navigationTitle(\"Superhero Recruits\")\n    }\n    .navigationViewStyle(.stack)\n  }\n}\n\nclass PhotoStore: ObservableObject {\n  @Published var photos: [Photo] = [/* Default photos */]\n}\n\nstruct Photo: Identifiable {\n  var id: URL { url }\n  var url: URL\n}"
    },
    {
      "timestamp": "3:45",
      "title": "AsyncImage with custom placeholder",
      "language": "swift",
      "code": "struct ContentView: View {\n  @StateObject private var photoStore = PhotoStore()\n\n  var body: some View {\n    NavigationView {\n      ScrollView {\n        LazyVGrid(columns: [GridItem(.adaptive(minimum: 420))]) {\n          ForEach(photoStore.photos) { photo in\n            AsyncImage(url: photo.url) { image in\n              image\n                .resizable()\n                .aspectRatio(contentMode: .fill)\n            } placeholder: {\n              randomPlaceholderColor()\n                .opacity(0.2)\n            }\n            .frame(width: 400, height: 266)\n            .mask(RoundedRectangle(cornerRadius: 16))\n          }\n        }\n        .padding()\n      }\n      .navigationTitle(\"Superhero Recruits\")\n    }\n    .navigationViewStyle(.stack)\n  }\n}\n\nclass PhotoStore: ObservableObject {\n  @Published var photos: [Photo] = [/* Default photos */]\n}\n\nstruct Photo: Identifiable {\n  var id: URL { url }\n  var url: URL\n}\n\nfunc randomPlaceholderColor() -> Color {\n  placeholderColors.randomElement()!\n}\n\nlet placeholderColors: [Color] = [\n  .red, .blue, .orange, .mint, .purple, .yellow, .green, .pink\n]"
    },
    {
      "timestamp": "4:00",
      "title": "AsyncImage with custom animations and error handling",
      "language": "swift",
      "code": "struct Contentiew: View {\n  @StateObject private var photoStore = PhotoStore()\n\n  var body: some View {\n    NavigationView {\n      ScrollView {\n        LazyVGrid(columns: [GridItem(.adaptive(minimum: 420))]) {\n          ForEach(photoStore.photos) { photo in\n            AsyncImage(url: photo.url, transaction: .init(animation: .spring())) { phase in\n              switch phase {\n              case .empty:\n                randomPlaceholderColor()\n                  .opacity(0.2)\n                  .transition(.opacity.combined(with: .scale))\n              case .success(let image):\n                image\n                  .resizable()\n                  .aspectRatio(contentMode: .fill)\n                  .transition(.opacity.combined(with: .scale))\n              case .failure(let error):\n                ErrorView(error)\n              @unknown default:\n                ErrorView()\n              }\n            }\n            .frame(width: 400, height: 266)\n            .mask(RoundedRectangle(cornerRadius: 16))\n          }\n        }\n        .padding()\n      }\n      .navigationTitle(\"Superhero Recruits\")\n    }\n    .navigationViewStyle(.stack)\n  }\n}\n\nstruct ErrorView: View {\n  var error: Error?\n\n  init(_ error: Error? = nil) {\n    self.error = error\n  }\n\n  var body: some View {\n    Text(\"Error\") // Display the error\n  }\n}\n\nclass PhotoStore: ObservableObject {\n  @Published var photos: [Photo] = [/* Default photos */]\n}\n\nstruct Photo: Identifiable {\n  var id: URL { url }\n  var url: URL\n}\n\nfunc randomPlaceholderColor() -> Color {\n  placeholderColors.randomElement()!\n}\n\nlet placeholderColors: [Color] = [\n  .red, .blue, .orange, .mint, .purple, .yellow, .green, .pink\n]"
    },
    {
      "timestamp": "4:24",
      "title": "refreshable() modifier",
      "language": "swift",
      "code": "struct ContentView: View {\n  @StateObject private var photoStore = PhotoStore()\n\n  var body: some View {\n    NavigationView {\n      List {\n        ForEach(photoStore.photos) { photo in\n          AsyncImage(url: photo.url)\n            .frame(minHeight: 200)\n            .mask(RoundedRectangle(cornerRadius: 16))\n            .listRowSeparator(.hidden)\n        }\n      }\n      .listStyle(.plain)\n      .navigationTitle(\"Superhero Recruits\")\n      .refreshable {\n        await photoStore.update()\n      }\n    }\n  }\n}\n\nclass PhotoStore: ObservableObject {\n  @Published var photos: [Photo] = [/* Default photos */]\n\n  func update() async {\n    // Fetch new photos\n  }\n}\n\nstruct Photo: Identifiable {\n  var id: URL { url }\n  var url: URL\n}"
    },
    {
      "timestamp": "4:58",
      "title": "task() modifier",
      "language": "swift",
      "code": "struct ContentView: View {\n  @StateObject private var photoStore = PhotoStore()\n\n  var body: some View {\n    NavigationView {\n      List {\n        ForEach(photoStore.photos) { photo in\n          AsyncImage(url: photo.url)\n            .frame(minHeight: 200)\n            .mask(RoundedRectangle(cornerRadius: 16))\n            .listRowSeparator(.hidden)\n        }\n      }\n      .listStyle(.plain)\n      .navigationTitle(\"Superhero Recruits\")\n      .refreshable {\n        await photoStore.update()\n      }\n      .task {\n        await photoStore.update()\n      }\n    }\n  }\n}\n\nclass PhotoStore: ObservableObject {\n  @Published var photos: [Photo] = [/* Default photos */]\n\n  func update() async {\n    // Fetch new photos\n  }\n}\n\nstruct Photo: Identifiable {\n  var id: URL { url }\n  var url: URL\n}"
    },
    {
      "timestamp": "5:28",
      "title": "task() modifier iterating over an AsyncSequence",
      "language": "swift",
      "code": "struct ContentView: View {\n  @StateObject private var photoStore = PhotoStore()\n\n  var body: some View {\n    NavigationView {\n      List {\n        ForEach(photoStore.photos) { photo in\n          AsyncImage(url: photo.url)\n            .frame(minHeight: 200)\n            .mask(RoundedRectangle(cornerRadius: 16))\n            .listRowSeparator(.hidden)\n        }\n      }\n      .listStyle(.plain)\n      .navigationTitle(\"Superhero Recruits\")\n      .refreshable {\n        await photoStore.update()\n      }\n      .task {\n        for await photo in photoStore.newestPhotos {\n          photoStore.push(photo)\n        }\n      }\n    }\n  }\n}\n\nclass PhotoStore: ObservableObject {\n  @Published var photos: [Photo] = [/* Default photos */]\n\n  var newestPhotos: NewestPhotos {\n    NewestPhotos()\n  }\n\n  func update() async {\n    // Fetch new photos from remote service\n  }\n\n  func push(_ photo: Photo) {\n    photos.append(photo)\n  }\n}\n\nstruct NewestPhotos: AsyncSequence {\n  struct AsyncIterator: AsyncIteratorProtocol {\n    func next() async -> Photo? {\n      // Fetch next photo from remote service\n    }\n  }\n\n  func makeAsyncIterator() -> AsyncIterator {\n    AsyncIterator()\n  }\n}\n\nstruct Photo: Identifiable {\n  var id: URL { url }\n  var url: URL\n}"
    },
    {
      "timestamp": "7:02",
      "title": "Non-interactive directions list",
      "language": "swift",
      "code": "struct ContentView: View {\n  @State var directions: [Direction] = [\n    Direction(symbol: \"car\", color: .mint, text: \"Drive to SFO\"),\n    Direction(symbol: \"airplane\", color: .blue, text: \"Fly to SJC\"),\n    Direction(symbol: \"tram\", color: .purple, text: \"Ride to Cupertino\"),\n    Direction(symbol: \"bicycle\", color: .orange, text: \"Bike to Apple Park\"),\n    Direction(symbol: \"figure.walk\", color: .green, text: \"Walk to pond\"),\n    Direction(symbol: \"lifepreserver\", color: .blue, text: \"Swim to the center\"),\n    Direction(symbol: \"drop\", color: .indigo, text: \"Dive to secret airlock\"),\n    Direction(symbol: \"tram.tunnel.fill\", color: .brown, text: \"Ride through underground tunnels\"),\n    Direction(symbol: \"key\", color: .red, text: \"Enter door code:\"),\n  ]\n\n  var body: some View {\n    NavigationView {\n      List(directions) { direction in\n        Label {\n          Text(direction.text)\n        } icon: {\n          DirectionsIcon(direction)\n        }\n      }\n      .listStyle(.sidebar)\n      .navigationTitle(\"Secret Hideout\")\n    }\n  }\n}\n\nstruct Direction: Identifiable {\n  var id = UUID()\n  var symbol: String\n  var color: Color\n  var text: String\n}\n\nprivate struct DirectionsIcon: View {\n  var direction: Direction\n\n  init(_ direction: Direction) {\n    self.direction = direction\n  }\n\n  var body: some View {\n    Image(systemName: direction.symbol)\n      .resizable()\n      .aspectRatio(contentMode: .fit)\n      .foregroundStyle(.white)\n      .padding(6)\n      .frame(width: 33, height: 33)\n      .background(direction.color, in: RoundedRectangle(cornerRadius: 8))\n  }\n}"
    },
    {
      "timestamp": "8:08",
      "title": "Interactive directions list",
      "language": "swift",
      "code": "struct ContentView: View {\n  @State var directions: [Direction] = [\n    Direction(symbol: \"car\", color: .mint, text: \"Drive to SFO\"),\n    Direction(symbol: \"airplane\", color: .blue, text: \"Fly to SJC\"),\n    Direction(symbol: \"tram\", color: .purple, text: \"Ride to Cupertino\"),\n    Direction(symbol: \"bicycle\", color: .orange, text: \"Bike to Apple Park\"),\n    Direction(symbol: \"figure.walk\", color: .green, text: \"Walk to pond\"),\n    Direction(symbol: \"lifepreserver\", color: .blue, text: \"Swim to the center\"),\n    Direction(symbol: \"drop\", color: .indigo, text: \"Dive to secret airlock\"),\n    Direction(symbol: \"tram.tunnel.fill\", color: .brown, text: \"Ride through underground tunnels\"),\n    Direction(symbol: \"key\", color: .red, text: \"Enter door code:\"),\n  ]\n\n  var body: some View {\n    NavigationView {\n      List($directions) { $direction in\n        Label {\n          TextField(\"Instructions\", text: $direction.text)\n        } icon: {\n          DirectionsIcon(direction)\n        }\n      }\n      .listStyle(.sidebar)\n      .navigationTitle(\"Secret Hideout\")\n    }\n  }\n}\n\nstruct Direction: Identifiable {\n  var id = UUID()\n  var symbol: String\n  var color: Color\n  var text: String\n}\n\nprivate struct DirectionsIcon: View {\n  var direction: Direction\n\n  init(_ direction: Direction) {\n    self.direction = direction\n  }\n\n  var body: some View {\n    Image(systemName: direction.symbol)\n      .resizable()\n      .aspectRatio(contentMode: .fit)\n      .foregroundStyle(.white)\n      .padding(6)\n      .frame(width: 33, height: 33)\n      .background(direction.color, in: RoundedRectangle(cornerRadius: 8))\n  }\n}"
    },
    {
      "timestamp": "8:49",
      "title": "Interactive directions list using ForEach",
      "language": "swift",
      "code": "struct ContentView: View {\n  @State var directions: [Direction] = [\n    Direction(symbol: \"car\", color: .mint, text: \"Drive to SFO\"),\n    Direction(symbol: \"airplane\", color: .blue, text: \"Fly to SJC\"),\n    Direction(symbol: \"tram\", color: .purple, text: \"Ride to Cupertino\"),\n    Direction(symbol: \"bicycle\", color: .orange, text: \"Bike to Apple Park\"),\n    Direction(symbol: \"figure.walk\", color: .green, text: \"Walk to pond\"),\n    Direction(symbol: \"lifepreserver\", color: .blue, text: \"Swim to the center\"),\n    Direction(symbol: \"drop\", color: .indigo, text: \"Dive to secret airlock\"),\n    Direction(symbol: \"tram.tunnel.fill\", color: .brown, text: \"Ride through underground tunnels\"),\n    Direction(symbol: \"key\", color: .red, text: \"Enter door code:\"),\n  ]\n\n  var body: some View {\n    NavigationView {\n      List {\n        ForEach($directions) { $direction in\n          Label {\n            TextField(\"Instructions\", text: $direction.text)\n          } icon: {\n            DirectionsIcon(direction)\n          }\n        }\n      }\n      .listStyle(.sidebar)\n      .navigationTitle(\"Secret Hideout\")\n    }\n  }\n}\n\nstruct Direction: Identifiable {\n  var id = UUID()\n  var symbol: String\n  var color: Color\n  var text: String\n}\n\nprivate struct DirectionsIcon: View {\n  var direction: Direction\n\n  init(_ direction: Direction) {\n    self.direction = direction\n  }\n\n  var body: some View {\n    Image(systemName: direction.symbol)\n      .resizable()\n      .aspectRatio(contentMode: .fit)\n      .foregroundStyle(.white)\n      .padding(6)\n      .frame(width: 33, height: 33)\n      .background(direction.color, in: RoundedRectangle(cornerRadius: 8))\n  }\n}"
    },
    {
      "timestamp": "9:09",
      "title": "listRowSeparatorTint() modifier",
      "language": "swift",
      "code": "struct ContentView: View {\n  @State var directions: [Direction] = [\n    Direction(symbol: \"car\", color: .mint, text: \"Drive to SFO\"),\n    Direction(symbol: \"airplane\", color: .blue, text: \"Fly to SJC\"),\n    Direction(symbol: \"tram\", color: .purple, text: \"Ride to Cupertino\"),\n    Direction(symbol: \"bicycle\", color: .orange, text: \"Bike to Apple Park\"),\n    Direction(symbol: \"figure.walk\", color: .green, text: \"Walk to pond\"),\n    Direction(symbol: \"lifepreserver\", color: .blue, text: \"Swim to the center\"),\n    Direction(symbol: \"drop\", color: .indigo, text: \"Dive to secret airlock\"),\n    Direction(symbol: \"tram.tunnel.fill\", color: .brown, text: \"Ride through underground tunnels\"),\n    Direction(symbol: \"key\", color: .red, text: \"Enter door code:\"),\n  ]\n\n  var body: some View {\n    NavigationView {\n      List {\n        ForEach($directions) { $direction in\n          Label {\n            TextField(\"Instructions\", text: $direction.text)\n          } icon: {\n            DirectionsIcon(direction)\n          }\n          .listRowSeparatorTint(direction.color)\n        }\n      }\n      .listStyle(.sidebar)\n      .navigationTitle(\"Secret Hideout\")\n    }\n  }\n}\n\nstruct Direction: Identifiable {\n  var id = UUID()\n  var symbol: String\n  var color: Color\n  var text: String\n}\n\nprivate struct DirectionsIcon: View {\n  var direction: Direction\n\n  init(_ direction: Direction) {\n    self.direction = direction\n  }\n\n  var body: some View {\n    Image(systemName: direction.symbol)\n      .resizable()\n      .aspectRatio(contentMode: .fit)\n      .foregroundStyle(.white)\n      .padding(6)\n      .frame(width: 33, height: 33)\n      .background(direction.color, in: RoundedRectangle(cornerRadius: 8))\n  }\n}"
    },
    {
      "timestamp": "9:38",
      "title": "listRowSeparator() modifier",
      "language": "swift",
      "code": "struct ContentView: View {\n  @State var directions: [Direction] = [\n    Direction(symbol: \"car\", color: .mint, text: \"Drive to SFO\"),\n    Direction(symbol: \"airplane\", color: .blue, text: \"Fly to SJC\"),\n    Direction(symbol: \"tram\", color: .purple, text: \"Ride to Cupertino\"),\n    Direction(symbol: \"bicycle\", color: .orange, text: \"Bike to Apple Park\"),\n    Direction(symbol: \"figure.walk\", color: .green, text: \"Walk to pond\"),\n    Direction(symbol: \"lifepreserver\", color: .blue, text: \"Swim to the center\"),\n    Direction(symbol: \"drop\", color: .indigo, text: \"Dive to secret airlock\"),\n    Direction(symbol: \"tram.tunnel.fill\", color: .brown, text: \"Ride through underground tunnels\"),\n    Direction(symbol: \"key\", color: .red, text: \"Enter door code:\"),\n  ]\n\n  var body: some View {\n    NavigationView {\n      List {\n        ForEach($directions) { $direction in\n          Label {\n            TextField(\"Instructions\", text: $direction.text)\n          } icon: {\n            DirectionsIcon(direction)\n          }\n          .listRowSeparator(.hidden)\n        }\n      }\n      .listStyle(.sidebar)\n      .navigationTitle(\"Secret Hideout\")\n    }\n  }\n}\n\nstruct Direction: Identifiable {\n  var id = UUID()\n  var symbol: String\n  var color: Color\n  var text: String\n}\n\nprivate struct DirectionsIcon: View {\n  var direction: Direction\n\n  init(_ direction: Direction) {\n    self.direction = direction\n  }\n\n  var body: some View {\n    Image(systemName: direction.symbol)\n      .resizable()\n      .aspectRatio(contentMode: .fit)\n      .foregroundStyle(.white)\n      .padding(6)\n      .frame(width: 33, height: 33)\n      .background(direction.color, in: RoundedRectangle(cornerRadius: 8))\n  }\n}"
    },
    {
      "timestamp": "10:08",
      "title": "Swipe actions",
      "language": "swift",
      "code": "struct ContentView: View {\n  @State private var characters = CharacterStore(StoryCharacter.previewData)\n\n  var body: some View {\n    NavigationView {\n      List {\n        if !characters.pinned.isEmpty {\n          Section(\"Pinned\") {\n            sectionContent(for: $characters.pinned)\n          }\n        }\n        Section(\"Heroes & Villains\") {\n          sectionContent(for: $characters.unpinned)\n        }\n      }\n      .listStyle(.sidebar)\n      .navigationTitle(\"Characters\")\n    }\n  }\n\n  @ViewBuilder\n  private func sectionContent(for characters: Binding<[StoryCharacter]>) -> some View {\n    ForEach(characters) { $character in\n      CharacterProfile(character)\n        .swipeActions {\n          Button {\n            togglePinned(for: $character)\n          } label: {\n            if character.isPinned {\n              Label(\"Unpin\", systemImage: \"pin.slash\")\n            } else {\n              Label(\"Pin\", systemImage: \"pin\")\n            }\n          }\n          .tint(.yellow)\n        }\n    }\n  }\n\n  private func togglePinned(for character: Binding<StoryCharacter>) {\n    withAnimation {\n      var tmp = character.wrappedValue\n      tmp.isPinned.toggle()\n      tmp.lastModified = Date()\n      character.wrappedValue = tmp\n    }\n  }\n\n  private func delete<C: RangeReplaceableCollection & MutableCollection>(\n    _ character: StoryCharacter, in characters: Binding<C>\n  ) where C.Element == StoryCharacter {\n    withAnimation {\n      if let i = characters.wrappedValue.firstIndex(where: {\n        $0.id == character.id\n      }) {\n        characters.wrappedValue.remove(at: i)\n      }\n    }\n  }\n}\n\nstruct CharacterProfile: View {\n  var character: StoryCharacter\n\n  init(_ character: StoryCharacter) {\n    self.character = character\n  }\n\n  var body: some View {\n    NavigationLink {\n      Text(character.name)\n    } label: {\n      HStack {\n        HStack {\n          let symbol = Image(systemName: character.symbol)\n            .resizable()\n            .aspectRatio(contentMode: .fit)\n            .foregroundStyle(.white)\n            .padding(6)\n            .frame(width: 33, height: 33)\n\n          if character.isVillain {\n            symbol\n              .background(character.color, in: RoundedRectangle(cornerRadius: 8))\n          } else {\n            symbol\n              .background(character.color, in: Circle())\n          }\n        }\n        VStack(alignment: .leading, spacing: 2) {\n          HStack(alignment: .center) {\n            Text(character.name)\n              .bold()\n              .foregroundStyle(.primary)\n          }\n          HStack(spacing: 4) {\n            Text(character.isVillain ? \"VILLAIN\" : \"HERO\")\n              .bold()\n              .font(.caption2.weight(.heavy))\n              .foregroundStyle(.white)\n              .padding(.vertical, 1)\n              .padding(.horizontal, 3)\n              .background(.quaternary, in: RoundedRectangle(cornerRadius: 3))\n\n            Text(character.powers)\n              .font(.footnote)\n              .foregroundStyle(.secondary)\n          }\n        }\n      }\n    }\n  }\n}\n\nstruct CharacterStore {\n  var all: [StoryCharacter] {\n    get { _all }\n    set { _all = newValue; sortAll() }\n  }\n  var _all: [StoryCharacter]\n\n  var pinned: [StoryCharacter] {\n    get {\n      all.prefix { $0.isPinned }\n    }\n    set {\n      if let end = all.firstIndex(where: { !$0.isPinned }) {\n        all.replaceSubrange(all.startIndex..<end, with: newValue)\n      }\n    }\n  }\n\n  var unpinned: [StoryCharacter] {\n    get {\n      if let start = all.firstIndex(where: { !$0.isPinned }) {\n        return Array(all.suffix(from: start))\n      } else {\n        return []\n      }\n    }\n    set {\n      if let start = all.firstIndex(where: { !$0.isPinned }) {\n        all.replaceSubrange(start..<all.endIndex, with: newValue)\n      }\n    }\n  }\n\n  init(_ characters: [StoryCharacter]) {\n    _all = characters\n    sortAll()\n  }\n\n  private mutating func sortAll() {\n    _all.sort { lhs, rhs in\n      if lhs.isPinned && !rhs.isPinned {\n        return true\n      } else if !lhs.isPinned && rhs.isPinned {\n        return false\n      } else {\n        return lhs.lastModified < rhs.lastModified\n      }\n    }\n  }\n}\n\nstruct StoryCharacter: Identifiable, Equatable {\n  var id: Int64\n  var name: String\n  var symbol: String\n  var color: Color\n  var powers: String\n  var isVillain: Bool = false\n  var isPinned: Bool = false\n  var lastModified = Date()\n}\n\nextension StoryCharacter {\n  static let previewData: [StoryCharacter] = [\n    StoryCharacter(\n      id: 0,\n      name: \"The View Builder\",\n      symbol: \"hammer\",\n      color: .pink,\n      powers: \"Conjures objects on-demand.\",\n      isPinned: true),\n    StoryCharacter(\n      id: 1,\n      name: \"The Truth Duplicator\",\n      symbol: \"eyes\",\n      color: .blue,\n      powers: \"Distorts reality.\",\n      isVillain: true),\n    StoryCharacter(\n      id: 2,\n      name: \"The Previewer\",\n      symbol: \"viewfinder\",\n      color: .indigo,\n      powers: \"Reveals the future.\",\n      isPinned: true),\n    StoryCharacter(\n      id: 3,\n      name: \"The Type Eraser\",\n      symbol: \"eye.slash\",\n      color: .black,\n      powers: \"Steals identities.\",\n      isVillain: true,\n      isPinned: true),\n    StoryCharacter(\n      id: 4,\n      name: \"The Environment Modifier\",\n      symbol: \"leaf\",\n      color: .green,\n      powers: \"Controls the physical world.\"),\n    StoryCharacter(\n      id: 5,\n      name: \"The Unstable Identifier\",\n      symbol: \"shuffle\",\n      color: .brown,\n      powers: \"Shape-shifter, uncatchable.\",\n      isVillain: true),\n    StoryCharacter(\n      id: 6,\n      name: \"The Stylizer\",\n      symbol: \"wand.and.stars.inverse\",\n      color: .red,\n      powers: \"Quartermaster of heroes.\"),\n    StoryCharacter(\n      id: 7,\n      name: \"The Singleton\",\n      symbol: \"diamond\",\n      color: .purple,\n      powers: \"An evil robotic hive mind.\",\n      isVillain: true),\n    StoryCharacter(\n      id: 8,\n      name: \"The Geometry Reader\",\n      symbol: \"ruler\",\n      color: .orange,\n      powers: \"Instantly scans any structure.\"),\n    StoryCharacter(\n      id: 9,\n      name: \"The Opaque Typist\",\n      symbol: \"app.fill\",\n      color: .teal,\n      powers: \"Creates impenetrable disguises.\"),\n    StoryCharacter(\n      id: 10,\n      name: \"The Unobservable Man\",\n      symbol: \"hand.raised.slash\",\n      color: .black,\n      powers: \"Impervious to detection.\",\n      isVillain: true),\n  ]\n}"
    },
    {
      "timestamp": "10:27",
      "title": "Swipe actions on the leading edge",
      "language": "swift",
      "code": "struct ContentView: View {\n  @State private var characters = CharacterStore(StoryCharacter.previewData)\n\n  var body: some View {\n    NavigationView {\n      List {\n        if !characters.pinned.isEmpty {\n          Section(\"Pinned\") {\n            sectionContent(for: $characters.pinned)\n          }\n        }\n        Section(\"Heroes & Villains\") {\n          sectionContent(for: $characters.unpinned)\n        }\n      }\n      .listStyle(.sidebar)\n      .navigationTitle(\"Characters\")\n    }\n  }\n\n  @ViewBuilder\n  private func sectionContent(for characters: Binding<[StoryCharacter]>) -> some View {\n    ForEach(characters) { $character in\n      CharacterProfile(character)\n        .swipeActions(edge: .leading) {\n          Button {\n            togglePinned(for: $character)\n          } label: {\n            if character.isPinned {\n              Label(\"Unpin\", systemImage: \"pin.slash\")\n            } else {\n              Label(\"Pin\", systemImage: \"pin\")\n            }\n          }\n          .tint(.yellow)\n        }\n    }\n  }\n\n  private func togglePinned(for character: Binding<StoryCharacter>) {\n    withAnimation {\n      var tmp = character.wrappedValue\n      tmp.isPinned.toggle()\n      tmp.lastModified = Date()\n      character.wrappedValue = tmp\n    }\n  }\n\n  private func delete<C: RangeReplaceableCollection & MutableCollection>(\n    _ character: StoryCharacter, in characters: Binding<C>\n  ) where C.Element == StoryCharacter {\n    withAnimation {\n      if let i = characters.wrappedValue.firstIndex(where: {\n        $0.id == character.id\n      }) {\n        characters.wrappedValue.remove(at: i)\n      }\n    }\n  }\n}\n\nstruct CharacterProfile: View {\n  var character: StoryCharacter\n\n  init(_ character: StoryCharacter) {\n    self.character = character\n  }\n\n  var body: some View {\n    NavigationLink {\n      Text(character.name)\n    } label: {\n      HStack {\n        HStack {\n          let symbol = Image(systemName: character.symbol)\n            .resizable()\n            .aspectRatio(contentMode: .fit)\n            .foregroundStyle(.white)\n            .padding(6)\n            .frame(width: 33, height: 33)\n\n          if character.isVillain {\n            symbol\n              .background(character.color, in: RoundedRectangle(cornerRadius: 8))\n          } else {\n            symbol\n              .background(character.color, in: Circle())\n          }\n        }\n        VStack(alignment: .leading, spacing: 2) {\n          HStack(alignment: .center) {\n            Text(character.name)\n              .bold()\n              .foregroundStyle(.primary)\n          }\n          HStack(spacing: 4) {\n            Text(character.isVillain ? \"VILLAIN\" : \"HERO\")\n              .bold()\n              .font(.caption2.weight(.heavy))\n              .foregroundStyle(.white)\n              .padding(.vertical, 1)\n              .padding(.horizontal, 3)\n              .background(.quaternary, in: RoundedRectangle(cornerRadius: 3))\n\n            Text(character.powers)\n              .font(.footnote)\n              .foregroundStyle(.secondary)\n          }\n        }\n      }\n    }\n  }\n}\n\nstruct CharacterStore {\n  var all: [StoryCharacter] {\n    get { _all }\n    set { _all = newValue; sortAll() }\n  }\n  var _all: [StoryCharacter]\n\n  var pinned: [StoryCharacter] {\n    get {\n      all.prefix { $0.isPinned }\n    }\n    set {\n      if let end = all.firstIndex(where: { !$0.isPinned }) {\n        all.replaceSubrange(all.startIndex..<end, with: newValue)\n      }\n    }\n  }\n\n  var unpinned: [StoryCharacter] {\n    get {\n      if let start = all.firstIndex(where: { !$0.isPinned }) {\n        return Array(all.suffix(from: start))\n      } else {\n        return []\n      }\n    }\n    set {\n      if let start = all.firstIndex(where: { !$0.isPinned }) {\n        all.replaceSubrange(start..<all.endIndex, with: newValue)\n      }\n    }\n  }\n\n  init(_ characters: [StoryCharacter]) {\n    _all = characters\n    sortAll()\n  }\n\n  private mutating func sortAll() {\n    _all.sort { lhs, rhs in\n      if lhs.isPinned && !rhs.isPinned {\n        return true\n      } else if !lhs.isPinned && rhs.isPinned {\n        return false\n      } else {\n        return lhs.lastModified < rhs.lastModified\n      }\n    }\n  }\n}\n\nstruct StoryCharacter: Identifiable, Equatable {\n  var id: Int64\n  var name: String\n  var symbol: String\n  var color: Color\n  var powers: String\n  var isVillain: Bool = false\n  var isPinned: Bool = false\n  var lastModified = Date()\n}\n\nextension StoryCharacter {\n  static let previewData: [StoryCharacter] = [\n    StoryCharacter(\n      id: 0,\n      name: \"The View Builder\",\n      symbol: \"hammer\",\n      color: .pink,\n      powers: \"Conjures objects on-demand.\",\n      isPinned: true),\n    StoryCharacter(\n      id: 1,\n      name: \"The Truth Duplicator\",\n      symbol: \"eyes\",\n      color: .blue,\n      powers: \"Distorts reality.\",\n      isVillain: true),\n    StoryCharacter(\n      id: 2,\n      name: \"The Previewer\",\n      symbol: \"viewfinder\",\n      color: .indigo,\n      powers: \"Reveals the future.\",\n      isPinned: true),\n    StoryCharacter(\n      id: 3,\n      name: \"The Type Eraser\",\n      symbol: \"eye.slash\",\n      color: .black,\n      powers: \"Steals identities.\",\n      isVillain: true,\n      isPinned: true),\n    StoryCharacter(\n      id: 4,\n      name: \"The Environment Modifier\",\n      symbol: \"leaf\",\n      color: .green,\n      powers: \"Controls the physical world.\"),\n    StoryCharacter(\n      id: 5,\n      name: \"The Unstable Identifier\",\n      symbol: \"shuffle\",\n      color: .brown,\n      powers: \"Shape-shifter, uncatchable.\",\n      isVillain: true),\n    StoryCharacter(\n      id: 6,\n      name: \"The Stylizer\",\n      symbol: \"wand.and.stars.inverse\",\n      color: .red,\n      powers: \"Quartermaster of heroes.\"),\n    StoryCharacter(\n      id: 7,\n      name: \"The Singleton\",\n      symbol: \"diamond\",\n      color: .purple,\n      powers: \"An evil robotic hive mind.\",\n      isVillain: true),\n    StoryCharacter(\n      id: 8,\n      name: \"The Geometry Reader\",\n      symbol: \"ruler\",\n      color: .orange,\n      powers: \"Instantly scans any structure.\"),\n    StoryCharacter(\n      id: 9,\n      name: \"The Opaque Typist\",\n      symbol: \"app.fill\",\n      color: .teal,\n      powers: \"Creates impenetrable disguises.\"),\n    StoryCharacter(\n      id: 10,\n      name: \"The Unobservable Man\",\n      symbol: \"hand.raised.slash\",\n      color: .black,\n      powers: \"Impervious to detection.\",\n      isVillain: true),\n  ]\n}"
    },
    {
      "timestamp": "10:32",
      "title": "Swipe actions on both edges",
      "language": "swift",
      "code": "struct ContentView: View {\n  @State private var characters = CharacterStore(StoryCharacter.previewData)\n\n  var body: some View {\n    NavigationView {\n      List {\n        if !characters.pinned.isEmpty {\n          Section(\"Pinned\") {\n            sectionContent(for: $characters.pinned)\n          }\n        }\n        Section(\"Heroes & Villains\") {\n          sectionContent(for: $characters.unpinned)\n        }\n      }\n      .listStyle(.sidebar)\n      .navigationTitle(\"Characters\")\n    }\n  }\n\n  @ViewBuilder\n  private func sectionContent(for characters: Binding<[StoryCharacter]>) -> some View {\n    ForEach(characters) { $character in\n      CharacterProfile(character)\n        .swipeActions(edge: .leading) {\n          Button {\n            togglePinned(for: $character)\n          } label: {\n            if character.isPinned {\n              Label(\"Unpin\", systemImage: \"pin.slash\")\n            } else {\n              Label(\"Pin\", systemImage: \"pin\")\n            }\n          }\n          .tint(.yellow)\n        }\n        .swipeActions(edge: .trailing) {\n          Button(role: .destructive) {\n            delete(character, in: characters)\n          } label: {\n            Label(\"Delete\", systemImage: \"trash\")\n          }\n          Button {\n            // Open \"More\" menu\n          } label: {\n            Label(\"More\", systemImage: \"ellipsis.circle\")\n          }\n          .tint(Color(white: 0.8))\n        }\n    }\n  }\n\n  private func togglePinned(for character: Binding<StoryCharacter>) {\n    withAnimation {\n      var tmp = character.wrappedValue\n      tmp.isPinned.toggle()\n      tmp.lastModified = Date()\n      character.wrappedValue = tmp\n    }\n  }\n\n  private func delete<C: RangeReplaceableCollection & MutableCollection>(\n    _ character: StoryCharacter, in characters: Binding<C>\n  ) where C.Element == StoryCharacter {\n    withAnimation {\n      if let i = characters.wrappedValue.firstIndex(where: {\n        $0.id == character.id\n      }) {\n        characters.wrappedValue.remove(at: i)\n      }\n    }\n  }\n}\n\nstruct CharacterProfile: View {\n  var character: StoryCharacter\n\n  init(_ character: StoryCharacter) {\n    self.character = character\n  }\n\n  var body: some View {\n    NavigationLink {\n      Text(character.name)\n    } label: {\n      HStack {\n        HStack {\n          let symbol = Image(systemName: character.symbol)\n            .resizable()\n            .aspectRatio(contentMode: .fit)\n            .foregroundStyle(.white)\n            .padding(6)\n            .frame(width: 33, height: 33)\n\n          if character.isVillain {\n            symbol\n              .background(character.color, in: RoundedRectangle(cornerRadius: 8))\n          } else {\n            symbol\n              .background(character.color, in: Circle())\n          }\n        }\n        VStack(alignment: .leading, spacing: 2) {\n          HStack(alignment: .center) {\n            Text(character.name)\n              .bold()\n              .foregroundStyle(.primary)\n          }\n          HStack(spacing: 4) {\n            Text(character.isVillain ? \"VILLAIN\" : \"HERO\")\n              .bold()\n              .font(.caption2.weight(.heavy))\n              .foregroundStyle(.white)\n              .padding(.vertical, 1)\n              .padding(.horizontal, 3)\n              .background(.quaternary, in: RoundedRectangle(cornerRadius: 3))\n\n            Text(character.powers)\n              .font(.footnote)\n              .foregroundStyle(.secondary)\n          }\n        }\n      }\n    }\n  }\n}\n\nstruct CharacterStore {\n  var all: [StoryCharacter] {\n    get { _all }\n    set { _all = newValue; sortAll() }\n  }\n  var _all: [StoryCharacter]\n\n  var pinned: [StoryCharacter] {\n    get {\n      all.prefix { $0.isPinned }\n    }\n    set {\n      if let end = all.firstIndex(where: { !$0.isPinned }) {\n        all.replaceSubrange(all.startIndex..<end, with: newValue)\n      }\n    }\n  }\n\n  var unpinned: [StoryCharacter] {\n    get {\n      if let start = all.firstIndex(where: { !$0.isPinned }) {\n        return Array(all.suffix(from: start))\n      } else {\n        return []\n      }\n    }\n    set {\n      if let start = all.firstIndex(where: { !$0.isPinned }) {\n        all.replaceSubrange(start..<all.endIndex, with: newValue)\n      }\n    }\n  }\n\n  init(_ characters: [StoryCharacter]) {\n    _all = characters\n    sortAll()\n  }\n\n  private mutating func sortAll() {\n    _all.sort { lhs, rhs in\n      if lhs.isPinned && !rhs.isPinned {\n        return true\n      } else if !lhs.isPinned && rhs.isPinned {\n        return false\n      } else {\n        return lhs.lastModified < rhs.lastModified\n      }\n    }\n  }\n}\n\nstruct StoryCharacter: Identifiable, Equatable {\n  var id: Int64\n  var name: String\n  var symbol: String\n  var color: Color\n  var powers: String\n  var isVillain: Bool = false\n  var isPinned: Bool = false\n  var lastModified = Date()\n}\n\nextension StoryCharacter {\n  static let previewData: [StoryCharacter] = [\n    StoryCharacter(\n      id: 0,\n      name: \"The View Builder\",\n      symbol: \"hammer\",\n      color: .pink,\n      powers: \"Conjures objects on-demand.\",\n      isPinned: true),\n    StoryCharacter(\n      id: 1,\n      name: \"The Truth Duplicator\",\n      symbol: \"eyes\",\n      color: .blue,\n      powers: \"Distorts reality.\",\n      isVillain: true),\n    StoryCharacter(\n      id: 2,\n      name: \"The Previewer\",\n      symbol: \"viewfinder\",\n      color: .indigo,\n      powers: \"Reveals the future.\",\n      isPinned: true),\n    StoryCharacter(\n      id: 3,\n      name: \"The Type Eraser\",\n      symbol: \"eye.slash\",\n      color: .black,\n      powers: \"Steals identities.\",\n      isVillain: true,\n      isPinned: true),\n    StoryCharacter(\n      id: 4,\n      name: \"The Environment Modifier\",\n      symbol: \"leaf\",\n      color: .green,\n      powers: \"Controls the physical world.\"),\n    StoryCharacter(\n      id: 5,\n      name: \"The Unstable Identifier\",\n      symbol: \"shuffle\",\n      color: .brown,\n      powers: \"Shape-shifter, uncatchable.\",\n      isVillain: true),\n    StoryCharacter(\n      id: 6,\n      name: \"The Stylizer\",\n      symbol: \"wand.and.stars.inverse\",\n      color: .red,\n      powers: \"Quartermaster of heroes.\"),\n    StoryCharacter(\n      id: 7,\n      name: \"The Singleton\",\n      symbol: \"diamond\",\n      color: .purple,\n      powers: \"An evil robotic hive mind.\",\n      isVillain: true),\n    StoryCharacter(\n      id: 8,\n      name: \"The Geometry Reader\",\n      symbol: \"ruler\",\n      color: .orange,\n      powers: \"Instantly scans any structure.\"),\n    StoryCharacter(\n      id: 9,\n      name: \"The Opaque Typist\",\n      symbol: \"app.fill\",\n      color: .teal,\n      powers: \"Creates impenetrable disguises.\"),\n    StoryCharacter(\n      id: 10,\n      name: \"The Unobservable Man\",\n      symbol: \"hand.raised.slash\",\n      color: .black,\n      powers: \"Impervious to detection.\",\n      isVillain: true),\n  ]\n}"
    },
    {
      "timestamp": "11:14",
      "title": "Basic macOS list",
      "language": "swift",
      "code": "struct ContentView: View {\n  @State private var characters = StoryCharacter.previewData\n  @State private var selection = Set<StoryCharacter.ID>()\n\n  var body: some View {\n    List(selection: $selection) {\n      ForEach(characters) { character in\n        Label {\n          Text(character.name)\n        } icon: {\n          CharacterIcon(character)\n        }\n        .padding(.leading, 4)\n      }\n    }\n    .listStyle(.inset)\n    .navigationTitle(\"All Characters\")\n  }\n}\n\nstruct CharacterIcon: View {\n  var character: StoryCharacter\n\n  init(_ character: StoryCharacter) {\n    self.character = character\n  }\n\n  var body: some View {\n    HStack {\n      let symbol = Image(systemName: character.symbol)\n        .resizable()\n        .aspectRatio(contentMode: .fit)\n        .foregroundStyle(.white)\n        .padding(4)\n        .frame(width: 20, height: 20)\n\n      if character.isVillain {\n        symbol\n          .background(character.color, in: RoundedRectangle(cornerRadius: 4))\n      } else {\n        symbol\n          .background(character.color, in: Circle())\n      }\n    }\n  }\n}\n\nstruct CharacterStore {\n  var all: [StoryCharacter] {\n    get { _all }\n    set { _all = newValue; sortAll() }\n  }\n  var _all: [StoryCharacter]\n\n  var pinned: [StoryCharacter] {\n    get {\n      all.prefix { $0.isPinned }\n    }\n    set {\n      if let end = all.firstIndex(where: { !$0.isPinned }) {\n        all.replaceSubrange(all.startIndex..<end, with: newValue)\n      }\n    }\n  }\n\n  var unpinned: [StoryCharacter] {\n    get {\n      if let start = all.firstIndex(where: { !$0.isPinned }) {\n        return Array(all.suffix(from: start))\n      } else {\n        return []\n      }\n    }\n    set {\n      if let start = all.firstIndex(where: { !$0.isPinned }) {\n        all.replaceSubrange(start..<all.endIndex, with: newValue)\n      }\n    }\n  }\n\n  init(_ characters: [StoryCharacter]) {\n    _all = characters\n    sortAll()\n  }\n\n  private mutating func sortAll() {\n    _all.sort { lhs, rhs in\n      if lhs.isPinned && !rhs.isPinned {\n        return true\n      } else if !lhs.isPinned && rhs.isPinned {\n        return false\n      } else {\n        return lhs.lastModified < rhs.lastModified\n      }\n    }\n  }\n}\n\nstruct StoryCharacter: Identifiable, Equatable {\n  var id: Int64\n  var name: String\n  var symbol: String\n  var color: Color\n  var powers: String\n  var isVillain: Bool = false\n  var isPinned: Bool = false\n  var lastModified = Date()\n}\n\nextension StoryCharacter {\n  static let previewData: [StoryCharacter] = [\n    StoryCharacter(\n      id: 0,\n      name: \"The View Builder\",\n      symbol: \"hammer\",\n      color: .pink,\n      powers: \"Conjures objects on-demand.\",\n      isPinned: true),\n    StoryCharacter(\n      id: 1,\n      name: \"The Truth Duplicator\",\n      symbol: \"eyes\",\n      color: .blue,\n      powers: \"Distorts reality.\",\n      isVillain: true),\n    StoryCharacter(\n      id: 2,\n      name: \"The Previewer\",\n      symbol: \"viewfinder\",\n      color: .indigo,\n      powers: \"Reveals the future.\",\n      isPinned: true),\n    StoryCharacter(\n      id: 3,\n      name: \"The Type Eraser\",\n      symbol: \"eye.slash\",\n      color: .black,\n      powers: \"Steals identities.\",\n      isVillain: true,\n      isPinned: true),\n    StoryCharacter(\n      id: 4,\n      name: \"The Environment Modifier\",\n      symbol: \"leaf\",\n      color: .green,\n      powers: \"Controls the physical world.\"),\n    StoryCharacter(\n      id: 5,\n      name: \"The Unstable Identifier\",\n      symbol: \"shuffle\",\n      color: .brown,\n      powers: \"Shape-shifter, uncatchable.\",\n      isVillain: true),\n    StoryCharacter(\n      id: 6,\n      name: \"The Stylizer\",\n      symbol: \"wand.and.stars.inverse\",\n      color: .red,\n      powers: \"Quartermaster of heroes.\"),\n    StoryCharacter(\n      id: 7,\n      name: \"The Singleton\",\n      symbol: \"diamond\",\n      color: .purple,\n      powers: \"An evil robotic hive mind.\",\n      isVillain: true),\n    StoryCharacter(\n      id: 8,\n      name: \"The Geometry Reader\",\n      symbol: \"ruler\",\n      color: .orange,\n      powers: \"Instantly scans any structure.\"),\n    StoryCharacter(\n      id: 9,\n      name: \"The Opaque Typist\",\n      symbol: \"app.fill\",\n      color: .teal,\n      powers: \"Creates impenetrable disguises.\"),\n    StoryCharacter(\n      id: 10,\n      name: \"The Unobservable Man\",\n      symbol: \"hand.raised.slash\",\n      color: .black,\n      powers: \"Impervious to detection.\",\n      isVillain: true),\n  ]\n}"
    },
    {
      "timestamp": "11:35",
      "title": "Inset list style alternating row backgrounds",
      "language": "swift",
      "code": "struct ContentView: View {\n  @State private var characters = StoryCharacter.previewData\n  @State private var selection = Set<StoryCharacter.ID>()\n\n  var body: some View {\n    List(selection: $selection) {\n      ForEach(characters) { character in\n        Label {\n          Text(character.name)\n        } icon: {\n          CharacterIcon(character)\n        }\n        .padding(.leading, 4)\n      }\n    }\n    .listStyle(.inset(alternatesRowBackgrounds: true))\n    .navigationTitle(\"All Characters\")\n  }\n}\n\nstruct CharacterIcon: View {\n  var character: StoryCharacter\n\n  init(_ character: StoryCharacter) {\n    self.character = character\n  }\n\n  var body: some View {\n    HStack {\n      let symbol = Image(systemName: character.symbol)\n        .resizable()\n        .aspectRatio(contentMode: .fit)\n        .foregroundStyle(.white)\n        .padding(4)\n        .frame(width: 20, height: 20)\n\n      if character.isVillain {\n        symbol\n          .background(character.color, in: RoundedRectangle(cornerRadius: 4))\n      } else {\n        symbol\n          .background(character.color, in: Circle())\n      }\n    }\n  }\n}\n\nstruct CharacterStore {\n  var all: [StoryCharacter] {\n    get { _all }\n    set { _all = newValue; sortAll() }\n  }\n  var _all: [StoryCharacter]\n\n  var pinned: [StoryCharacter] {\n    get {\n      all.prefix { $0.isPinned }\n    }\n    set {\n      if let end = all.firstIndex(where: { !$0.isPinned }) {\n        all.replaceSubrange(all.startIndex..<end, with: newValue)\n      }\n    }\n  }\n\n  var unpinned: [StoryCharacter] {\n    get {\n      if let start = all.firstIndex(where: { !$0.isPinned }) {\n        return Array(all.suffix(from: start))\n      } else {\n        return []\n      }\n    }\n    set {\n      if let start = all.firstIndex(where: { !$0.isPinned }) {\n        all.replaceSubrange(start..<all.endIndex, with: newValue)\n      }\n    }\n  }\n\n  init(_ characters: [StoryCharacter]) {\n    _all = characters\n    sortAll()\n  }\n\n  private mutating func sortAll() {\n    _all.sort { lhs, rhs in\n      if lhs.isPinned && !rhs.isPinned {\n        return true\n      } else if !lhs.isPinned && rhs.isPinned {\n        return false\n      } else {\n        return lhs.lastModified < rhs.lastModified\n      }\n    }\n  }\n}\n\nstruct StoryCharacter: Identifiable, Equatable {\n  var id: Int64\n  var name: String\n  var symbol: String\n  var color: Color\n  var powers: String\n  var isVillain: Bool = false\n  var isPinned: Bool = false\n  var lastModified = Date()\n}\n\nextension StoryCharacter {\n  static let previewData: [StoryCharacter] = [\n    StoryCharacter(\n      id: 0,\n      name: \"The View Builder\",\n      symbol: \"hammer\",\n      color: .pink,\n      powers: \"Conjures objects on-demand.\",\n      isPinned: true),\n    StoryCharacter(\n      id: 1,\n      name: \"The Truth Duplicator\",\n      symbol: \"eyes\",\n      color: .blue,\n      powers: \"Distorts reality.\",\n      isVillain: true),\n    StoryCharacter(\n      id: 2,\n      name: \"The Previewer\",\n      symbol: \"viewfinder\",\n      color: .indigo,\n      powers: \"Reveals the future.\",\n      isPinned: true),\n    StoryCharacter(\n      id: 3,\n      name: \"The Type Eraser\",\n      symbol: \"eye.slash\",\n      color: .black,\n      powers: \"Steals identities.\",\n      isVillain: true,\n      isPinned: true),\n    StoryCharacter(\n      id: 4,\n      name: \"The Environment Modifier\",\n      symbol: \"leaf\",\n      color: .green,\n      powers: \"Controls the physical world.\"),\n    StoryCharacter(\n      id: 5,\n      name: \"The Unstable Identifier\",\n      symbol: \"shuffle\",\n      color: .brown,\n      powers: \"Shape-shifter, uncatchable.\",\n      isVillain: true),\n    StoryCharacter(\n      id: 6,\n      name: \"The Stylizer\",\n      symbol: \"wand.and.stars.inverse\",\n      color: .red,\n      powers: \"Quartermaster of heroes.\"),\n    StoryCharacter(\n      id: 7,\n      name: \"The Singleton\",\n      symbol: \"diamond\",\n      color: .purple,\n      powers: \"An evil robotic hive mind.\",\n      isVillain: true),\n    StoryCharacter(\n      id: 8,\n      name: \"The Geometry Reader\",\n      symbol: \"ruler\",\n      color: .orange,\n      powers: \"Instantly scans any structure.\"),\n    StoryCharacter(\n      id: 9,\n      name: \"The Opaque Typist\",\n      symbol: \"app.fill\",\n      color: .teal,\n      powers: \"Creates impenetrable disguises.\"),\n    StoryCharacter(\n      id: 10,\n      name: \"The Unobservable Man\",\n      symbol: \"hand.raised.slash\",\n      color: .black,\n      powers: \"Impervious to detection.\",\n      isVillain: true),\n  ]\n}"
    },
    {
      "timestamp": "12:13",
      "title": "Tables",
      "language": "swift",
      "code": "struct ContentView: View {\n  @State private var characters = StoryCharacter.previewData\n\n  var body: some View {\n    Table(characters) {\n      TableColumn(\"􀟈\") { CharacterIcon($0) }\n        .width(20)\n      TableColumn(\"Villain\") { Text($0.isVillain ? \"Villain\" : \"Hero\") }\n        .width(40)\n      TableColumn(\"Name\", value: \\.name)\n      TableColumn(\"Powers\", value: \\.powers)\n    }\n  }\n}\n\nstruct CharacterIcon: View {\n  var character: StoryCharacter\n\n  init(_ character: StoryCharacter) {\n    self.character = character\n  }\n\n  var body: some View {\n    HStack {\n      let symbol = Image(systemName: character.symbol)\n        .resizable()\n        .aspectRatio(contentMode: .fit)\n        .foregroundStyle(.white)\n        .padding(4)\n        .frame(width: 20, height: 20)\n\n      if character.isVillain {\n        symbol\n          .background(character.color, in: RoundedRectangle(cornerRadius: 4))\n      } else {\n        symbol\n          .background(character.color, in: Circle())\n      }\n    }\n  }\n}\n\nstruct CharacterStore {\n  var all: [StoryCharacter] {\n    get { _all }\n    set { _all = newValue; sortAll() }\n  }\n  var _all: [StoryCharacter]\n\n  var pinned: [StoryCharacter] {\n    get {\n      all.prefix { $0.isPinned }\n    }\n    set {\n      if let end = all.firstIndex(where: { !$0.isPinned }) {\n        all.replaceSubrange(all.startIndex..<end, with: newValue)\n      }\n    }\n  }\n\n  var unpinned: [StoryCharacter] {\n    get {\n      if let start = all.firstIndex(where: { !$0.isPinned }) {\n        return Array(all.suffix(from: start))\n      } else {\n        return []\n      }\n    }\n    set {\n      if let start = all.firstIndex(where: { !$0.isPinned }) {\n        all.replaceSubrange(start..<all.endIndex, with: newValue)\n      }\n    }\n  }\n\n  init(_ characters: [StoryCharacter]) {\n    _all = characters\n    sortAll()\n  }\n\n  private mutating func sortAll() {\n    _all.sort { lhs, rhs in\n      if lhs.isPinned && !rhs.isPinned {\n        return true\n      } else if !lhs.isPinned && rhs.isPinned {\n        return false\n      } else {\n        return lhs.lastModified < rhs.lastModified\n      }\n    }\n  }\n}\n\nstruct StoryCharacter: Identifiable, Equatable {\n  var id: Int64\n  var name: String\n  var symbol: String\n  var color: Color\n  var powers: String\n  var isVillain: Bool = false\n  var isPinned: Bool = false\n  var lastModified = Date()\n}\n\nextension StoryCharacter {\n  static let previewData: [StoryCharacter] = [\n    StoryCharacter(\n      id: 0,\n      name: \"The View Builder\",\n      symbol: \"hammer\",\n      color: .pink,\n      powers: \"Conjures objects on-demand.\",\n      isPinned: true),\n    StoryCharacter(\n      id: 1,\n      name: \"The Truth Duplicator\",\n      symbol: \"eyes\",\n      color: .blue,\n      powers: \"Distorts reality.\",\n      isVillain: true),\n    StoryCharacter(\n      id: 2,\n      name: \"The Previewer\",\n      symbol: \"viewfinder\",\n      color: .indigo,\n      powers: \"Reveals the future.\",\n      isPinned: true),\n    StoryCharacter(\n      id: 3,\n      name: \"The Type Eraser\",\n      symbol: \"eye.slash\",\n      color: .black,\n      powers: \"Steals identities.\",\n      isVillain: true,\n      isPinned: true),\n    StoryCharacter(\n      id: 4,\n      name: \"The Environment Modifier\",\n      symbol: \"leaf\",\n      color: .green,\n      powers: \"Controls the physical world.\"),\n    StoryCharacter(\n      id: 5,\n      name: \"The Unstable Identifier\",\n      symbol: \"shuffle\",\n      color: .brown,\n      powers: \"Shape-shifter, uncatchable.\",\n      isVillain: true),\n    StoryCharacter(\n      id: 6,\n      name: \"The Stylizer\",\n      symbol: \"wand.and.stars.inverse\",\n      color: .red,\n      powers: \"Quartermaster of heroes.\"),\n    StoryCharacter(\n      id: 7,\n      name: \"The Singleton\",\n      symbol: \"diamond\",\n      color: .purple,\n      powers: \"An evil robotic hive mind.\",\n      isVillain: true),\n    StoryCharacter(\n      id: 8,\n      name: \"The Geometry Reader\",\n      symbol: \"ruler\",\n      color: .orange,\n      powers: \"Instantly scans any structure.\"),\n    StoryCharacter(\n      id: 9,\n      name: \"The Opaque Typist\",\n      symbol: \"app.fill\",\n      color: .teal,\n      powers: \"Creates impenetrable disguises.\"),\n    StoryCharacter(\n      id: 10,\n      name: \"The Unobservable Man\",\n      symbol: \"hand.raised.slash\",\n      color: .black,\n      powers: \"Impervious to detection.\",\n      isVillain: true),\n  ]\n}"
    },
    {
      "timestamp": "12:49",
      "title": "Tables with selection",
      "language": "swift",
      "code": "struct ContentView: View {\n  @State private var characters = StoryCharacter.previewData\n\n  // Single selection\n  @State private var singleSelection: StoryCharacter.ID?\n\n  // Multiple selection\n  @State private var multipleSelection: Set<StoryCharacter.ID>()\n\n  var body: some View {\n    Table(characters, selection: $singleSelection) { // or `$multipleSelection`\n      TableColumn(\"􀟈\") { CharacterIcon($0) }\n        .width(20)\n      TableColumn(\"Villain\") { Text($0.isVillain ? \"Villain\" : \"Hero\") }\n        .width(40)\n      TableColumn(\"Name\", value: \\.name)\n      TableColumn(\"Powers\", value: \\.powers)\n    }\n  }\n}\n\nstruct CharacterIcon: View {\n  var character: StoryCharacter\n\n  init(_ character: StoryCharacter) {\n    self.character = character\n  }\n\n  var body: some View {\n    HStack {\n      let symbol = Image(systemName: character.symbol)\n        .resizable()\n        .aspectRatio(contentMode: .fit)\n        .foregroundStyle(.white)\n        .padding(4)\n        .frame(width: 20, height: 20)\n\n      if character.isVillain {\n        symbol\n          .background(character.color, in: RoundedRectangle(cornerRadius: 4))\n      } else {\n        symbol\n          .background(character.color, in: Circle())\n      }\n    }\n  }\n}\n\nstruct CharacterStore {\n  var all: [StoryCharacter] {\n    get { _all }\n    set { _all = newValue; sortAll() }\n  }\n  var _all: [StoryCharacter]\n\n  var pinned: [StoryCharacter] {\n    get {\n      all.prefix { $0.isPinned }\n    }\n    set {\n      if let end = all.firstIndex(where: { !$0.isPinned }) {\n        all.replaceSubrange(all.startIndex..<end, with: newValue)\n      }\n    }\n  }\n\n  var unpinned: [StoryCharacter] {\n    get {\n      if let start = all.firstIndex(where: { !$0.isPinned }) {\n        return Array(all.suffix(from: start))\n      } else {\n        return []\n      }\n    }\n    set {\n      if let start = all.firstIndex(where: { !$0.isPinned }) {\n        all.replaceSubrange(start..<all.endIndex, with: newValue)\n      }\n    }\n  }\n\n  init(_ characters: [StoryCharacter]) {\n    _all = characters\n    sortAll()\n  }\n\n  private mutating func sortAll() {\n    _all.sort { lhs, rhs in\n      if lhs.isPinned && !rhs.isPinned {\n        return true\n      } else if !lhs.isPinned && rhs.isPinned {\n        return false\n      } else {\n        return lhs.lastModified < rhs.lastModified\n      }\n    }\n  }\n}\n\nstruct StoryCharacter: Identifiable, Equatable {\n  var id: Int64\n  var name: String\n  var symbol: String\n  var color: Color\n  var powers: String\n  var isVillain: Bool = false\n  var isPinned: Bool = false\n  var lastModified = Date()\n}\n\nextension StoryCharacter {\n  static let previewData: [StoryCharacter] = [\n    StoryCharacter(\n      id: 0,\n      name: \"The View Builder\",\n      symbol: \"hammer\",\n      color: .pink,\n      powers: \"Conjures objects on-demand.\",\n      isPinned: true),\n    StoryCharacter(\n      id: 1,\n      name: \"The Truth Duplicator\",\n      symbol: \"eyes\",\n      color: .blue,\n      powers: \"Distorts reality.\",\n      isVillain: true),\n    StoryCharacter(\n      id: 2,\n      name: \"The Previewer\",\n      symbol: \"viewfinder\",\n      color: .indigo,\n      powers: \"Reveals the future.\",\n      isPinned: true),\n    StoryCharacter(\n      id: 3,\n      name: \"The Type Eraser\",\n      symbol: \"eye.slash\",\n      color: .black,\n      powers: \"Steals identities.\",\n      isVillain: true,\n      isPinned: true),\n    StoryCharacter(\n      id: 4,\n      name: \"The Environment Modifier\",\n      symbol: \"leaf\",\n      color: .green,\n      powers: \"Controls the physical world.\"),\n    StoryCharacter(\n      id: 5,\n      name: \"The Unstable Identifier\",\n      symbol: \"shuffle\",\n      color: .brown,\n      powers: \"Shape-shifter, uncatchable.\",\n      isVillain: true),\n    StoryCharacter(\n      id: 6,\n      name: \"The Stylizer\",\n      symbol: \"wand.and.stars.inverse\",\n      color: .red,\n      powers: \"Quartermaster of heroes.\"),\n    StoryCharacter(\n      id: 7,\n      name: \"The Singleton\",\n      symbol: \"diamond\",\n      color: .purple,\n      powers: \"An evil robotic hive mind.\",\n      isVillain: true),\n    StoryCharacter(\n      id: 8,\n      name: \"The Geometry Reader\",\n      symbol: \"ruler\",\n      color: .orange,\n      powers: \"Instantly scans any structure.\"),\n    StoryCharacter(\n      id: 9,\n      name: \"The Opaque Typist\",\n      symbol: \"app.fill\",\n      color: .teal,\n      powers: \"Creates impenetrable disguises.\"),\n    StoryCharacter(\n      id: 10,\n      name: \"The Unobservable Man\",\n      symbol: \"hand.raised.slash\",\n      color: .black,\n      powers: \"Impervious to detection.\",\n      isVillain: true),\n  ]\n}"
    },
    {
      "timestamp": "12:57",
      "title": "Tables with selection and sorting",
      "language": "swift",
      "code": "struct ContentView: View {\n  @State private var characters = StoryCharacter.previewData\n  @State private var selection = Set<StoryCharacter.ID>()\n\n  @State private var sortOrder = [KeyPathComparator(\\StoryCharacter.name)]\n  @State private var sorted: [StoryCharacter]?\n\n  var body: some View {\n    Table(sorted ?? characters, selection: $selection, sortOrder: $sortOrder) {\n      TableColumn(\"􀟈\") { CharacterIcon($0) }\n        .width(20)\n      TableColumn(\"Villain\") { Text($0.isVillain ? \"Villain\" : \"Hero\") }\n        .width(40)\n      TableColumn(\"Name\", value: \\.name)\n      TableColumn(\"Powers\", value: \\.powers)\n    }\n    .onChange(of: characters) { sorted = $0.sorted(using: sortOrder) }\n    .onChange(of: sortOrder) { sorted = characters.sorted(using: $0) }\n  }\n}\n\nstruct CharacterIcon: View {\n  var character: StoryCharacter\n\n  init(_ character: StoryCharacter) {\n    self.character = character\n  }\n\n  var body: some View {\n    HStack {\n      let symbol = Image(systemName: character.symbol)\n        .resizable()\n        .aspectRatio(contentMode: .fit)\n        .foregroundStyle(.white)\n        .padding(4)\n        .frame(width: 20, height: 20)\n\n      if character.isVillain {\n        symbol\n          .background(character.color, in: RoundedRectangle(cornerRadius: 4))\n      } else {\n        symbol\n          .background(character.color, in: Circle())\n      }\n    }\n  }\n}\n\nstruct CharacterStore {\n  var all: [StoryCharacter] {\n    get { _all }\n    set { _all = newValue; sortAll() }\n  }\n  var _all: [StoryCharacter]\n\n  var pinned: [StoryCharacter] {\n    get {\n      all.prefix { $0.isPinned }\n    }\n    set {\n      if let end = all.firstIndex(where: { !$0.isPinned }) {\n        all.replaceSubrange(all.startIndex..<end, with: newValue)\n      }\n    }\n  }\n\n  var unpinned: [StoryCharacter] {\n    get {\n      if let start = all.firstIndex(where: { !$0.isPinned }) {\n        return Array(all.suffix(from: start))\n      } else {\n        return []\n      }\n    }\n    set {\n      if let start = all.firstIndex(where: { !$0.isPinned }) {\n        all.replaceSubrange(start..<all.endIndex, with: newValue)\n      }\n    }\n  }\n\n  init(_ characters: [StoryCharacter]) {\n    _all = characters\n    sortAll()\n  }\n\n  private mutating func sortAll() {\n    _all.sort { lhs, rhs in\n      if lhs.isPinned && !rhs.isPinned {\n        return true\n      } else if !lhs.isPinned && rhs.isPinned {\n        return false\n      } else {\n        return lhs.lastModified < rhs.lastModified\n      }\n    }\n  }\n}\n\nstruct StoryCharacter: Identifiable, Equatable {\n  var id: Int64\n  var name: String\n  var symbol: String\n  var color: Color\n  var powers: String\n  var isVillain: Bool = false\n  var isPinned: Bool = false\n  var lastModified = Date()\n}\n\nextension StoryCharacter {\n  static let previewData: [StoryCharacter] = [\n    StoryCharacter(\n      id: 0,\n      name: \"The View Builder\",\n      symbol: \"hammer\",\n      color: .pink,\n      powers: \"Conjures objects on-demand.\",\n      isPinned: true),\n    StoryCharacter(\n      id: 1,\n      name: \"The Truth Duplicator\",\n      symbol: \"eyes\",\n      color: .blue,\n      powers: \"Distorts reality.\",\n      isVillain: true),\n    StoryCharacter(\n      id: 2,\n      name: \"The Previewer\",\n      symbol: \"viewfinder\",\n      color: .indigo,\n      powers: \"Reveals the future.\",\n      isPinned: true),\n    StoryCharacter(\n      id: 3,\n      name: \"The Type Eraser\",\n      symbol: \"eye.slash\",\n      color: .black,\n      powers: \"Steals identities.\",\n      isVillain: true,\n      isPinned: true),\n    StoryCharacter(\n      id: 4,\n      name: \"The Environment Modifier\",\n      symbol: \"leaf\",\n      color: .green,\n      powers: \"Controls the physical world.\"),\n    StoryCharacter(\n      id: 5,\n      name: \"The Unstable Identifier\",\n      symbol: \"shuffle\",\n      color: .brown,\n      powers: \"Shape-shifter, uncatchable.\",\n      isVillain: true),\n    StoryCharacter(\n      id: 6,\n      name: \"The Stylizer\",\n      symbol: \"wand.and.stars.inverse\",\n      color: .red,\n      powers: \"Quartermaster of heroes.\"),\n    StoryCharacter(\n      id: 7,\n      name: \"The Singleton\",\n      symbol: \"diamond\",\n      color: .purple,\n      powers: \"An evil robotic hive mind.\",\n      isVillain: true),\n    StoryCharacter(\n      id: 8,\n      name: \"The Geometry Reader\",\n      symbol: \"ruler\",\n      color: .orange,\n      powers: \"Instantly scans any structure.\"),\n    StoryCharacter(\n      id: 9,\n      name: \"The Opaque Typist\",\n      symbol: \"app.fill\",\n      color: .teal,\n      powers: \"Creates impenetrable disguises.\"),\n    StoryCharacter(\n      id: 10,\n      name: \"The Unobservable Man\",\n      symbol: \"hand.raised.slash\",\n      color: .black,\n      powers: \"Impervious to detection.\",\n      isVillain: true),\n  ]\n}"
    },
    {
      "timestamp": "13:15",
      "title": "CoreData Tables",
      "language": "swift",
      "code": "@FetchRequest(sortDescriptors: [SortDescriptor(\\.name)])\nprivate var characters: FetchedResults<StoryCharacter>\n@State private var selection = Set<StoryCharacter.ID>()\n\nTable(characters, selection: $selection, sortOrder: $characters.sortDescriptors) {\n  TableColumn(\"􀟈\") { CharacterIcon($0) }\n    .width(20)\n  TableColumn(\"Villain\") { Text($0.isVillain ? \"Villain\" : \"Hero\") }\n    .width(40)\n  TableColumn(\"Name\", value: \\.name)\n  TableColumn(\"Powers\", value: \\.powers)\n}"
    },
    {
      "timestamp": "13:34",
      "title": "Sectioned fetch requests",
      "language": "swift",
      "code": "@SectionedFetchRequest(\n  sectionIdentifier: \\.isPinned,\n  sortDescriptors: [\n    SortDescriptor(\\.isPinned, order: .reverse),\n    SortDescriptor(\\.lastModified)\n  ],\n  animation: .default)\nprivate var characters: SectionedFetchResults<...>\n\nList {\n  ForEach(characters) { section in\n    Section(section.id ? \"Pinned\" : \"Heroes & Villains\") {\n      ForEach(section) { character in\n        CharacterRowView(character)\n      }\n    }\n  }\n}"
    },
    {
      "timestamp": "15:20",
      "title": "searchable() modifier",
      "language": "swift",
      "code": "struct ContentView: View {\n  @State private var characters = CharacterStore(StoryCharacter.previewData)\n\n  var body: some View {\n    NavigationView {\n      List {\n        if characters.filterText.isEmpty {\n          if !characters.pinned.isEmpty {\n            Section(\"Pinned\") {\n              sectionContent(for: characters.pinned)\n            }\n          }\n          Section(\"Heroes & Villains\") {\n            sectionContent(for: characters.unpinned)\n          }\n        } else {\n          sectionContent(for: characters.filtered)\n        }\n      }\n      .listStyle(.sidebar)\n      .searchable(text: $characters.filterText)\n      .navigationTitle(\"Characters\")\n    }\n  }\n\n  @ViewBuilder\n  private func sectionContent(for characters: [StoryCharacter]) -> some View {\n    ForEach(characters) { character in\n      CharacterProfile(character)\n    }\n  }\n}\n\nstruct CharacterProfile: View {\n  var character: StoryCharacter\n\n  init(_ character: StoryCharacter) {\n    self.character = character\n  }\n\n  var body: some View {\n    NavigationLink {\n      Text(character.name)\n    } label: {\n      HStack {\n        HStack {\n          let symbol = Image(systemName: character.symbol)\n            .resizable()\n            .aspectRatio(contentMode: .fit)\n            .foregroundStyle(.white)\n            .padding(6)\n            .frame(width: 33, height: 33)\n\n          if character.isVillain {\n            symbol\n              .background(character.color, in: RoundedRectangle(cornerRadius: 8))\n          } else {\n            symbol\n              .background(character.color, in: Circle())\n          }\n        }\n        VStack(alignment: .leading, spacing: 2) {\n          HStack(alignment: .center) {\n            Text(character.name)\n              .bold()\n              .foregroundStyle(.primary)\n          }\n          HStack(spacing: 4) {\n            Text(character.isVillain ? \"VILLAIN\" : \"HERO\")\n              .bold()\n              .font(.caption2.weight(.heavy))\n              .foregroundStyle(.white)\n              .padding(.vertical, 1)\n              .padding(.horizontal, 3)\n              .background(.quaternary, in: RoundedRectangle(cornerRadius: 3))\n\n            Text(character.powers)\n              .font(.footnote)\n              .foregroundStyle(.secondary)\n          }\n        }\n      }\n    }\n  }\n}\n\nstruct CharacterStore {\n  var all: [StoryCharacter] {\n    get { _all }\n    set { _all = newValue; sortAll() }\n  }\n  var _all: [StoryCharacter]\n\n  var pinned: [StoryCharacter] {\n    all.prefix { $0.isPinned }\n  }\n\n  var unpinned: [StoryCharacter] {\n    if let start = all.firstIndex(where: { !$0.isPinned }) {\n      return Array(all.suffix(from: start))\n    } else {\n      return []\n    }\n  }\n\n  var filterText: String = \"\"\n  var filtered: [StoryCharacter] {\n    if filterText.isEmpty {\n      return all\n    } else {\n      return all.filter {\n        $0.name.contains(filterText) || $0.powers.contains(filterText)\n      }\n    }\n  }\n\n  init(_ characters: [StoryCharacter]) {\n    _all = characters\n    sortAll()\n  }\n\n  private mutating func sortAll() {\n    _all.sort { lhs, rhs in\n      if lhs.isPinned && !rhs.isPinned {\n        return true\n      } else if !lhs.isPinned && rhs.isPinned {\n        return false\n      } else {\n        return lhs.lastModified < rhs.lastModified\n      }\n    }\n  }\n}\n\nstruct StoryCharacter: Identifiable, Equatable {\n  var id: Int64\n  var name: String\n  var symbol: String\n  var color: Color\n  var powers: String\n  var isVillain: Bool = false\n  var isPinned: Bool = false\n  var lastModified = Date()\n}\n\nextension StoryCharacter {\n  static let previewData: [StoryCharacter] = [\n    StoryCharacter(\n      id: 0,\n      name: \"The View Builder\",\n      symbol: \"hammer\",\n      color: .pink,\n      powers: \"Conjures objects on-demand.\",\n      isPinned: true),\n    StoryCharacter(\n      id: 1,\n      name: \"The Truth Duplicator\",\n      symbol: \"eyes\",\n      color: .blue,\n      powers: \"Distorts reality.\",\n      isVillain: true),\n    StoryCharacter(\n      id: 2,\n      name: \"The Previewer\",\n      symbol: \"viewfinder\",\n      color: .indigo,\n      powers: \"Reveals the future.\",\n      isPinned: true),\n    StoryCharacter(\n      id: 3,\n      name: \"The Type Eraser\",\n      symbol: \"eye.slash\",\n      color: .black,\n      powers: \"Steals identities.\",\n      isVillain: true,\n      isPinned: true),\n    StoryCharacter(\n      id: 4,\n      name: \"The Environment Modifier\",\n      symbol: \"leaf\",\n      color: .green,\n      powers: \"Controls the physical world.\"),\n    StoryCharacter(\n      id: 5,\n      name: \"The Unstable Identifier\",\n      symbol: \"shuffle\",\n      color: .brown,\n      powers: \"Shape-shifter, uncatchable.\",\n      isVillain: true),\n    StoryCharacter(\n      id: 6,\n      name: \"The Stylizer\",\n      symbol: \"wand.and.stars.inverse\",\n      color: .red,\n      powers: \"Quartermaster of heroes.\"),\n    StoryCharacter(\n      id: 7,\n      name: \"The Singleton\",\n      symbol: \"diamond\",\n      color: .purple,\n      powers: \"An evil robotic hive mind.\",\n      isVillain: true),\n    StoryCharacter(\n      id: 8,\n      name: \"The Geometry Reader\",\n      symbol: \"ruler\",\n      color: .orange,\n      powers: \"Instantly scans any structure.\"),\n    StoryCharacter(\n      id: 9,\n      name: \"The Opaque Typist\",\n      symbol: \"app.fill\",\n      color: .teal,\n      powers: \"Creates impenetrable disguises.\"),\n    StoryCharacter(\n      id: 10,\n      name: \"The Unobservable Man\",\n      symbol: \"hand.raised.slash\",\n      color: .black,\n      powers: \"Impervious to detection.\",\n      isVillain: true),\n  ]\n}"
    },
    {
      "timestamp": "16:22",
      "title": "Drag previews",
      "language": "swift",
      "code": "struct ContentView: View {\n  let character = StoryCharacter(\n    id: 0,\n    name: \"The View Builder\",\n    symbol: \"hammer\",\n    color: .pink,\n    powers: \"Conjures objects on-demand.\",\n    isPinned: true\n  )\n\n  var body: some View {\n    CharacterIcon(character)\n      .controlSize(.large)\n      .padding()\n      .onDrag {\n        character.itemProvider\n      } preview: {\n        Label {\n          Text(character.name)\n        } icon: {\n          CharacterIcon(character)\n            .controlSize(.small)\n        }\n        .padding(.vertical, 8)\n        .frame(width: 150)\n        .background(.white, in: RoundedRectangle(cornerRadius: 8))\n      }\n  }\n}\n\nstruct StoryCharacter: Identifiable, Equatable {\n  var id: Int64\n  var name: String\n  var symbol: String\n  var color: Color\n  var powers: String\n  var isVillain: Bool = false\n  var isPinned: Bool = false\n  var lastModified = Date()\n\n  var itemProvider: NSItemProvider {\n    let item = NSItemProvider()\n    item.registerObject(name as NSString, visibility: .all)\n    return item\n  }\n}\n\nstruct CharacterIcon: View {\n  var character: StoryCharacter\n\n  #if os(iOS) || os(macOS)\n  @Environment(\\.controlSize) private var controlSize\n  #endif\n\n  init(_ character: StoryCharacter) {\n    self.character = character\n  }\n\n  var body: some View {\n    HStack {\n      let symbol = Image(systemName: character.symbol)\n        .resizable()\n        .aspectRatio(contentMode: .fit)\n        .foregroundStyle(.white)\n        .padding(symbolPadding)\n        .frame(width: symbolLength, height: symbolLength)\n\n      if character.isVillain {\n        symbol\n          .background(\n            character.color, in: RoundedRectangle(cornerRadius: cornerRadius))\n      } else {\n        symbol\n          .background(character.color, in: Circle())\n      }\n    }\n  }\n\n  var symbolPadding: CGFloat {\n    switch controlSize {\n    case .small: return 4\n    case .large: return 10\n    default: return 6\n    }\n  }\n\n  var symbolLength: CGFloat {\n    switch controlSize {\n    case .small: return 20\n    case .large: return 60\n    default: return 33\n    }\n  }\n\n  var cornerRadius: CGFloat {\n    switch controlSize {\n    case .small: return 4\n    case .large: return 16\n    default: return 8\n    }\n  }\n}"
    },
    {
      "timestamp": "16:48",
      "title": "importsItemProviders() modifier",
      "language": "swift",
      "code": "import UniformTypeIdentifiers\n\n@main\nprivate struct Catalog: App {\n  var body: some Scene {\n    WindowGroup {\n      ContentView()\n    }\n    .commands {\n      ImportFromDevicesCommands()\n    }\n  }\n}\n\nstruct ContentView: View {\n  @State private var character: StoryCharacter = StoryCharacter(\n    id: 0,\n    name: \"The View Builder\",\n    symbol: \"hammer\",\n    color: .pink,\n    powers: \"Conjures objects on-demand.\",\n    isPinned: true\n  )\n\n  var body: some View {\n    VStack {\n      CharacterIcon(character)\n        .controlSize(.large)\n        .onDrag {\n          character.itemProvider\n        } preview: {\n          Label {\n            Text(character.name)\n          } icon: {\n            CharacterIcon(character)\n              .controlSize(.small)\n          }\n          .padding(.vertical, 8)\n          .frame(width: 150)\n          .background(.white, in: RoundedRectangle(cornerRadius: 8))\n        }\n\n      if let headerImage = character.headerImage {\n        headerImage\n          .resizable()\n          .aspectRatio(contentMode: .fill)\n          .frame(width: 150, height: 150)\n          .mask(RoundedRectangle(cornerRadius: 16, style: .continuous))\n      }\n    }\n    .padding()\n    .importsItemProviders(StoryCharacter.headerImageTypes) { itemProviders in\n      guard let first = itemProviders.first else { return false }\n      async {\n        character.headerImage = await StoryCharacter.loadHeaderImage(from: first)\n      }\n      return true\n    }\n  }\n}\n\nstruct StoryCharacter: Identifiable, Equatable {\n  var id: Int64\n  var name: String\n  var symbol: String\n  var color: Color\n  var powers: String\n  var isVillain: Bool = false\n  var isPinned: Bool = false\n  var lastModified = Date()\n  var headerImage: Image?\n\n  static var headerImageTypes: [UTType] {\n    NSImage.imageTypes.compactMap { UTType($0) }\n  }\n\n  var itemProvider: NSItemProvider {\n    let item = NSItemProvider()\n    item.registerObject(name as NSString, visibility: .all)\n    return item\n  }\n\n  static func loadHeaderImage(from itemProvider: NSItemProvider) async -> Image? {\n    for type in Self.headerImageTypes.map(\\.identifier) {\n      if itemProvider.hasRepresentationConforming(toTypeIdentifier: type) {\n        return await withCheckedContinuation { continuation in\n          itemProvider.loadDataRepresentation(forTypeIdentifier: type) { data, error in\n            guard let data = data, let image = NSImage(data: data) else { return }\n            continuation.resume(returning: Image(nsImage: image))\n          }\n        }\n      }\n    }\n    return nil\n  }\n}\n\nstruct CharacterIcon: View {\n  var character: StoryCharacter\n\n  #if os(iOS) || os(macOS)\n  @Environment(\\.controlSize) private var controlSize\n  #endif\n\n  init(_ character: StoryCharacter) {\n    self.character = character\n  }\n\n  var body: some View {\n    HStack {\n      let symbol = Image(systemName: character.symbol)\n        .resizable()\n        .aspectRatio(contentMode: .fit)\n        .foregroundStyle(.white)\n        .padding(symbolPadding)\n        .frame(width: symbolLength, height: symbolLength)\n\n      if character.isVillain {\n        symbol\n          .background(\n            character.color, in: RoundedRectangle(cornerRadius: cornerRadius))\n      } else {\n        symbol\n          .background(character.color, in: Circle())\n      }\n    }\n  }\n\n  var symbolPadding: CGFloat {\n    switch controlSize {\n    case .small: return 4\n    case .large: return 10\n    default: return 6\n    }\n  }\n\n  var symbolLength: CGFloat {\n    switch controlSize {\n    case .small: return 20\n    case .large: return 60\n    default: return 33\n    }\n  }\n\n  var cornerRadius: CGFloat {\n    switch controlSize {\n    case .small: return 4\n    case .large: return 16\n    default: return 8\n    }\n  }\n}"
    },
    {
      "timestamp": "18:17",
      "title": "exportsItemProviders() modifier",
      "language": "swift",
      "code": "import UniformTypeIdentifiers\n\n@main\nprivate struct Catalog: App {\n  var body: some Scene {\n    WindowGroup {\n      ContentView()\n    }\n    .commands {\n      ImportFromDevicesCommands()\n    }\n  }\n}\n\nstruct ContentView: View {\n  @State private var character: StoryCharacter = StoryCharacter(\n    id: 0,\n    name: \"The View Builder\",\n    symbol: \"hammer\",\n    color: .pink,\n    powers: \"Conjures objects on-demand.\",\n    isPinned: true\n  )\n\n  var body: some View {\n    VStack {\n      CharacterIcon(character)\n        .controlSize(.large)\n        .onDrag {\n          character.itemProvider\n        } preview: {\n          Label {\n            Text(character.name)\n          } icon: {\n            CharacterIcon(character)\n              .controlSize(.small)\n          }\n          .padding(.vertical, 8)\n          .frame(width: 150)\n          .background(.white, in: RoundedRectangle(cornerRadius: 8))\n        }\n\n      if let headerImage = character.headerImage {\n        headerImage\n          .resizable()\n          .aspectRatio(contentMode: .fill)\n          .frame(width: 150, height: 150)\n          .mask(RoundedRectangle(cornerRadius: 16, style: .continuous))\n      }\n    }\n    .padding()\n    .importsItemProviders(StoryCharacter.headerImageTypes) { itemProviders in\n      guard let first = itemProviders.first else { return false }\n      async {\n        character.headerImage = await StoryCharacter.loadHeaderImage(from: first)\n      }\n      return true\n    }\n    .exportsItemProviders(StoryCharacter.contentTypes) { [character.itemProvider] }\n  }\n}\n\nstruct StoryCharacter: Identifiable, Equatable {\n  var id: Int64\n  var name: String\n  var symbol: String\n  var color: Color\n  var powers: String\n  var isVillain: Bool = false\n  var isPinned: Bool = false\n  var lastModified = Date()\n  var headerImage: Image?\n\n  static var contentTypes: [UTType] { [.utf8PlainText] }\n  static var headerImageTypes: [UTType] {\n    NSImage.imageTypes.compactMap { UTType($0) }\n  }\n\n  var itemProvider: NSItemProvider {\n    let item = NSItemProvider()\n    item.registerObject(name as NSString, visibility: .all)\n    return item\n  }\n\n  static func loadHeaderImage(from itemProvider: NSItemProvider) async -> Image? {\n    for type in Self.headerImageTypes.map(\\.identifier) {\n      if itemProvider.hasRepresentationConforming(toTypeIdentifier: type) {\n        return await withCheckedContinuation { continuation in\n          itemProvider.loadDataRepresentation(forTypeIdentifier: type) { data, error in\n            guard let data = data, let image = NSImage(data: data) else { return }\n            continuation.resume(returning: Image(nsImage: image))\n          }\n        }\n      }\n    }\n    return nil\n  }\n}\n\nstruct CharacterIcon: View {\n  var character: StoryCharacter\n\n  #if os(iOS) || os(macOS)\n  @Environment(\\.controlSize) private var controlSize\n  #endif\n\n  init(_ character: StoryCharacter) {\n    self.character = character\n  }\n\n  var body: some View {\n    HStack {\n      let symbol = Image(systemName: character.symbol)\n        .resizable()\n        .aspectRatio(contentMode: .fit)\n        .foregroundStyle(.white)\n        .padding(symbolPadding)\n        .frame(width: symbolLength, height: symbolLength)\n\n      if character.isVillain {\n        symbol\n          .background(\n            character.color, in: RoundedRectangle(cornerRadius: cornerRadius))\n      } else {\n        symbol\n          .background(character.color, in: Circle())\n      }\n    }\n  }\n\n  var symbolPadding: CGFloat {\n    switch controlSize {\n    case .small: return 4\n    case .large: return 10\n    default: return 6\n    }\n  }\n\n  var symbolLength: CGFloat {\n    switch controlSize {\n    case .small: return 20\n    case .large: return 60\n    default: return 33\n    }\n  }\n\n  var cornerRadius: CGFloat {\n    switch controlSize {\n    case .small: return 4\n    case .large: return 16\n    default: return 8\n    }\n  }\n}"
    },
    {
      "timestamp": "19:47",
      "title": "Symbol rendering modes",
      "language": "swift",
      "code": "struct ContentView: View {\n    var body: some View {\n        VStack {\n            HStack { symbols }\n                .symbolRenderingMode(.monochrome)\n            HStack { symbols }\n                .symbolRenderingMode(.multicolor)\n            HStack { symbols }\n                .symbolRenderingMode(.hierarchical)\n            HStack { symbols }\n                .symbolRenderingMode(.palette)\n                .foregroundStyle(Color.cyan, Color.purple)\n        }\n        .foregroundStyle(.blue)\n        .font(.title)\n    }\n    @ViewBuilder var symbols: some View {\n        Group {\n            Image(systemName: \"exclamationmark.triangle.fill\")\n            Image(systemName: \"pc\")\n            Image(systemName: \"phone.down.circle\")\n            Image(systemName: \"hourglass\")\n            Image(systemName: \"heart.fill\")\n            Image(systemName: \"airplane.circle.fill\")\n        }\n        .frame(width: 40, height: 40)\n    }\n}"
    },
    {
      "timestamp": "20:27",
      "title": "Symbol variants",
      "language": "swift",
      "code": "struct ContentView: View {\n    var body: some View {\n        VStack {\n            HStack { symbols }\n            HStack { symbols }\n                .symbolVariant(.fill)\n        }\n        .foregroundStyle(.blue)\n    }\n    @ViewBuilder var symbols: some View {\n        let heart = Image(systemName: \"heart\")\n        Group {\n            heart\n            heart.symbolVariant(.slash)\n            heart.symbolVariant(.circle)\n            heart.symbolVariant(.square)\n            heart.symbolVariant(.rectangle)\n        }\n        .frame(width: 40, height: 40)\n    }\n}"
    },
    {
      "timestamp": "20:42",
      "title": "Tab symbol variants: iOS 13",
      "language": "swift",
      "code": "struct TabExample: View {\n    var body: some View {\n        TabView {\n            CardsView().tabItem {\n                Label(\"Cards\", systemImage: \"rectangle.portrait.on.rectangle.portrait.fill\")\n            }\n            RulesView().tabItem {\n                Label(\"Rules\", systemImage: \"character.book.closed.fill\")\n            }\n            ProfileView().tabItem {\n                Label(\"Profile\", systemImage: \"person.circle.fill\")\n            }\n            SearchPlayersView().tabItem {\n                Label(\"Magic\", systemImage: \"sparkles\")\n            }\n        }\n    }\n}\n\nstruct CardsView: View {\n    var body: some View { Color.clear }\n}\nstruct RulesView: View {\n    var body: some View { Color.clear }\n}\nstruct ProfileView: View {\n    var body: some View { Color.clear }\n}\nstruct SearchPlayersView: View {\n    var body: some View { Color.clear }\n}"
    },
    {
      "timestamp": "20:50",
      "title": "Tab symbol variants",
      "language": "swift",
      "code": "@main\nstruct SnippetsApp: App {\n    var body: some Scene {\n        WindowGroup {\n            #if os(iOS)\n            TabExample()\n            #else\n            VStack{\n                Text(\"Open Preferences\")\n                Text(\"⌘,\").font(.title.monospaced())\n            }\n            .fixedSize()\n            .scenePadding()\n            #endif\n        }\n\n        #if os(macOS)\n        Settings {\n            TabExample()\n        }\n        #endif\n    }\n}\n\n\nstruct TabExample: View {\n    var body: some View {\n        TabView {\n            CardsView().tabItem {\n                Label(\"Cards\", systemImage: \"rectangle.portrait.on.rectangle.portrait\")\n            }\n            RulesView().tabItem {\n                Label(\"Rules\", systemImage: \"character.book.closed\")\n            }\n            ProfileView().tabItem {\n                Label(\"Profile\", systemImage: \"person.circle\")\n            }\n            SearchPlayersView().tabItem {\n                Label(\"Magic\", systemImage: \"sparkles\")\n            }\n        }\n    }\n}\n\nstruct CardsView: View {\n    var body: some View { Color.clear }\n}\nstruct RulesView: View {\n    var body: some View { Color.clear }\n}\nstruct ProfileView: View {\n    var body: some View { Color.clear }\n}\nstruct SearchPlayersView: View {\n    var body: some View { Color.clear }\n}"
    },
    {
      "timestamp": "21:31",
      "title": "Canvas",
      "language": "swift",
      "code": "struct ContentView: View {\n    let symbols = Array(repeating: Symbol(\"swift\"), count: 3166)\n\n    var body: some View {\n        Canvas { context, size in\n            let metrics = gridMetrics(in: size)\n            for (index, symbol) in symbols.enumerated() {\n                let rect = metrics[index]\n                let image = context.resolve(symbol.image)\n                context.draw(image, in: rect.fit(image.size))\n            }\n        }\n    }\n\n    func gridMetrics(in size: CGSize) -> SymbolGridMetrics {\n        SymbolGridMetrics(size: size, numberOfSymbols: symbols.count)\n    }\n}\n\nstruct Symbol: Identifiable {\n    let name: String\n    init(_ name: String) { self.name = name }\n\n    var image: Image { Image(systemName: name) }\n    var id: String { name }\n}\n\nstruct SymbolGridMetrics {\n    let symbolWidth: CGFloat\n    let symbolsPerRow: Int\n    let numberOfSymbols: Int\n    let insetProportion: CGFloat\n\n    init(size: CGSize, numberOfSymbols: Int, insetProportion: CGFloat = 0.1) {\n        let areaPerSymbol = (size.width * size.height) / CGFloat(numberOfSymbols)\n        self.symbolsPerRow = Int(size.width / sqrt(areaPerSymbol))\n        self.symbolWidth = size.width / CGFloat(symbolsPerRow)\n        self.numberOfSymbols = numberOfSymbols\n        self.insetProportion = insetProportion\n    }\n\n    /// Returns the frame in the grid for the symbol at `index` position.\n    /// It is not valid to pass an index less than `0` or larger than the number of symbols the grid metrics was created for.\n    subscript(_ index: Int) -> CGRect {\n        precondition(index >= 0 && index < numberOfSymbols)\n        let row = index / symbolsPerRow\n        let column = index % symbolsPerRow\n        let rect = CGRect(\n            x: CGFloat(column) * symbolWidth,\n            y: CGFloat(row) * symbolWidth,\n            width: symbolWidth, height: symbolWidth)\n        return rect.insetBy(dx: symbolWidth * insetProportion, dy: symbolWidth * insetProportion)\n    }\n}\n\nextension CGRect {\n    /// Returns a rect with the aspect ratio of `otherSize`, fitting within `self`.\n    func fit(_ otherSize: CGSize) -> CGRect {\n        let scale = min(size.width / otherSize.width, size.height / otherSize.height)\n        let newSize = CGSize(width: otherSize.width * scale, height: otherSize.height * scale)\n        let newOrigin = CGPoint(x: midX - newSize.width/2, y: midY - newSize.height/2)\n        return CGRect(origin: newOrigin, size: newSize)\n    }\n}"
    },
    {
      "timestamp": "22:03",
      "title": "Canvas with gesture",
      "language": "swift",
      "code": "struct ContentView: View {\n    let symbols = Array(repeating: Symbol(\"swift\"), count: 3166)\n    @GestureState private var focalPoint: CGPoint? = nil\n\n    var body: some View {\n        Canvas { context, size in\n            let metrics = gridMetrics(in: size)\n            for (index, symbol) in symbols.enumerated() {\n                let rect = metrics[index]\n                let (sRect, opacity) = rect.fishEyeTransform(around: focalPoint)\n\n                context.opacity = opacity\n                let image = context.resolve(symbol.image)\n                context.draw(image, in: sRect.fit(image.size))\n            }\n        }\n        .gesture(DragGesture(minimumDistance: 0).updating($focalPoint) { value, focalPoint, _ in\n            focalPoint = value.location\n        })\n    }\n\n    func gridMetrics(in size: CGSize) -> SymbolGridMetrics {\n        SymbolGridMetrics(size: size, numberOfSymbols: symbols.count)\n    }\n}\n\nstruct Symbol: Identifiable {\n    let name: String\n    init(_ name: String) { self.name = name }\n\n    var image: Image { Image(systemName: name) }\n    var id: String { name }\n}\n\nstruct SymbolGridMetrics {\n    let symbolWidth: CGFloat\n    let symbolsPerRow: Int\n    let numberOfSymbols: Int\n    let insetProportion: CGFloat\n\n    init(size: CGSize, numberOfSymbols: Int, insetProportion: CGFloat = 0.1) {\n        let areaPerSymbol = (size.width * size.height) / CGFloat(numberOfSymbols)\n        self.symbolsPerRow = Int(size.width / sqrt(areaPerSymbol))\n        self.symbolWidth = size.width / CGFloat(symbolsPerRow)\n        self.numberOfSymbols = numberOfSymbols\n        self.insetProportion = insetProportion\n    }\n\n    /// Returns the frame in the grid for the symbol at `index` position.\n    /// It is not valid to pass an index less than `0` or larger than the number of symbols the grid metrics was created for.\n    subscript(_ index: Int) -> CGRect {\n        precondition(index >= 0 && index < numberOfSymbols)\n        let row = index / symbolsPerRow\n        let column = index % symbolsPerRow\n        let rect = CGRect(\n            x: CGFloat(column) * symbolWidth,\n            y: CGFloat(row) * symbolWidth,\n            width: symbolWidth, height: symbolWidth)\n        return rect.insetBy(dx: symbolWidth * insetProportion, dy: symbolWidth * insetProportion)\n    }\n}\n\nextension CGRect {\n    /// Returns a rect with the aspect ratio of `otherSize`, fitting within `self`.\n    func fit(_ otherSize: CGSize) -> CGRect {\n        let scale = min(size.width / otherSize.width, size.height / otherSize.height)\n        let newSize = CGSize(width: otherSize.width * scale, height: otherSize.height * scale)\n        let newOrigin = CGPoint(x: midX - newSize.width/2, y: midY - newSize.height/2)\n        return CGRect(origin: newOrigin, size: newSize)\n    }\n\n    /// Returns a transformed rect and relative opacity based on a fish eye effect centered around `point`.\n    /// The rectangles closer to the center of that point will be larger and brighter, and those further away will be smaller, up to a distance of `radius`.\n    func fishEyeTransform(around point: CGPoint?, radius: CGFloat = 300, zoom: CGFloat = 1.0) -> (frame: CGRect, opacity: CGFloat) {\n        guard let point = point else {\n            return (self, 1.0)\n        }\n\n        let deltaX = midX - point.x\n        let deltaY = midY - point.y\n        let distance = sqrt(deltaX*deltaX + deltaY*deltaY)\n        let theta = atan2(deltaY, deltaX)\n\n        let scaledClampedDistance = pow(min(1, max(0, distance/radius)), 0.7)\n        let scale = (1.0 - scaledClampedDistance)*zoom + 0.5\n\n        let newOffset = distance * (2.0 - scaledClampedDistance)*sqrt(zoom)\n        let newDeltaX = newOffset * cos(theta)\n        let newDeltaY = newOffset * sin(theta)\n\n        let newSize = CGSize(width: size.width * scale, height: size.height * scale)\n        let newOrigin = CGPoint(x: (newDeltaX + point.x) - newSize.width/2, y: (newDeltaY + point.y) - newSize.height/2)\n\n        // Clamp the opacity to be 0.1 at the lowest\n        let opacity = max(0.1, 1.0 - scaledClampedDistance)\n        return (CGRect(origin: newOrigin, size: newSize), opacity)\n    }\n}"
    },
    {
      "timestamp": "22:24",
      "title": "Canvas with accessibility children",
      "language": "swift",
      "code": "struct ContentView: View {\n    let symbols = Array(repeating: Symbol(\"swift\"), count: 3166)\n    @GestureState private var focalPoint: CGPoint? = nil\n\n    var body: some View {\n        Canvas { context, size in\n            let metrics = gridMetrics(in: size)\n            for (index, symbol) in symbols.enumerated() {\n                let rect = metrics[index]\n                let (sRect, opacity) = rect.fishEyeTransform(around: focalPoint)\n\n                context.opacity = opacity\n                let image = context.resolve(symbol.image)\n                context.draw(image, in: sRect.fit(image.size))\n            }\n        }\n        .gesture(DragGesture(minimumDistance: 0).updating($focalPoint) { value, focalPoint, _ in\n            focalPoint = value.location\n        })\n        .accessibilityLabel(\"Symbol Browser\")\n        .accessibilityChildren {\n            List(symbols) {\n                Text($0.name)\n            }\n        }\n    }\n\n    func gridMetrics(in size: CGSize) -> SymbolGridMetrics {\n        SymbolGridMetrics(size: size, numberOfSymbols: symbols.count)\n    }\n}\n\nstruct Symbol: Identifiable {\n    let name: String\n    init(_ name: String) { self.name = name }\n\n    var image: Image { Image(systemName: name) }\n    var id: String { name }\n}\n\nstruct SymbolGridMetrics {\n    let symbolWidth: CGFloat\n    let symbolsPerRow: Int\n    let numberOfSymbols: Int\n    let insetProportion: CGFloat\n\n    init(size: CGSize, numberOfSymbols: Int, insetProportion: CGFloat = 0.1) {\n        let areaPerSymbol = (size.width * size.height) / CGFloat(numberOfSymbols)\n        self.symbolsPerRow = Int(size.width / sqrt(areaPerSymbol))\n        self.symbolWidth = size.width / CGFloat(symbolsPerRow)\n        self.numberOfSymbols = numberOfSymbols\n        self.insetProportion = insetProportion\n    }\n\n    /// Returns the frame in the grid for the symbol at `index` position.\n    /// It is not valid to pass an index less than `0` or larger than the number of symbols the grid metrics was created for.\n    subscript(_ index: Int) -> CGRect {\n        precondition(index >= 0 && index < numberOfSymbols)\n        let row = index / symbolsPerRow\n        let column = index % symbolsPerRow\n        let rect = CGRect(\n            x: CGFloat(column) * symbolWidth,\n            y: CGFloat(row) * symbolWidth,\n            width: symbolWidth, height: symbolWidth)\n        return rect.insetBy(dx: symbolWidth * insetProportion, dy: symbolWidth * insetProportion)\n    }\n}\n\nextension CGRect {\n    /// Returns a rect with the aspect ratio of `otherSize`, fitting within `self`.\n    func fit(_ otherSize: CGSize) -> CGRect {\n        let scale = min(size.width / otherSize.width, size.height / otherSize.height)\n        let newSize = CGSize(width: otherSize.width * scale, height: otherSize.height * scale)\n        let newOrigin = CGPoint(x: midX - newSize.width/2, y: midY - newSize.height/2)\n        return CGRect(origin: newOrigin, size: newSize)\n    }\n\n    /// Returns a transformed rect and relative opacity based on a fish eye effect centered around `point`.\n    /// The rectangles closer to the center of that point will be larger and brighter, and those further away will be smaller, up to a distance of `radius`.\n    func fishEyeTransform(around point: CGPoint?, radius: CGFloat = 300, zoom: CGFloat = 1.0) -> (frame: CGRect, opacity: CGFloat) {\n        guard let point = point else {\n            return (self, 1.0)\n        }\n\n        let deltaX = midX - point.x\n        let deltaY = midY - point.y\n        let distance = sqrt(deltaX*deltaX + deltaY*deltaY)\n        let theta = atan2(deltaY, deltaX)\n\n        let scaledClampedDistance = pow(min(1, max(0, distance/radius)), 0.7)\n        let scale = (1.0 - scaledClampedDistance)*zoom + 0.5\n\n        let newOffset = distance * (2.0 - scaledClampedDistance)*sqrt(zoom)\n        let newDeltaX = newOffset * cos(theta)\n        let newDeltaY = newOffset * sin(theta)\n\n        let newSize = CGSize(width: size.width * scale, height: size.height * scale)\n        let newOrigin = CGPoint(x: (newDeltaX + point.x) - newSize.width/2, y: (newDeltaY + point.y) - newSize.height/2)\n\n        // Clamp the opacity to be 0.1 at the lowest\n        let opacity = max(0.1, 1.0 - scaledClampedDistance)\n        return (CGRect(origin: newOrigin, size: newSize), opacity)\n    }\n}"
    },
    {
      "timestamp": "22:48",
      "title": "Canvas with TimelineView",
      "language": "swift",
      "code": "struct ContentView: View {\n    let symbols = Array(repeating: Symbol(\"swift\"), count: 3166)\n\n    var body: some View {\n        TimelineView(.animation) {\n           let time = $0.date.timeIntervalSince1970\n           Canvas { context, size in\n              let metrics = gridMetrics(in: size)\n              let focalPoint = focalPoint(at: time, in: size)\n              for (index, symbol) in symbols.enumerated() {\n                let rect = metrics[index]\n                let (sRect, opacity) = rect.fishEyeTransform(\n                   around: focalPoint, at: time)\n\n                 context.opacity = opacity\n                 let image = context.resolve(symbol.image)\n                 context.draw(image, in: sRect.fit(image.size))\n              }\n           }\n        }\n    }\n\n    func gridMetrics(in size: CGSize) -> SymbolGridMetrics {\n        SymbolGridMetrics(size: size, numberOfSymbols: symbols.count)\n    }\n}\n\nstruct Symbol: Identifiable {\n    let name: String\n    init(_ name: String) { self.name = name }\n\n    var image: Image { Image(systemName: name) }\n    var id: String { name }\n}\n\nstruct SymbolGridMetrics {\n    let symbolWidth: CGFloat\n    let symbolsPerRow: Int\n    let numberOfSymbols: Int\n    let insetProportion: CGFloat\n\n    init(size: CGSize, numberOfSymbols: Int, insetProportion: CGFloat = 0.1) {\n        let areaPerSymbol = (size.width * size.height) / CGFloat(numberOfSymbols)\n        self.symbolsPerRow = Int(size.width / sqrt(areaPerSymbol))\n        self.symbolWidth = size.width / CGFloat(symbolsPerRow)\n        self.numberOfSymbols = numberOfSymbols\n        self.insetProportion = insetProportion\n    }\n\n    /// Returns the frame in the grid for the symbol at `index` position.\n    /// It is not valid to pass an index less than `0` or larger than the number of symbols the grid metrics was created for.\n    subscript(_ index: Int) -> CGRect {\n        precondition(index >= 0 && index < numberOfSymbols)\n        let row = index / symbolsPerRow\n        let column = index % symbolsPerRow\n        let rect = CGRect(\n            x: CGFloat(column) * symbolWidth,\n            y: CGFloat(row) * symbolWidth,\n            width: symbolWidth, height: symbolWidth)\n        return rect.insetBy(dx: symbolWidth * insetProportion, dy: symbolWidth * insetProportion)\n    }\n}\n\nextension CGRect {\n    /// Returns a rect with the aspect ratio of `otherSize`, fitting within `self`.\n    func fit(_ otherSize: CGSize) -> CGRect {\n        let scale = min(size.width / otherSize.width, size.height / otherSize.height)\n        let newSize = CGSize(width: otherSize.width * scale, height: otherSize.height * scale)\n        let newOrigin = CGPoint(x: midX - newSize.width/2, y: midY - newSize.height/2)\n        return CGRect(origin: newOrigin, size: newSize)\n    }\n\n    /// Returns a transformed rect and relative opacity based on a fish eye effect centered around `point`.\n    /// The rectangles closer to the center of that point will be larger and brighter, and those further away will be smaller, up to a distance of `radius`.\n    func fishEyeTransform(around point: CGPoint?, radius: CGFloat = 200, zoom: CGFloat = 3.0) -> (frame: CGRect, opacity: CGFloat) {\n        guard let point = point else {\n            return (self, 1.0)\n        }\n\n        let deltaX = midX - point.x\n        let deltaY = midY - point.y\n        let distance = sqrt(deltaX*deltaX + deltaY*deltaY)\n        let theta = atan2(deltaY, deltaX)\n\n        let scaledClampedDistance = pow(min(1, max(0, distance/radius)), 0.7)\n        let scale = (1.0 - scaledClampedDistance)*zoom + 0.5\n\n        let newOffset = distance * (2.0 - scaledClampedDistance)*sqrt(zoom)\n        let newDeltaX = newOffset * cos(theta)\n        let newDeltaY = newOffset * sin(theta)\n\n        let newSize = CGSize(width: size.width * scale, height: size.height * scale)\n        let newOrigin = CGPoint(x: (newDeltaX + point.x) - newSize.width/2, y: (newDeltaY + point.y) - newSize.height/2)\n\n        // Clamp the opacity to be 0.1 at the lowest\n        let opacity = max(0.1, 1.0 - scaledClampedDistance)\n        return (CGRect(origin: newOrigin, size: newSize), opacity)\n    }\n\n    /// Returns a transformed rect and relative opacity based on a fish eye effect centered around `point`, based on a preset path indexed using `time`.\n    func fishEyeTransform(around point: CGPoint, at time: TimeInterval) -> (frame: CGRect, opacity: CGFloat) {\n        // Arbitrary zoom and radius calculation based on time\n        let zoom = cos(time) + 3.0\n        let radius = ((cos(time/5) + 1)/2) * 150 + 150\n        return fishEyeTransform(around: point, radius: radius, zoom: zoom)\n    }\n}\n\n/// Returns a focal point within `size` based on a preset path, indexed using `time`.\nfunc focalPoint(at time: TimeInterval, in size: CGSize) -> CGPoint {\n   let offset: CGFloat = min(size.width, size.height)/4\n   let distance = ((sin(time/5) + 1)/2) * offset + offset\n   let scalePoint = CGPoint(x: size.width / 2 + distance * cos(time / 2), y: size.height / 2 + distance * sin(time / 2))\n   return scalePoint\n}"
    },
    {
      "timestamp": "24:10",
      "title": "Privacy sensitive",
      "language": "swift",
      "code": "Button {\n    showFavoritePicker = true\n} label: {\n    VStack(alignment: .center) {\n        Text(\"Favorite Symbol\")\n            .foregroundStyle(.secondary)\n        Image(systemName: favoriteSymbol)\n            .font(.title2)\n            .privacySensitive(true)\n   }\n}\n.tint(.purple)"
    },
    {
      "timestamp": "24:27",
      "title": "Privacy sensitive (widgets)",
      "language": "swift",
      "code": "VStack(alignment: .leading) {\n    Text(\"Favorite Symbol\")\n        .textCase(.uppercase)\n        .font(.caption.bold())\n\n    ContainerRelativeShape()\n        .fill(.quaternary)\n        .overlay {\n            Image(systemName: favoriteSymbol)\n                .font(.system(size: 40))\n                .privacySensitive(true)\n        }\n}"
    },
    {
      "timestamp": "25:03",
      "title": "Materials",
      "language": "swift",
      "code": "struct ColorList: View {\n    let symbols = Array(repeating: Symbol(\"swift\"), count: 3166)\n\n    var body: some View {\n        ZStack {\n            gradientBackground\n            materialOverlay\n        }\n    }\n\n    var materialOverlay: some View {\n        VStack {\n           Text(\"Symbol Browser\")\n              .font(.largeTitle.bold())\n           Text(\"\\(symbols.count) symbols 🎉\")\n              .foregroundStyle(.secondary)\n              .font(.title2.bold())\n        }\n        .padding()\n        .background(.ultraThinMaterial, in: RoundedRectangle(cornerRadius: 16.0))\n    }\n\n    var gradientBackground: some View {\n        LinearGradient(\n            gradient: Gradient(colors: [.red, .orange, .yellow, .green, .blue, .indigo, .purple]),\n            startPoint: .leading, endPoint: .trailing)\n    }\n}\n\nstruct Symbol: Identifiable {\n    let name: String\n    init(_ name: String) { self.name = name }\n\n    var image: Image { Image(systemName: name) }\n    var id: String { name }\n}"
    },
    {
      "timestamp": "25:40",
      "title": "Safe area inset",
      "language": "swift",
      "code": "struct ContentView: View {\n    let newSymbols = Array(repeating: Symbol(\"swift\"), count: 645)\n    let systemColors: [Color] = [.red, .orange, .yellow, .green, .mint, .teal, .cyan, .blue, .indigo, .purple, .pink, .gray, .brown]\n\n    var body: some View {\n        ScrollView {\n            symbolGrid\n        }\n        .safeAreaInset(edge: .bottom, spacing: 0) {\n            VStack(spacing: 0) {\n                Divider()\n                VStack(spacing: 0) {\n                    Text(\"\\(newSymbols.count) new symbols\")\n                        .foregroundStyle(.primary)\n                        .font(.body.bold())\n                    Text(\"\\(systemColors.count) system colors\")\n                        .foregroundStyle(.secondary)\n                }\n                .padding()\n            }\n            .background(.regularMaterial)\n        }\n    }\n\n    var symbolGrid: some View {\n        LazyVGrid(columns: [.init(.adaptive(minimum: 40, maximum: 40))]) {\n            ForEach(0 ..< newSymbols.count, id: \\.self) { index in\n                newSymbols[index].image\n                    .foregroundStyle(.white)\n                    .frame(width: 40, height: 40)\n                    .background(systemColors[index % systemColors.count])\n            }\n        }\n        .padding()\n    }\n}\n\nstruct Symbol: Identifiable {\n    let name: String\n    init(_ name: String) { self.name = name }\n\n    var image: Image { Image(systemName: name) }\n    var id: String { name }\n}"
    },
    {
      "timestamp": "26:03",
      "title": "Preview orientation",
      "language": "swift",
      "code": "struct ColorList_Previews: PreviewProvider {\n    static var previews: some View {\n        ColorList()\n            .previewInterfaceOrientation(.portrait)\n\n        ColorList()\n            .previewInterfaceOrientation(.landscapeLeft)\n    }\n}\n\nstruct ColorList: View {\n    let newSymbols = Array(repeating: Symbol(\"swift\"), count: 645)\n    let systemColors: [Color] = [.red, .orange, .yellow, .green, .mint, .teal, .cyan, .blue, .indigo, .purple, .pink, .gray, .brown]\n\n    var body: some View {\n        ScrollView {\n            symbolGrid\n        }\n        .safeAreaInset(edge: .bottom, spacing: 0) {\n            VStack(spacing: 0) {\n                Divider()\n                VStack(spacing: 0) {\n                    Text(\"\\(newSymbols.count) new symbols\")\n                        .foregroundStyle(.primary)\n                        .font(.body.bold())\n                    Text(\"\\(systemColors.count) system colors\")\n                        .foregroundStyle(.secondary)\n                }\n                .padding()\n            }\n            .background(.regularMaterial)\n        }\n    }\n\n    var symbolGrid: some View {\n        LazyVGrid(columns: [.init(.adaptive(minimum: 40, maximum: 40))]) {\n            ForEach(0 ..< newSymbols.count, id: \\.self) { index in\n                newSymbols[index].image\n                    .foregroundStyle(.white)\n                    .frame(width: 40, height: 40)\n                    .background(systemColors[index % systemColors.count])\n            }\n        }\n        .padding()\n    }\n}\n\nstruct Symbol: Identifiable {\n    let name: String\n    init(_ name: String) { self.name = name }\n\n    var image: Image { Image(systemName: name) }\n    var id: String { name }\n}"
    },
    {
      "timestamp": "27:06",
      "title": "Hello, World!",
      "language": "swift",
      "code": "Text(\"Hello, World!\")"
    },
    {
      "timestamp": "27:17",
      "title": "Markdown Text: strong emphasis",
      "language": "swift",
      "code": "Text(\"**Hello**, World!\")"
    },
    {
      "timestamp": "27:24",
      "title": "Markdown Text: links",
      "language": "swift",
      "code": "Text(\"**Hello**, World!\")\nText(\"\"\"\nHave a *happy* [WWDC](https://developer.apple.com/wwdc21/)!\n\"\"\")"
    },
    {
      "timestamp": "27:30",
      "title": "Markdown Text: inline code",
      "language": "swift",
      "code": "Text(\"\"\"\nIs this *too* meta?\n\n`Text(\"**Hello**, World!\")`\n`Text(\\\"\\\"\\\"`\n`Have a *happy* [WWDC](https://developer.apple.com/wwdc21/)!`\n`\\\"\\\"\\\")`\n\"\"\")"
    },
    {
      "timestamp": "27:37",
      "title": "AttributedString",
      "language": "swift",
      "code": "struct ContentView: View {\n    var body: some View {\n        Text(formattedDate)\n    }\n\n    var formattedDate: AttributedString {\n        var formattedDate: AttributedString = Date().formatted(Date.FormatStyle().day().month(.wide).weekday(.wide).attributed)\n\n        let weekday = AttributeContainer.dateField(.weekday)\n        let color = AttributeContainer.foregroundColor(.orange)\n        formattedDate.replaceAttributes(weekday, with: color)\n\n        return formattedDate\n    }\n}"
    },
    {
      "timestamp": "29:17",
      "title": "Text selection",
      "language": "swift",
      "code": "struct ContentView: View {\n    var activity: Activity = .sample\n\n    var body: some View {\n        VStack(alignment: .leading, spacing: 0) {\n            ActivityHeader(activity)\n            Divider()\n            Text(activity.info)\n                .textSelection(.enabled)\n                .padding()\n            Spacer()\n        }\n        .background()\n        .navigationTitle(activity.name)\n    }\n}\n\nstruct ActivityHeader: View {\n    var activity: Activity\n    init(_ activity: Activity) { self.activity = activity }\n\n    var body: some View {\n        VStack(alignment: alignment.horizontal, spacing: 8) {\n            HStack(alignment: .firstTextBaseline) {\n#if os(macOS)\n                Text(activity.name)\n                    .font(.title2.bold())\n                Spacer()\n#endif\n                Text(activity.date.formatted(.dateTime.weekday(.wide).day().month().hour().minute()))\n                    .foregroundStyle(.secondary)\n            }\n            HStack(alignment: .firstTextBaseline) {\n                Image(systemName: \"person.2\")\n                Text(activity.people.map(\\.nameComponents).formatted(.list(memberStyle: .name(style: .short), type: .and)))\n            }\n        }\n#if os(macOS)\n        .padding()\n#else\n        .padding([.horizontal, .bottom])\n#endif\n        .frame(maxWidth: .infinity, alignment: alignment)\n        .background(activity.tint.opacity(0.1).ignoresSafeArea())\n    }\n\n    private var alignment: Alignment {\n#if os(macOS)\n        .leading\n#else\n        .center\n#endif\n    }\n}\n\nstruct Activity {\n    var name: String\n    var date: Date\n    var location: String\n    var people: [Person]\n    var info: AttributedString\n    var tint: Color = .purple\n\n    static let sample = Activity(name: \"What's New in SwiftUI\", date: Date(), location: \"Apple Park\", people: [.init(givenName: \"You\")], info: \"This is some info.\")\n}\n\nstruct Person {\n    var givenName: String\n    var familyName: String = \"\"\n\n    var nameComponents: PersonNameComponents {\n        get {\n            var components = PersonNameComponents()\n            components.givenName = givenName\n            if !familyName.isEmpty {\n                components.familyName = familyName\n            }\n            return components\n        }\n        set {\n            givenName = newValue.givenName ?? \"\"\n            familyName = newValue.familyName ?? \"\"\n        }\n    }\n}"
    },
    {
      "timestamp": "29:28",
      "title": "Text selection: view hierarchy",
      "language": "swift",
      "code": "struct ContentView: View {\n    var activity: Activity = .sample\n\n    var body: some View {\n        VStack(alignment: .leading, spacing: 0) {\n            ActivityHeader(activity)\n            Divider()\n            Text(activity.info)\n                .padding()\n            Spacer()\n        }\n        .textSelection(.enabled)\n        .background()\n        .navigationTitle(activity.name)\n    }\n}\n\nstruct ActivityHeader: View {\n    var activity: Activity\n    init(_ activity: Activity) { self.activity = activity }\n\n    var body: some View {\n        VStack(alignment: alignment.horizontal, spacing: 8) {\n            HStack(alignment: .firstTextBaseline) {\n#if os(macOS)\n                Text(activity.name)\n                    .font(.title2.bold())\n                Spacer()\n#endif\n                Text(activity.date.formatted(.dateTime.weekday(.wide).day().month().hour().minute()))\n                    .foregroundStyle(.secondary)\n            }\n            HStack(alignment: .firstTextBaseline) {\n                Image(systemName: \"person.2\")\n                Text(activity.people.map(\\.nameComponents).formatted(.list(memberStyle: .name(style: .short), type: .and)))\n            }\n        }\n#if os(macOS)\n        .padding()\n#else\n        .padding([.horizontal, .bottom])\n#endif\n        .frame(maxWidth: .infinity, alignment: alignment)\n        .background(activity.tint.opacity(0.1).ignoresSafeArea())\n    }\n\n    private var alignment: Alignment {\n#if os(macOS)\n        .leading\n#else\n        .center\n#endif\n    }\n}\n\nstruct Activity {\n    var name: String\n    var date: Date\n    var location: String\n    var people: [Person]\n    var info: AttributedString\n    var tint: Color = .purple\n\n    static let sample = Activity(name: \"What's New in SwiftUI\", date: Date(), location: \"Apple Park\", people: [.init(givenName: \"You\")], info: \"This is some info.\")\n}\n\nstruct Person {\n    var givenName: String\n    var familyName: String = \"\"\n\n    var nameComponents: PersonNameComponents {\n        get {\n            var components = PersonNameComponents()\n            components.givenName = givenName\n            if !familyName.isEmpty {\n                components.familyName = familyName\n            }\n            return components\n        }\n        set {\n            givenName = newValue.givenName ?? \"\"\n            familyName = newValue.familyName ?? \"\"\n        }\n    }\n}"
    },
    {
      "timestamp": "30:03",
      "title": "Text formatting: List",
      "language": "swift",
      "code": "struct ContentView: View {\n    var activity: Activity = .sample\n\n    var body: some View {\n        Text(activity.people.map(\\.nameComponents).formatted(.list(memberStyle: .name(style: .short), type: .and)))\n            .scenePadding()\n    }\n}\n\nstruct Activity {\n    var name: String\n    var date: Date\n    var location: String\n    var people: [Person]\n    var info: AttributedString\n    var tint: Color = .purple\n\n    static let sample = Activity(name: \"What's New in SwiftUI\", date: Date(), location: \"Apple Park\", people: [.init(givenName: \"You\")], info: \"This is some info.\")\n}\n\nstruct Person {\n    var givenName: String\n    var familyName: String = \"\"\n\n    var nameComponents: PersonNameComponents {\n        get {\n            var components = PersonNameComponents()\n            components.givenName = givenName\n            if !familyName.isEmpty {\n                components.familyName = familyName\n            }\n            return components\n        }\n        set {\n            givenName = newValue.givenName ?? \"\"\n            familyName = newValue.familyName ?? \"\"\n        }\n    }\n}"
    },
    {
      "timestamp": "30:43",
      "title": "Text field formatting",
      "language": "swift",
      "code": "struct ContentView: View {\n    @State private var newAttendee = PersonNameComponents()\n\n    var body: some View {\n       TextField(\"New Person\", value: $newAttendee,\n          format: .name(style: .medium))\n    }\n}"
    },
    {
      "timestamp": "31:09",
      "title": "Text field prompts and labels",
      "language": "swift",
      "code": "struct ContentView: View {\n    @State var activity: Activity = .sample\n\n    var body: some View {\n        Form {\n            TextField(\"Name:\", text: $activity.name, prompt: Text(\"New Activity\"))\n            TextField(\"Location:\", text: $activity.location)\n            DatePicker(\"Date:\", selection: $activity.date)\n        }\n        .frame(minWidth: 250)\n        .padding()\n    }\n}\n\nstruct Activity {\n    var name: String\n    var date: Date\n    var location: String\n    var people: [Person]\n    var info: AttributedString\n    var tint: Color = .purple\n\n    static let sample = Activity(name: \"What's New in SwiftUI\", date: Date(), location: \"Apple Park\", people: [.init(givenName: \"You\")], info: \"This is some info.\")\n}\n\nstruct Person {\n    var givenName: String\n    var familyName: String = \"\"\n\n    var nameComponents: PersonNameComponents {\n        get {\n            var components = PersonNameComponents()\n            components.givenName = givenName\n            if !familyName.isEmpty {\n                components.familyName = familyName\n            }\n            return components\n        }\n        set {\n            givenName = newValue.givenName ?? \"\"\n            familyName = newValue.familyName ?? \"\"\n        }\n    }\n}"
    },
    {
      "timestamp": "31:39",
      "title": "Text field submission",
      "language": "swift",
      "code": "struct ContentView: View {\n    @State private var activity: Activity = .sample\n    @State private var newAttendee = PersonNameComponents()\n\n    var body: some View {\n        TextField(\"New Person\", value: $newAttendee,\n            format: .name(style: .medium)\n        )\n        .onSubmit {\n            activity.append(Person(newAttendee))\n            newAttendee = PersonNameComponents()\n        }\n    }\n}\n\nstruct Activity {\n    var name: String\n    var date: Date\n    var location: String\n    var people: [Person]\n    var info: AttributedString\n    var tint: Color = .purple\n\n    static let sample = Activity(name: \"What's New in SwiftUI\", date: Date(), location: \"Apple Park\", people: [.init(givenName: \"You\")], info: \"This is some info.\")\n\n    mutating func append(_ person: Person) {\n        people.append(person)\n    }\n}\n\nstruct Person {\n    var givenName: String\n    var familyName: String\n\n    init(givenName: String, familyName: String = \"\") {\n        self.givenName = givenName\n        self.familyName = familyName\n    }\n\n    init(_ nameComponents: PersonNameComponents) {\n        givenName = nameComponents.givenName ?? \"\"\n        familyName = nameComponents.familyName ?? \"\"\n    }\n\n    var nameComponents: PersonNameComponents {\n        get {\n            var components = PersonNameComponents()\n            components.givenName = givenName\n            if !familyName.isEmpty {\n                components.familyName = familyName\n            }\n            return components\n        }\n        set {\n            givenName = newValue.givenName ?? \"\"\n            familyName = newValue.familyName ?? \"\"\n        }\n    }\n}"
    },
    {
      "timestamp": "31:59",
      "title": "Text field submission: submit label",
      "language": "swift",
      "code": "struct ContentView: View {\n    @State private var activity: Activity = .sample\n    @State private var newAttendee = PersonNameComponents()\n\n    var body: some View {\n        TextField(\"New Person\", value: $newAttendee,\n            format: .name(style: .medium)\n        )\n        .onSubmit {\n            activity.append(Person(newAttendee))\n            newAttendee = PersonNameComponents()\n        }\n        .submitLabel(.done)\n    }\n}\n\nstruct Activity {\n    var name: String\n    var date: Date\n    var location: String\n    var people: [Person]\n    var info: AttributedString\n    var tint: Color = .purple\n\n    static let sample = Activity(name: \"What's New in SwiftUI\", date: Date(), location: \"Apple Park\", people: [.init(givenName: \"You\")], info: \"This is some info.\")\n\n    mutating func append(_ person: Person) {\n        people.append(person)\n    }\n}\n\nstruct Person {\n    var givenName: String\n    var familyName: String\n\n    init(givenName: String, familyName: String = \"\") {\n        self.givenName = givenName\n        self.familyName = familyName\n    }\n\n    init(_ nameComponents: PersonNameComponents) {\n        givenName = nameComponents.givenName ?? \"\"\n        familyName = nameComponents.familyName ?? \"\"\n    }\n\n    var nameComponents: PersonNameComponents {\n        get {\n            var components = PersonNameComponents()\n            components.givenName = givenName\n            if !familyName.isEmpty {\n                components.familyName = familyName\n            }\n            return components\n        }\n        set {\n            givenName = newValue.givenName ?? \"\"\n            familyName = newValue.familyName ?? \"\"\n        }\n    }\n}"
    },
    {
      "timestamp": "32:07",
      "title": "Keyboard toolbar",
      "language": "swift",
      "code": "struct ContentView: View {\n    @State private var activity: Activity = .sample\n    @FocusState private var focusedField: Field?\n\n    var body: some View {\n        Form {\n            TextField(\"Name\", text: $activity.name, prompt: Text(\"New Activity\"))\n            TextField(\"Location\", text: $activity.location)\n            DatePicker(\"Date\", selection: $activity.date)\n        }\n        .toolbar {\n            ToolbarItemGroup(placement: .keyboard) {\n                Button(action: selectPreviousField) {\n                    Label(\"Previous\", systemImage: \"chevron.up\")\n                }\n                .disabled(!hasPreviousField)\n\n                Button(action: selectNextField) {\n                    Label(\"Next\", systemImage: \"chevron.down\")\n                }\n                .disabled(!hasNextField)\n            }\n        }\n    }\n\n    private func selectPreviousField() {\n       focusedField = focusedField.map {\n          Field(rawValue: $0.rawValue - 1)!\n       }\n    }\n\n    private var hasPreviousField: Bool {\n        if let currentFocusedField = focusedField {\n            return currentFocusedField.rawValue > 0\n        } else {\n            return false\n        }\n    }\n\n    private func selectNextField() {\n       focusedField = focusedField.map {\n          Field(rawValue: $0.rawValue + 1)!\n       }\n    }\n\n    private var hasNextField: Bool {\n        if let currentFocusedField = focusedField {\n            return currentFocusedField.rawValue < Field.allCases.count\n        } else {\n            return false\n        }\n    }\n}\n\nprivate enum Field: Int, Hashable, CaseIterable {\n   case name, location, date, addAttendee\n}\n\nstruct Activity {\n    var name: String\n    var date: Date\n    var location: String\n    var people: [Person]\n    var info: AttributedString\n    var tint: Color = .purple\n\n    static let sample = Activity(name: \"What's New in SwiftUI\", date: Date(), location: \"Apple Park\", people: [.init(givenName: \"You\")], info: \"This is some info.\")\n\n    mutating func append(_ person: Person) {\n        people.append(person)\n    }\n}\n\nstruct Person {\n    var givenName: String\n    var familyName: String\n\n    init(givenName: String, familyName: String = \"\") {\n        self.givenName = givenName\n        self.familyName = familyName\n    }\n\n    init(_ nameComponents: PersonNameComponents) {\n        givenName = nameComponents.givenName ?? \"\"\n        familyName = nameComponents.familyName ?? \"\"\n    }\n\n    var nameComponents: PersonNameComponents {\n        get {\n            var components = PersonNameComponents()\n            components.givenName = givenName\n            if !familyName.isEmpty {\n                components.familyName = familyName\n            }\n            return components\n        }\n        set {\n            givenName = newValue.givenName ?? \"\"\n            familyName = newValue.familyName ?? \"\"\n        }\n    }\n}"
    },
    {
      "timestamp": "33:05",
      "title": "Focus state",
      "language": "swift",
      "code": "struct ContentView: View {\n    @State private var activity: Activity = .sample\n    @State private var newAttendee = PersonNameComponents()\n    @FocusState private var addAttendeeIsFocused: Bool\n\n    var body: some View {\n        VStack {\n            Form {\n                TextField(\"Name:\", text: $activity.name, prompt: Text(\"New Activity\"))\n                TextField(\"Location:\", text: $activity.location)\n                DatePicker(\"Date:\", selection: $activity.date)\n            }\n\n            TextField(\"New Person\", value: $newAttendee, format: .name(style: .medium))\n                .focused($addAttendeeIsFocused)\n        }\n        .frame(minWidth: 250)\n        .scenePadding()\n    }\n}\n\nstruct Activity {\n    var name: String\n    var date: Date\n    var location: String\n    var people: [Person]\n    var info: AttributedString\n    var tint: Color = .purple\n\n    static let sample = Activity(name: \"What's New in SwiftUI\", date: Date(), location: \"Apple Park\", people: [.init(givenName: \"You\")], info: \"This is some info.\")\n\n    mutating func append(_ person: Person) {\n        people.append(person)\n    }\n}\n\nstruct Person {\n    var givenName: String\n    var familyName: String\n\n    init(givenName: String, familyName: String = \"\") {\n        self.givenName = givenName\n        self.familyName = familyName\n    }\n\n    init(_ nameComponents: PersonNameComponents) {\n        givenName = nameComponents.givenName ?? \"\"\n        familyName = nameComponents.familyName ?? \"\"\n    }\n\n    var nameComponents: PersonNameComponents {\n        get {\n            var components = PersonNameComponents()\n            components.givenName = givenName\n            if !familyName.isEmpty {\n                components.familyName = familyName\n            }\n            return components\n        }\n        set {\n            givenName = newValue.givenName ?? \"\"\n            familyName = newValue.familyName ?? \"\"\n        }\n    }\n}"
    },
    {
      "timestamp": "33:16",
      "title": "Focus state: setting focus",
      "language": "swift",
      "code": "struct ContentView: View {\n    @State private var activity: Activity = .sample\n    @State private var newAttendee = PersonNameComponents()\n    @FocusState private var addAttendeeIsFocused: Bool\n\n    var body: some View {\n        VStack {\n            Form {\n                TextField(\"Name:\", text: $activity.name, prompt: Text(\"New Activity\"))\n                TextField(\"Location:\", text: $activity.location)\n                DatePicker(\"Date:\", selection: $activity.date)\n            }\n\n            VStack(alignment: .leading) {\n                TextField(\"New Person\", value: $newAttendee, format: .name(style: .medium))\n                    .focused($addAttendeeIsFocused)\n\n                ControlGroup {\n                    Button {\n                        addAttendeeIsFocused = true\n                    } label: {\n                       Label(\"Add Attendee\", systemImage: \"plus\")\n                    }\n                }\n                .fixedSize()\n            }\n        }\n        .frame(minWidth: 250)\n        .scenePadding()\n    }\n}\n\nstruct Activity {\n    var name: String\n    var date: Date\n    var location: String\n    var people: [Person]\n    var info: AttributedString\n    var tint: Color = .purple\n\n    static let sample = Activity(name: \"What's New in SwiftUI\", date: Date(), location: \"Apple Park\", people: [.init(givenName: \"You\")], info: \"This is some info.\")\n\n    mutating func append(_ person: Person) {\n        people.append(person)\n    }\n}\n\nstruct Person {\n    var givenName: String\n    var familyName: String\n\n    init(givenName: String, familyName: String = \"\") {\n        self.givenName = givenName\n        self.familyName = familyName\n    }\n\n    init(_ nameComponents: PersonNameComponents) {\n        givenName = nameComponents.givenName ?? \"\"\n        familyName = nameComponents.familyName ?? \"\"\n    }\n\n    var nameComponents: PersonNameComponents {\n        get {\n            var components = PersonNameComponents()\n            components.givenName = givenName\n            if !familyName.isEmpty {\n                components.familyName = familyName\n            }\n            return components\n        }\n        set {\n            givenName = newValue.givenName ?? \"\"\n            familyName = newValue.familyName ?? \"\"\n        }\n    }\n}"
    },
    {
      "timestamp": "33:30",
      "title": "Focus state: Hashable value",
      "language": "swift",
      "code": "private enum Field: Int, Hashable, CaseIterable {\n   case name, location, date, addAttendee\n}\n\nstruct ContentView: View {\n    @State private var activity: Activity = .sample\n    @State private var newAttendee = PersonNameComponents()\n    @FocusState private var focusedField: Field?\n\n    var body: some View {\n        VStack {\n            Form {\n                TextField(\"Name:\", text: $activity.name, prompt: Text(\"New Activity\"))\n                    .focused($focusedField, equals: .name)\n                TextField(\"Location:\", text: $activity.location)\n                    .focused($focusedField, equals: .location)\n                DatePicker(\"Date:\", selection: $activity.date)\n                    .focused($focusedField, equals: .date)\n            }\n\n            VStack(alignment: .leading) {\n                TextField(\"New Person\", value: $newAttendee, format: .name(style: .medium))\n                    .focused($focusedField, equals: .addAttendee)\n\n                ControlGroup {\n                    Button {\n                        focusedField = .addAttendee\n                    } label: {\n                       Label(\"Add Attendee\", systemImage: \"plus\")\n                    }\n                }\n                .fixedSize()\n            }\n        }\n        .frame(minWidth: 250)\n        .scenePadding()\n    }\n}\n\nstruct Activity {\n    var name: String\n    var date: Date\n    var location: String\n    var people: [Person]\n    var info: AttributedString\n    var tint: Color = .purple\n\n    static let sample = Activity(name: \"What's New in SwiftUI\", date: Date(), location: \"Apple Park\", people: [.init(givenName: \"You\")], info: \"This is some info.\")\n\n    mutating func append(_ person: Person) {\n        people.append(person)\n    }\n}\n\nstruct Person {\n    var givenName: String\n    var familyName: String\n\n    init(givenName: String, familyName: String = \"\") {\n        self.givenName = givenName\n        self.familyName = familyName\n    }\n\n    init(_ nameComponents: PersonNameComponents) {\n        givenName = nameComponents.givenName ?? \"\"\n        familyName = nameComponents.familyName ?? \"\"\n    }\n\n    var nameComponents: PersonNameComponents {\n        get {\n            var components = PersonNameComponents()\n            components.givenName = givenName\n            if !familyName.isEmpty {\n                components.familyName = familyName\n            }\n            return components\n        }\n        set {\n            givenName = newValue.givenName ?? \"\"\n            familyName = newValue.familyName ?? \"\"\n        }\n    }\n}"
    },
    {
      "timestamp": "34:03",
      "title": "Focus state: back/forward controls",
      "language": "swift",
      "code": "private enum Field: Int, Hashable, CaseIterable {\n   case name, location, date, addAttendee\n}\n\nstruct ContentView: View {\n    @State private var activity: Activity = .sample\n    @FocusState private var focusedField: Field?\n\n    var body: some View {\n        Form {\n            TextField(\"Name\", text: $activity.name, prompt: Text(\"New Activity\"))\n            TextField(\"Location\", text: $activity.location)\n            DatePicker(\"Date\", selection: $activity.date)\n        }\n        .toolbar {\n            ToolbarItemGroup(placement: .keyboard) {\n                Button(action: selectPreviousField) {\n                    Label(\"Previous\", systemImage: \"chevron.up\")\n                }\n                .disabled(!canSelectPreviousField)\n\n                Button(action: selectNextField) {\n                    Label(\"Next\", systemImage: \"chevron.down\")\n                }\n                .disabled(!canSelectNextField)\n            }\n        }\n    }\n\n    private func selectPreviousField() {\n       focusedField = focusedField.map {\n          Field(rawValue: $0.rawValue - 1)!\n       }\n    }\n\n    private var canSelectPreviousField: Bool {\n        if let currentFocusedField = focusedField {\n            return currentFocusedField.rawValue > 0\n        } else {\n            return false\n        }\n    }\n\n    private func selectNextField() {\n       focusedField = focusedField.map {\n          Field(rawValue: $0.rawValue + 1)!\n       }\n    }\n\n    private var canSelectNextField: Bool {\n        if let currentFocusedField = focusedField {\n            return currentFocusedField.rawValue < Field.allCases.count\n        } else {\n            return false\n        }\n    }\n}\n\nstruct Activity {\n    var name: String\n    var date: Date\n    var location: String\n    var people: [Person]\n    var info: AttributedString\n    var tint: Color = .purple\n\n    static let sample = Activity(name: \"What's New in SwiftUI\", date: Date(), location: \"Apple Park\", people: [.init(givenName: \"You\")], info: \"This is some info.\")\n\n    mutating func append(_ person: Person) {\n        people.append(person)\n    }\n}\n\nstruct Person {\n    var givenName: String\n    var familyName: String\n\n    init(givenName: String, familyName: String = \"\") {\n        self.givenName = givenName\n        self.familyName = familyName\n    }\n\n    init(_ nameComponents: PersonNameComponents) {\n        givenName = nameComponents.givenName ?? \"\"\n        familyName = nameComponents.familyName ?? \"\"\n    }\n\n    var nameComponents: PersonNameComponents {\n        get {\n            var components = PersonNameComponents()\n            components.givenName = givenName\n            if !familyName.isEmpty {\n                components.familyName = familyName\n            }\n            return components\n        }\n        set {\n            givenName = newValue.givenName ?? \"\"\n            familyName = newValue.familyName ?? \"\"\n        }\n    }\n}"
    },
    {
      "timestamp": "34:13",
      "title": "Focus state: keyboard dismissal",
      "language": "swift",
      "code": "private enum Field: Int, Hashable, CaseIterable {\n   case name, location, date, addAttendee\n}\n\nstruct ContentView: View {\n    @State private var activity: Activity = .sample\n    @FocusState private var focusedField: Field?\n\n    var body: some View {\n        Form {\n            TextField(\"Name\", text: $activity.name, prompt: Text(\"New Activity\"))\n            TextField(\"Location\", text: $activity.location)\n            DatePicker(\"Date\", selection: $activity.date)\n        }\n    }\n\n    func endEditing() {\n        focusedField = nil\n    }\n}\n\nstruct Activity {\n    var name: String\n    var date: Date\n    var location: String\n    var people: [Person]\n    var info: AttributedString\n    var tint: Color = .purple\n\n    static let sample = Activity(name: \"What's New in SwiftUI\", date: Date(), location: \"Apple Park\", people: [.init(givenName: \"You\")], info: \"This is some info.\")\n\n    mutating func append(_ person: Person) {\n        people.append(person)\n    }\n}\n\nstruct Person {\n    var givenName: String\n    var familyName: String\n\n    init(givenName: String, familyName: String = \"\") {\n        self.givenName = givenName\n        self.familyName = familyName\n    }\n\n    init(_ nameComponents: PersonNameComponents) {\n        givenName = nameComponents.givenName ?? \"\"\n        familyName = nameComponents.familyName ?? \"\"\n    }\n\n    var nameComponents: PersonNameComponents {\n        get {\n            var components = PersonNameComponents()\n            components.givenName = givenName\n            if !familyName.isEmpty {\n                components.familyName = familyName\n            }\n            return components\n        }\n        set {\n            givenName = newValue.givenName ?? \"\"\n            familyName = newValue.familyName ?? \"\"\n        }\n    }\n}"
    },
    {
      "timestamp": "34:55",
      "title": "Bordered buttons",
      "language": "swift",
      "code": "Button(\"Add\") {\n   // ... \n}\n.buttonStyle(.bordered)"
    },
    {
      "timestamp": "35:03",
      "title": "Bordered buttons: view hierarchy",
      "language": "swift",
      "code": "struct ContentView: View {\n    var body: some View {\n        ScrollView {\n            LazyVStack {\n                ForEach(0..<10) { _ in\n                    Button(\"Add\") {\n                        //...\n                    }\n                }\n            }\n        }\n        .buttonStyle(.bordered)\n    }\n}"
    },
    {
      "timestamp": "35:09",
      "title": "Bordered buttons: tinting",
      "language": "swift",
      "code": "struct ContentView: View {\n    var body: some View {\n        ScrollView {\n            LazyVStack {\n                ForEach(0..<10) { _ in\n                    Button(\"Add\") {\n                        //...\n                    }\n                }\n            }\n        }\n        .buttonStyle(.bordered)\n        .tint(.green)\n    }\n}"
    },
    {
      "timestamp": "35:16",
      "title": "Control size and prominence",
      "language": "swift",
      "code": "struct ContentView: View {\n    var entry: ButtonEntry = .sample\n\n    var body: some View {\n        HStack {\n            ForEach(entry.tags) { tag in\n                Button(tag.name) {\n                    // ...\n                }\n                .tint(tag.color)\n            }\n        }\n        .buttonStyle(.bordered)\n        .controlSize(.small)\n        .controlProminence(.increased)\n    }\n}\n\nstruct ButtonEntry {\n    struct Tag: Identifiable {\n        var name: String\n        var color: Color\n        var id: String { name }\n    }\n\n    var name: String\n    var tags: [Tag]\n\n    static let sample = ButtonEntry(name: \"Stroopwafel\", tags: [Tag(name: \"1960s\", color: .purple), Tag(name: \"bronze\", color: .yellow)])\n}"
    },
    {
      "timestamp": "35:34",
      "title": "Large buttons",
      "language": "swift",
      "code": "struct ContentView: View {\n    var body: some View {\n        VStack {\n            Button(action: addToJar) {\n                Text(\"Add to Jar\").frame(maxWidth: 300)\n            }\n            .controlProminence(.increased)\n            .keyboardShortcut(.defaultAction)\n\n            Button(action: addToWatchlist) {\n                Text(\"Add to Watchlist\").frame(maxWidth: 300)\n            }\n            .tint(.accentColor)\n        }\n        .buttonStyle(.bordered)\n        .controlSize(.large)\n    }\n\n    private func addToJar() {}\n    private func addToWatchlist() {}\n}"
    },
    {
      "timestamp": "37:14",
      "title": "Destructive buttons",
      "language": "swift",
      "code": "struct ContentView: View {\n    var entry: ButtonEntry = .sample\n\n    var body: some View {\n        ButtonEntryCell(entry)\n            .contextMenu {\n                Section {\n                    Button(\"Open\") {\n                        // ...\n                    }\n                    Button(\"Delete...\", role: .destructive) {\n                        // ...\n                    }\n                }\n\n                Section {\n                    Button(\"Archive\") {}\n\n                    Menu(\"Move to\") {\n                        ForEach(Jar.allJars) { jar in\n                            Button(\"\\(jar.name)\") {\n                                //addTo(jar)\n                            }\n                        }\n                    }\n                }\n            }\n    }\n}\n\nstruct ButtonEntryCell: View {\n    var entry: ButtonEntry = .sample\n    init(_ entry: ButtonEntry) { self.entry = entry }\n\n    var body: some View {\n        Text(entry.name)\n            .padding()\n    }\n}\n\nstruct Jar: Identifiable {\n    var name: String\n    var id: String { name }\n\n    static let allJars = [Jar(name: \"Secret Stash\")]\n}\n\nstruct ButtonEntry {\n    struct Tag: Identifiable {\n        var name: String\n        var color: Color\n        var id: String { name }\n    }\n\n    var name: String\n    var tags: [Tag]\n\n    static let sample = ButtonEntry(name: \"Stroopwafel\", tags: [Tag(name: \"1960s\", color: .purple), Tag(name: \"bronze\", color: .yellow)])\n}"
    },
    {
      "timestamp": "37:25",
      "title": "Confirmation dialogs",
      "language": "swift",
      "code": "struct ContentView: View {\n    var entry: ButtonEntry = .sample\n    @State private var showConfirmation: Bool = false\n\n    var body: some View {\n        ButtonEntryCell(entry)\n            .contextMenu {\n                Section {\n                    Button(\"Open\") {\n                        // ...\n                    }\n                    Button(\"Delete...\", role: .destructive) {\n                        showConfirmation = true\n                        // ...\n                    }\n                }\n\n                Section {\n                    Button(\"Archive\") {}\n\n                    Menu(\"Move to\") {\n                        ForEach(Jar.allJars) { jar in\n                            Button(\"\\(jar.name)\") {\n                                //addTo(jar)\n                            }\n                        }\n                    }\n                }\n            }\n            .confirmationDialog(\n                \"Are you sure you want to delete \\(entry.name)?\",\n                isPresented: $showConfirmation\n            ) {\n                Button(\"Delete\", role: .destructive) {\n                    // delete the entry\n                }\n            } message: {\n                Text(\"Deleting \\(entry.name) will remove it from all of your jars.\")\n            }\n    }\n}\n\nstruct ButtonEntryCell: View {\n    var entry: ButtonEntry = .sample\n    init(_ entry: ButtonEntry) { self.entry = entry }\n\n    var body: some View {\n        Text(entry.name)\n            .padding()\n    }\n}\n\nstruct Jar: Identifiable {\n    var name: String\n    var id: String { name }\n\n    static let allJars = [Jar(name: \"Secret Stash\")]\n}\n\nstruct ButtonEntry {\n    struct Tag: Identifiable {\n        var name: String\n        var color: Color\n        var id: String { name }\n    }\n\n    var name: String\n    var tags: [Tag]\n\n    static let sample = ButtonEntry(name: \"Stroopwafel\", tags: [Tag(name: \"1960s\", color: .purple), Tag(name: \"bronze\", color: .yellow)])\n}"
    },
    {
      "timestamp": "37:59",
      "title": "Menu buttons",
      "language": "swift",
      "code": "struct ContentView: View {\n    var buttonEntry: ButtonEntry = .sample\n    @StateObject private var jarStore = JarStore()\n\n    var body: some View {\n        Menu(\"Add\") {\n           ForEach(jarStore.allJars) { jar in\n              Button(\"Add to \\(jar.name)\") {\n                 jarStore.add(buttonEntry, to: jar)\n              }\n           }\n        }\n        .menuStyle(BorderedButtonMenuStyle())\n        .scenePadding()\n    }\n}\n\nclass JarStore: ObservableObject {\n    var allJars: [Jar] = Jar.allJars\n    func add(_ entry: ButtonEntry, to jar: Jar) {}\n}\n\nstruct Jar: Identifiable {\n    var name: String\n    var id: String { name }\n    static let allJars = [Jar(name: \"Secret Stash\")]\n}\n\nstruct ButtonEntry {\n    var name: String\n    static let sample = ButtonEntry(name: \"Stroopwafel\")\n}"
    },
    {
      "timestamp": "38:10",
      "title": "Menu buttons: hidden indicator",
      "language": "swift",
      "code": "struct ContentView: View {\n    var buttonEntry: ButtonEntry = .sample\n    @StateObject private var jarStore = JarStore()\n\n    var body: some View {\n        Menu(\"Add\") {\n           ForEach(jarStore.allJars) { jar in\n              Button(\"Add to \\(jar.name)\") {\n                 jarStore.add(buttonEntry, to: jar)\n              }\n           }\n        }\n        .menuStyle(BorderedButtonMenuStyle())\n        .menuIndicator(.hidden)\n        .scenePadding()\n    }\n}\n\nclass JarStore: ObservableObject {\n    var allJars: [Jar] = Jar.allJars\n    func add(_ entry: ButtonEntry, to jar: Jar) {}\n}\n\nstruct Jar: Identifiable {\n    var name: String\n    var id: String { name }\n    static let allJars = [Jar(name: \"Secret Stash\")]\n}\n\nstruct ButtonEntry {\n    var name: String\n    static let sample = ButtonEntry(name: \"Stroopwafel\")\n}"
    },
    {
      "timestamp": "38:31",
      "title": "Menu buttons: primary action",
      "language": "swift",
      "code": "struct ContentView: View {\n    var buttonEntry: ButtonEntry = .sample\n    @StateObject private var jarStore = JarStore()\n\n    var body: some View {\n        Menu(\"Add\") {\n           ForEach(jarStore.allJars) { jar in\n              Button(\"Add to \\(jar.name)\") {\n                 jarStore.add(buttonEntry, to: jar)\n              }\n           }\n        } primaryAction: {\n            jarStore.addToDefaultJar(buttonEntry)\n        }\n        .menuStyle(BorderedButtonMenuStyle())\n        .scenePadding()\n    }\n}\n\nclass JarStore: ObservableObject {\n    var allJars: [Jar] = Jar.allJars\n    func add(_ entry: ButtonEntry, to jar: Jar) {}\n    func addToDefaultJar(_ entry: ButtonEntry) {}\n}\n\nstruct Jar: Identifiable {\n    var name: String\n    var id: String { name }\n    static let allJars = [Jar(name: \"Secret Stash\")]\n}\n\n\nstruct ButtonEntry {\n    var name: String\n    static let sample = ButtonEntry(name: \"Stroopwafel\")\n}"
    },
    {
      "timestamp": "38:42",
      "title": "Menu buttons: primary action, indicator hidden",
      "language": "swift",
      "code": "struct ContentView: View {\n    var buttonEntry: ButtonEntry = .sample\n    @StateObject private var jarStore = JarStore()\n\n    var body: some View {\n        Menu(\"Add\") {\n           ForEach(jarStore.allJars) { jar in\n              Button(\"Add to \\(jar.name)\") {\n                 jarStore.add(buttonEntry, to: jar)\n              }\n           }\n        } primaryAction: {\n            jarStore.addToDefaultJar(buttonEntry)\n        }\n        .menuStyle(BorderedButtonMenuStyle())\n        .menuIndicator(.hidden)\n        .scenePadding()\n    }\n}\n\nclass JarStore: ObservableObject {\n    var allJars: [Jar] = Jar.allJars\n    func add(_ entry: ButtonEntry, to jar: Jar) {}\n    func addToDefaultJar(_ entry: ButtonEntry) {}\n}\n\nstruct Jar: Identifiable {\n    var name: String\n    var id: String { name }\n    static let allJars = [Jar(name: \"Secret Stash\")]\n}\n\n\nstruct ButtonEntry {\n    var name: String\n    static let sample = ButtonEntry(name: \"Stroopwafel\")\n}"
    },
    {
      "timestamp": "39:01",
      "title": "Toggle buttons",
      "language": "swift",
      "code": "Toggle(isOn: $showOnlyNew) {\n    Label(\"Show New Buttons\", systemImage: \"sparkles\")\n}\n.toggleStyle(.button)"
    },
    {
      "timestamp": "39:13",
      "title": "Control group",
      "language": "swift",
      "code": "ControlGroup {\n    Button(action: archive) {\n        Label(\"Archive\", systemImage: \"archiveBox\")\n    }\n    Button(action: delete) {\n        Label(\"Delete\", systemName: \"trash\")\n    }\n}"
    },
    {
      "timestamp": "39:26",
      "title": "Control group: back/forward control",
      "language": "swift",
      "code": "struct ContentView: View {\n    @State var current: String = \"More buttons\"\n    @State var history: [String] = [\"Text and keyboard\", \"Advanced graphics\", \"Beyond lists\", \"Better lists\"]\n    @State var forwardHistory: [String] = []\n\n    var body: some View {\n        Color.clear\n            .toolbar{\n                ToolbarItem(placement: .navigation) {\n                    ControlGroup {\n                        Menu {\n                            ForEach(history, id: \\.self) { previousSection in\n                                Button(previousSection) {\n                                    goBack(to: previousSection)\n                                }\n                            }\n                        } label: {\n                            Label(\"Back\", systemImage: \"chevron.backward\")\n                        } primaryAction: {\n                            goBack(to: history[0])\n                        }\n                        .disabled(history.isEmpty)\n\n                        Menu {\n                            ForEach(forwardHistory, id: \\.self) { nextSection in\n                                Button(nextSection) {\n                                    goForward(to: nextSection)\n                                }\n                            }\n                        } label: {\n                            Label(\"Forward\", systemImage: \"chevron.forward\")\n                        } primaryAction: {\n                            goForward(to: forwardHistory[0])\n                        }\n                        .disabled(forwardHistory.isEmpty)\n                    }\n                    .controlGroupStyle(.navigation)\n                }\n            }\n            .navigationTitle(current)\n    }\n\n    private func goBack(to section: String) {\n        guard let index = history.firstIndex(of: section) else { return }\n        forwardHistory.insert(current, at: 0)\n        forwardHistory.insert(contentsOf: history[...history.index(before: index)].reversed(), at: 0)\n        history.removeSubrange(...index)\n        current = section\n    }\n\n    private func goForward(to section: String) {\n        guard let index = forwardHistory.firstIndex(of: section) else { return }\n        history.insert(current, at: 0)\n        history.insert(contentsOf: forwardHistory[...forwardHistory.index(before: index)].reversed(), at: 0)\n        forwardHistory.removeSubrange(...index)\n        current = section\n    }\n}"
    }
  ],
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "Human Interface Guidelines: Designing for iOS",
        "url": "https://developer.apple.com/design/Human-Interface-Guidelines/designing-for-ios"
      },
      {
        "title": "SwiftUI",
        "url": "https://developer.apple.com/documentation/SwiftUI"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2021/10018/4/C1412BB4-40EE-418F-BCFD-09796128093C/downloads/wwdc2021-10018_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2021/10018/4/C1412BB4-40EE-418F-BCFD-09796128093C/downloads/wwdc2021-10018_sd.mp4?dl=1"
  },
  "relatedVideos": [
    {
      "id": "10021",
      "year": "2021",
      "title": "Add rich graphics to your SwiftUI app",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10021"
    },
    {
      "id": "10017",
      "year": "2021",
      "title": "Bring Core Data concurrency to Swift and SwiftUI",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10017"
    },
    {
      "id": "10009",
      "year": "2021",
      "title": "Build a workout app for Apple Watch",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10009"
    },
    {
      "id": "10176",
      "year": "2021",
      "title": "Craft search experiences in SwiftUI",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10176"
    },
    {
      "id": "10022",
      "year": "2021",
      "title": "Demystify SwiftUI",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10022"
    },
    {
      "id": "10023",
      "year": "2021",
      "title": "Direct and reflect focus in SwiftUI",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10023"
    },
    {
      "id": "10019",
      "year": "2021",
      "title": "Discover concurrency in SwiftUI",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10019"
    },
    {
      "id": "10220",
      "year": "2021",
      "title": "Localize your SwiftUI app",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10220"
    },
    {
      "id": "10232",
      "year": "2021",
      "title": "Meet Shortcuts for macOS",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10232"
    },
    {
      "id": "10048",
      "year": "2021",
      "title": "Principles of great widgets",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10048"
    },
    {
      "id": "10349",
      "year": "2021",
      "title": "SF Symbols in SwiftUI",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10349"
    },
    {
      "id": "10194",
      "year": "2021",
      "title": "Swift concurrency: Update a sample app",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10194"
    },
    {
      "id": "10119",
      "year": "2021",
      "title": "SwiftUI Accessibility: Beyond the basics",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10119"
    },
    {
      "id": "10109",
      "year": "2021",
      "title": "What's new in Foundation",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10109"
    },
    {
      "id": "10002",
      "year": "2021",
      "title": "What's new in watchOS 8",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10002"
    },
    {
      "id": "10192",
      "year": "2021",
      "title": "What‘s new in Swift",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10192"
    },
    {
      "id": "10097",
      "year": "2021",
      "title": "What’s new in SF Symbols",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10097"
    }
  ],
  "extractedAt": "2025-07-18T10:27:17.786Z"
}