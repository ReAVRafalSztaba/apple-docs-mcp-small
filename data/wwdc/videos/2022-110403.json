{
  "id": "110403",
  "year": "2022",
  "url": "https://developer.apple.com/videos/play/wwdc2022/110403/",
  "title": "Meet Background Assets",
  "speakers": [],
  "duration": "",
  "topics": [
    "App Services"
  ],
  "hasTranscript": true,
  "hasCode": true,
  "transcript": {
    "fullText": "♪ Mellow instrumental hip-hop music ♪ ♪ Hi! My name is Jared, and I'm a software engineer here at Apple.\n\nToday I'd like to talk you about a new framework we are introducing this year to iOS, iPadOS, and macOS.\n\nThis new framework is called Background Assets, and we believe it will greatly enrich the user experience of the apps that we all know and love, and more importantly, that you develop.\n\nTo get started, I'll be introducing you to the new Background Assets framework.\n\nAfterwards, I'll show you how to adopt the new framework into your app.\n\nThis will be followed by a quick overview of the extension and what new capabilities it provides.\n\nThen we'll finish with some best practices and everything we've learned.\n\nBefore we begin, let's talk about what we're trying to solve here.\n\nThe truth is, waiting is not fun.\n\nAnytime we find ourselves asking those that use our software to wait, we're increasing frustration and taking away from the experience we want our apps to provide.\n\nFor instance, how often have you found yourself browsing endlessly through the App Store looking for that perfect app? You finally find it, and oh does it look so perfect! You then tap that GET button.\n\nWith every moment, your level of excitement increases.\n\nThen you shortly realize that depending on your network connection or the size of the app, you may find yourself having to wait as the app downloads.\n\nThen after a few seconds of waiting, you find yourself putting your phone down, grabbing a cup of coffee, reading your favorite book about the benefits of practicing mindfulness and mastering patience.\n\nThen a few hours pass, and you finally pick up your phone.\n\nYour excitement levels rise as you're ready to dive into the perfect app that you've been waiting to use all day.\n\nJust to launch the app and be immediately greeted with this: more downloading.\n\nIt's confusing.\n\nYou've been away from your phone all day.\n\nWhy is this app now making you wait even longer? Couldn't this app have downloaded this content automatically after the app was installed? For anyone on a slower internet connection, this might frustrate them to close and remove the app.\n\nThe truth is, this is not the experience any of us want to have.\n\nWe know this isn't your fault, and we believe we can make this experience so much better! This is why we're proud to introduce to you this year, Background Assets.\n\nThis framework was developed to help you enrich the user experience of your apps.\n\nSo that the moment your app is launched, it is providing a phenomenal first impression! Background Assets is designed to be flexible with your existing workflows.\n\nA lot of you have already developed complex asset management systems, and we wanted this new framework to easily fit into the solutions that you have already developed.\n\nWe also know that you want to be able to push updated content to your apps without having to require an additional submission to the App Store.\n\nIt's not uncommon for games or other apps to need additional content after the app has already shipped.\n\nThink updated art textures or a bug fix in game-level data.\n\nBackground Assets provides you with the ability to schedule and update your assets outside of your app's lifecycle.\n\nWe believe it's important that assets are present before first app launch, or whenever the app is updated overnight.\n\nSo we've worked to create a mechanism to help ensure that your content is present by the time your app is launched.\n\nAnd finally, the easier a framework is to adopt, the more we can encourage you to use it in your apps.\n\nWe want Background Assets to be used in any place where large assets need to be predownloaded.\n\nThat way, we can minimize the time your app is waiting and showing a progress bar before its content is available.\n\nSo you may be wondering, how is this new framework helping you solve this problem? Well, in order to be as extensible as possible, we've created a new app extension for downloading content in the background.\n\nThis new extension is built on top of the powerful app extension technology that other extensions on our platforms use.\n\nThis provides an opportunity to run code outside of the app's lifecycle.\n\nFor instance, the extension will run whenever the user first installs your app but has yet to launch it.\n\nThe extension will also run whenever the app is updated automatically in the background.\n\nThis helps to ensure that your content can be scheduled and downloaded before the user opens the application after it has been updated.\n\nFinally, the extension will run periodically in the background, allowing you to check for updated assets and schedule them periodically over time.\n\nThough it is important to note, that extension runtime is short-lived, so all work will need to be scheduled by your extension with haste.\n\nIf downloads are not scheduled quickly, the system may terminate the extension.\n\nIt's also important to be aware that the frequency of the extension's ability to run periodically will back off based on app usage.\n\nIf your app isn't being used very much, then the extension will receive less frequent runtime.\n\nSo that's an overview of the new Background Assets framework.\n\nIt provides you with the tools you need to ensure that your assets are available by the time your app is launched.\n\nThis is done with an extension that runs whenever your app is installed or updated, but before the user has launched your app.\n\nNow, let's take a look at adopting the Background Assets framework into your project and getting started! The download manager within the framework is the primary vehicle used to communicate with the Background Assets system service.\n\nThe manager is a singleton object that can be used throughout your app.\n\nUsing the manager, you can schedule the download of your assets in either the foreground or background.\n\nYou can also retrieve downloads that are currently in flight, which might have started before your application was ever launched.\n\nDownloads can also be canceled.\n\nThis is useful if they were already scheduled or are in the middle of being downloaded and you no longer need that asset that you originally requested.\n\nWe've also introduced a synchronization mechanism for managing exclusive access between your app and the extension so that both the extension and application do not end up scheduling or modifying existing downloads at the same time.\n\nI have an example to show you, but for now, more on this later! Let's take a look at just how easy it is to start using Background Assets.\n\nI'm going to begin by walking you through some of the basics of the API.\n\nI'll then follow that up later by showing you how to tie all of this together into an app extension.\n\nTo get started, you'll import the Background Assets framework module.\n\nThen, it's as easy as defining a URL that points to the location of where your remote asset is located.\n\nWe then follow that up by defining an app group container that your extension and app are both members of.\n\nHaving your app and extension in the same group allows them to manage your assets during the download and after completion.\n\nIf you're not already familiar with app groups, you can easily add one from the Signing & Capability section of Xcode 14.\n\nThey're a powerful feature that allows two or more applications to access the same resources, or in this case, your app and its extension.\n\nThe next thing to do is create your download object.\n\nThe Background Assets framework is designed to support multiple different types of download objects.\n\nHowever, in this example, we'll be focusing on the most common one: BAURLDownload.\n\nImmediately, you'll notice that the initializer takes in the URL and the app group identifier.\n\nThis information tells the system both what we're downloading and where the resulting file will end up.\n\nIt also takes an identifier.\n\nYou'll use this identifier to track your download across multiple launches of your app, and within the extension.\n\nThe engine will not allow more than one download to be scheduled with the same identifier.\n\nTherefore, you should make these identifiers unique.\n\nNext, we'll grab a reference to the BADownloaderManager shared object.\n\nThe download manager is your single interface into Background Assets.\n\nIt's what allows you to observe, cancel, and schedule downloads.\n\nWe'll then pass it a weak reference to a delegate that conforms to the BADownloadManagerDelegate protocol.\n\nI'll go more into this protocol shortly, but the most important part to know now is that it receives messages about downloads that have been scheduled.\n\nThe only thing left to do is to ask the download manager to schedule the download.\n\nIf for any reason the download cannot be scheduled, then an error is thrown.\n\nIn addition to scheduling downloads in the background, we also provide API for doing foreground downloads.\n\nRunning in the foreground not only gives you increased priority, but it also enables your download to begin immediately.\n\nThis is similar to using the default session configuration within URLSession.\n\nWe provide this API so that your app can promote any downloads scheduled by your extension in the background to the foreground.\n\nOne thing to keep in mind: performing a foreground download is not available from within the extension; it can only be initiated from the app.\n\nSince extensions never present UI, and the user doesn't notice that they are running, extensions may only schedule downloads in the background.\n\nIf your app would like to promote existing background downloads to the foreground, this can easily be accomplished by fetching the list of currently active downloads from the manager.\n\nThe list that is returned contains all downloads the are currently scheduled, which may include downloads in flight or queued up in the scheduler.\n\nNext, your app can begin the promotion process by calling startForegroundDownload.\n\nIf a download is already in the foreground, calling this method will effectively do nothing.\n\nHowever, if the download was backgrounded, it will first be paused, then resumed in the foreground without requiring any content that was already downloaded up until this point to be redownloaded.\n\nTogether, this provides an effective and simple illustration for how easy it is to use Background Assets to promote downloads scheduled in the background to the foreground.\n\nIt really is as simple as that! The download manager is your primary interface that is used to schedule and monitor background downloads.\n\nAs these download objects are processed by the system, you'll receive messages in your delegate object.\n\nLet's walk through the delegate now.\n\nThe delegate receives messages for all downloads that have been scheduled by either the extension or your app.\n\nIf there are numerous downloads that were scheduled, callbacks will be received for all of them.\n\nThis is where you use the download object's unique identifier to distinguish between them.\n\nYour app will begin to receive callbacks the moment the delegate is established on BADownloadManager.\n\nCallbacks are not enqueued by the system.\n\nIf your app does not handle one of the delegate methods or your delegate is not established, then your extension will wake to process the message.\n\nThis means that you should fully expect your extension to be sent messages if you have not established a delegate onto BADownloadManager within your app.\n\nIf your app is currently in the foreground being presented to the user and its delegate has been established, then callbacks will be sent to your app and the extension will not be woken.\n\nThe extension will only wake if your app does not handle its delegate callback.\n\nIf a download finishes, or fails, and the app does not process this message, then the extension will wake.\n\nKeep in mind, the extension is not woken for all types of callbacks.\n\nOnly callbacks that share common interfaces between BADownloadManagerDelegate and the BADownloaderExtension protocol.\n\nA download succeeding or failing is an example of a common interface between the delegate and the protocol.\n\nAlthough your app extension has its own entry points that cause it to wake, if the extension is currently running, it can use BADownloadManager and establish a delegate.\n\nThis will allow both the app and extension to receive duplicate messages to their delegates.\n\nKeep in mind that extensions do not wake to process delegate messages.\n\nThey only wake at extension entry points defined in the BADownloaderExtension protocol.\n\nLet's take a look at the protocol for the download manager's delegate.\n\nThe first function is for receiving messages whenever a download starts.\n\nThis is useful for tracking when the device has finally chosen to schedule a specific download.\n\nYou may also be notified if a download pauses.\n\nAn example of a pause occurring would be if the extension starts a download in the background and then your app asks us to promote it to the foreground.\n\nDuring this promotion there will be a small window where the download pauses before it is resumed.\n\nThe download manager also allows you to monitor active progress of your download as it is being downloaded in the foreground.\n\nWe also provide a mechanism to answer a challenge request, which is useful for validating the authenticity of a connection or for providing credentials to authorize a connection.\n\nThe most important functions are for dealing with a failed or finished download.\n\nIf a download fails, you may need to reschedule it or determine the cause.\n\nFor a successful download, the system has placed the file in a location that is managed by the operating system.\n\nIf the device ends up low on space, then the system will delete the file for you.\n\nWe strongly recommend that you leave the file at the location that the system has provided.\n\nOnly move the file if you absolutely must and please do not duplicate it unless you delete the originating file afterwards.\n\nAs a reminder, the protocol for the download manager's delegate is for receiving messages related to downloads that your app or extension has scheduled.\n\nIt is not the entry point for your extension, which brings us to our next topic.\n\nNow we'll be taking a look at the most exciting part of Background Assets, the extension! The extension enables you to schedule the downloads of your assets before the user has launched your app.\n\nThis enables you to ensure that your assets are in place and ready to go in order to provide the best possible experience in your app with minimal wait time.\n\nAs discussed earlier, we're introducing a new app extension.\n\nThis extension can be created from within Xcode inside of your existing project.\n\nAs a quick reminder, the extension runs whenever your app is installed or updated.\n\nGiving you the flexibility to make sure changes to your app always has its latest assets.\n\nThe extension also runs periodically based on how often a user uses your app.\n\nIf someone uses your app everyday, then the system learns this behavior and your extension will run more frequently.\n\nHowever, if the app is never launched, then the frequency of this periodic check will subside.\n\nThe new extension also has a short lifecycle and a tight sandbox to ensure that its usage is limited to just downloading assets.\n\nYou are encouraged to make quick decisions in the extension and to limit the extension to the Background Assets framework.\n\nBefore we start navigating through the extension, there are a couple of configurations that you need to make before the extension can launch.\n\nThese changes are also a requirement for your app to be approved for distribution on the App Store.\n\nIn your app's information property list, you'll need to define a couple of additional keys.\n\nThese keys should not be placed in the extension's Info.plist, only the app's.\n\nThe first key is BAInitialDownloadRestrictions.\n\nThis is a dictionary where you will be specifying restrictions that will be placed upon your extension.\n\nThese restrictions are reviewed by App Review, so try to be as accurate as possible.\n\nNow, let's dig into each individual key inside the dictionary.\n\nThe first restriction is the download allowance.\n\nThis is represented in bytes and is the maximum download size you're requesting to make within the extension during an initial app install.\n\nThis size pertains to the sum of all files combined that you are requesting to download, not the size of each individual file.\n\nThe next item is the domain AllowList, which takes an array of domains represented as strings.\n\nThe domain AllowList supports prefix wildcards and takes in a list of host names that your extension is permitted to download from.\n\nIt's important to note that the keys in the BAInitialDownloadRestrictions, such as the DownloadAllowance and AllowList are only enforced after first app install.\n\nWhenever your app is launched, these restrictions are no longer enforced.\n\nThe last required key, which sits at the root of your Info.plist is the maximum size that your app will require in additional storage for these assets.\n\nWe expect that you might want to download compressed assets, so this value should be the final extracted uncompressed size.\n\nThe number that is placed here will be presented on the App Store before the app is downloaded.\n\nNow that we've gone over some housekeeping, let's talk about the entry points into your extension in more detail.\n\nThe functions that you define from the protocol will be called by the system and not by your app.\n\nUnlike other app extensions, where the application is responsible for talking to the extension, the background download extension is brokered by the system.\n\nSince the system is maintaining the lifecycle of the extension, it should be viewed as an ephemeral service.\n\nWhenever any of the functions inside of the protocol are invoked, it's important to keep the work that is done there to a minimum.\n\nThe extension will be terminated rather quickly after it is launched.\n\nThis is not the place to kick off decompression or other complex operations that may take a while.\n\nOne of the great parts of working in the extension is that all of the BackgroundAssets APIs available to your app are also available within the extension.\n\nWith the only exception being the ForegroundDownload API.\n\nThis means that you'll use BADownloadManager just like you would in your app.\n\nAs a matter of fact, it's entirely likely that you'll discover the ability to create something that uses the same code to schedule and manage your assets in both your app and its extension.\n\nAlso, when creating your extension, it's important to ensure that both are in a common app group.\n\nYou'll want to use the same group identifier so that content can be read and written by your app and its extension.\n\nNow let's take a look at the downloader extension protocol that you will be conforming your extension to.\n\nThe first thing you'll notice is how similar it looks to the download manager delegate protocol.\n\nAs I stated earlier, you can use BADownloadManager and construct a delegate from within the extension.\n\nHowever, only these entry points can actually wake the extension.\n\nThe first function is invoked whenever your application is first installed.\n\nThe app hasn't launched yet, but your extension has.\n\nThis is the perfect opportunity to start scheduling downloads that your app needs to provide the best experience once your app has been launched.\n\nIt's also important to recall that during initial app install, download restrictions are in effect.\n\nYou'll want to consult the BADownloadRestrictions key that you defined in your Info.plist to know what your maximum permitted download size and allowed domains are.\n\nThis next function is invoked whenever the App Store updates your app.\n\nAs long as the user hasn't quit your app in the app switcher, your newly updated extension will wake and you can begin scheduling work.\n\nThe checkForUpdates function provides support for your extension being periodically awoken by the system, so that you can check for any updates that need to be background downloaded.\n\nThis function is invoked by the system based on how often a user uses your app.\n\nWe also have support for responding to an authentication challenge request.\n\nSo that you can better restrict and ensure that the files you are downloading have come from a trusted source.\n\nFinally, just like the delegate, you'll be informed if the download failed or succeeded.\n\nYou'll notice that in the backgroundDownloadDidFail function, there is no error returned.\n\nThe error can be retrieved along with its state in a variable inside of the returned BADownload object.\n\nIt's also important to note that the last three functions can be invoked even if your extension isn't what scheduled the download.\n\nIf your app scheduled a download, but hasn’t become backgrounded, then the extension will be expected to service the download.\n\nNow that we understand how to use BADownloaderManager from our app and its extension, we have to start thinking about what it means if both the app and its extension are running simultaneously.\n\nFor instance, let's say the system has decided that it's time to wake the extension to have it periodically check for updates.\n\nAnd of course, since the extension needs to access the network to do this check, it's going to use BADownloaderManager to schedule the download of a catalog or some other type of metadata that provides a list of updated assets that are available.\n\nFor instance, let's say the file is a small 100KB catalog that contains a list of large multi-gigabyte assets that we need to download.\n\nSince the extension needs to know when the download it has scheduled finished, or failed, it's going to attach a delegate onto the download manager.\n\nThe download manager's delegate is used over its extension entry points since its downloading a small file to determine what larger assets it will be scheduling, and extension entry points are not guaranteed to be invoked immediately.\n\nAfter the download has finished, the extension receives this message through its delegate.\n\nYour extension now has access to the catalog file and has to make a choice with what it plans to do with the downloaded file.\n\nYou could imagine that the extension will read the file to determine which of the assets in the catalog need to be downloaded to the device.\n\nThen the extension could schedule background downloads of those larger assets.\n\nNow that the downloaded file is no longer necessary, the extension should delete the file.\n\nWhile this seems appropriate, what happens if your app launches while your extension is running and creates its own BADownloadManager? Well, let's take a look! The app launches and immediately wants to know if it has updated content.\n\nPerhaps a version number is stored in the app group that both consult to determine if their assets are up to date.\n\nSince the app was launched before the newer catalog finished downloading, it's going to fetch the current downloads from the manager and realize that a download of the catalog is currently in flight and wait for it to be finished in its delegate.\n\nBut we have a problem.\n\nBoth the extension and the app will receive a download finished message in their respective delegates that were hooked into the download manager.\n\nThis means we have a data race on the file being downloaded.\n\nBoth the app and extension will try to read and delete the file at the same time; this is not good.\n\nThis means that either your app or extension could try to read the file and it might be missing.\n\nThis means that you will need think about your app and extension in a similar way that you would think about two threads within your app.\n\nLuckily, Background Assets provides a way to synchronize between your app and its extension.\n\nLet's talk about that now! Synchronizing between your app and its extension is extremely simple with Background Assets.\n\nWhat we're currently looking at is the download manager's delegate function for when a download has completed.\n\nA URL is provided that contains a local path to the file that your app or extension has access to.\n\nIn this example, we'll be ensuring mutual exclusion of this file.\n\nNext, we grab a reference to the download manager and use the withExclusiveControl function, which takes a completion handler.\n\nAll code that is executed within the completion handler scope is guaranteed to be mutually exclusive with other calls that require exclusive control.\n\nMeaning if your extension calls withExclusiveControl while you app has not returned from its completion handler, then the extension will wait.\n\nThis applies in the other direction as well.\n\nIf the extension acquires exclusive control first, then the app will wait until the extension is terminated or releases control by exiting scope.\n\nAn important thing to keep in mind is that acquiring exclusive control can fail.\n\nIt is extremely unlikely that this will occur, but in the event it does, your code should handle it.\n\nYou can detect if exclusive control could not be acquired by checking if the error provided by the function is not nil.\n\nFrom this point on, you are guaranteed that your app or extension has exclusive access within its context.\n\nSo based on our earlier example, it is now perfectly valid to read the contents of the file and then clean it up, if you so choose.\n\nJust make sure to be aware that when your other app or extension gets its opportunity to enter exclusive control that it knows that you have already processed the file.\n\nOne way this can be accomplished is by first checking if the file exists or writing to a database or plist.\n\nAs a reminder, the background downloader extension is for collecting and scheduling the downloads of large assets for your app.\n\nIts runtime is short lived, so please keep the work that is done within the extension to a minimum.\n\nYou should also place your extension and app within a shared app group so that both can access files that are downloaded by one another.\n\nAnd finally, the extension is brokered by the system and not your app.\n\nNow that you know how to develop a basic background download extension, you have everything you need to start implementing Background Assets into your app.\n\nNow, let's go over what we've learned.\n\nThe download manager is used to coordinate and schedule downloads between your app and its extension, therefore you should be using the download manager in both places.\n\nYour extension runs even if your app is not in the foreground.\n\nThis can occur during app installation, update, or periodically at an interval determined by the system.\n\nIf your app is launched and content that was being downloaded in the background is now be waited on, please immediately promote those downloads to the foreground.\n\nThe extension can only schedule downloads in the background.\n\nBy having your app promote them to the foreground, ensures that your content will arrive as quickly as possible.\n\nIf you ever find yourself needing exclusive access to the download manager, please use the exclusive control APIs.\n\nThis will ensure that only your app or extension will have runtime within that window.\n\nThis is extremely useful so that you don't have to think about your extension racing your app when accessing its container or managing downloads.\n\nIf there is anything you should take from this presentation, it's that waiting results in a poor app experience.\n\nMinimize waiting by making your app usable while the task you are waiting on is underway.\n\nOne of the ways you can minimize waiting in your app is to adopt the new Background Assets framework along with the underlying background download extension.\n\nThis helps to ensure that your app will have all of its content ready before the app is launched.\n\nMake sure to also check out the documentation, which includes extra information that may not have been incorporated into this presentation; including how to test your extension and to simulate its entry points.\n\nWe're really excited to get to share Background Assets with you, and we value your feedback.\n\nPlease use Feedback Assistant to let us know what is working for you and what you'd like us improve.\n\nThis is a new framework and we have the opportunity to make adjustments during seeding.\n\nWe have some additional sessions that we think you might find interesting and we encourage you to check them out.\n\n\"Accelerating networking with HTTP3\" is a fantastic session that pairs well with Background Assets.\n\nAlso, I encourage you to check out another session: the \"Introducing on demand resources\" presentation covers an alternative to Background Assets where your content is hosted by Apple and files are downloaded at your request.\n\nBoth of these sessions are really engaging and have a lot to offer.\n\nThank you for spending your time with me, and on behalf of everyone at Apple, we hope you have a fantastic WWDC! ♪",
    "segments": []
  },
  "codeExamples": [
    {
      "timestamp": "5:28",
      "title": "Getting started with Background Assets",
      "language": "swift",
      "code": "// Getting started with Background Assets\nimport BackgroundAssets\n\nlet url = URL(string: \"https://cdn.example.com/large-asset.bin\")!\nlet appGroupIdentifier = \"group.WWDC.AssetContainer\"\nlet download = BAURLDownload ( identifier: \"Large-Asset\",\n                               request: URLRequest(url:url),\n                               applicationGroupIdentifier:\n                                appGroupIdentifier )\n\nlet manager = BADownloadManager.shared\nmanager.delegate = self  // BADownloadManagerDelegate protocol\n\n// Schedule download at an opportunistic time determined by the system\ndo {\n    try manager.schedule(download)\n} catch {\n    print(\"Failed to schedule download. \\(error)\")\n}\n\n// or Schedule download in foreground\ndo {\n    try manager.startForegroundDownload(download)\n} catch {\n    print(\"Failed to start foreground download. \\(error)\")\n}\n\n// or Promote downloads to foreground.\ndo {\n    for download in try await manager.fetchCurrentDownloads) {\n       try manager.startForegroundDownload(download)\n    }\n} catch {\n    print(\"Failed to promote downloads to foreground \\(error)\")\n}"
    },
    {
      "timestamp": "10:28",
      "title": "BADownloadManager delegate protocol",
      "language": "swift",
      "code": "// BADownloadManager protocol definition\npublic protocol BADownloadManagerDelegate : NSObjectProtocol {\n    optional func downloadDidBegin(_ download: BADownload)\n\n    optional func downloadDidPause(_ download: BADownload)\n\n    optional func download(_ download: BADownload,\n                           bytesWritten: Int64,\n                           totalBytesWritten: Int64,\n                           totalExpectedBytes: Int64)\n\n    optional func download(_ download: BADownload, didReceive challenge: URLAuthenticationChallenge) async -> (URLSession.AuthChallengeDisposition, URLCredential?)\n\n    optional func download(_ download: BADownload, failedWithError error: Error)\n\n    optional func download(_ download: BADownload, finishedWithFileURL fileURL: URL)\n}"
    },
    {
      "timestamp": "15:37",
      "title": "BADownloaderExtension protocol",
      "language": "swift",
      "code": "// BADownloaderExtension protocol definition\npublic protocol BADownloaderExtension : NSObjectProtocol {\n    optional func applicationDidInstall(metadata: BAApplicationExtensionInfo)\n\n    optional func applicationDidUpdate(metadata: BAApplicationExtensionInfo)\n\n    optional func checkForUpdates(metadata: BAApplicationExtensionInfo)\n\n    optional func download(_ download: BADownload, didReceive challenge: URLAuthenticationChallenge) async -> (URLSession.AuthChallengeDisposition, URLCredential?)\n\n    optional func backgroundDownloadDidFail(failedDownload: BADownload)\n\n    optional func backgroundDownloadDidFinish(finishedDownload: BADownload, fileURL: URL)\n  \n    optional func extensionWillTerminate()\n}"
    },
    {
      "timestamp": "19:40",
      "title": "Synchronizing between app and extension",
      "language": "swift",
      "code": "// Synchronizing between app and extension\nfunc download(_ download: BADownload, finishedWithFileURL fileURL: URL) {\n    let manager = BADownloadManager.shared\n    manager.withExclusiveControl { error in\n        guard error == nil else {\n            print(\"Unable to acquire exclusive control \\(String(describing: error))\")\n            return\n        }\n        // Exclusive control acquired\n        // All code in this scope ensures mutual exclusion between extension and app\n        do {\n            let data = try Data(contentsOf: fileURL, options: .mappedIfSafe)\n            // Do something with memory mapped data\n            try FileManager.default.removeItem(at: fileURL)\n        } catch {\n            print(\"Unable to read/cleanup file data. \\(error)\")\n        }\n    }\n}"
    }
  ],
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "Background Assets",
        "url": "https://developer.apple.com/documentation/BackgroundAssets"
      },
      {
        "title": "NSBundleResourceRequest",
        "url": "https://developer.apple.com/documentation/Foundation/NSBundleResourceRequest"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2022/110403/3/7B38146A-41F4-422B-A863-6E4277C76C6E/downloads/wwdc2022-110403_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2022/110403/3/7B38146A-41F4-422B-A863-6E4277C76C6E/downloads/wwdc2022-110403_sd.mp4?dl=1"
  },
  "relatedVideos": [
    {
      "id": "10108",
      "year": "2023",
      "title": "What’s new in Background Assets",
      "url": "https://developer.apple.com/videos/play/wwdc2023/10108"
    },
    {
      "id": "10094",
      "year": "2021",
      "title": "Accelerate networking with HTTP/3 and QUIC",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10094"
    }
  ],
  "extractedAt": "2025-07-18T09:15:20.622Z"
}