{
  "id": "10046",
  "year": "2022",
  "url": "https://developer.apple.com/videos/play/wwdc2022/10046/",
  "title": "Adopt declarative device management",
  "speakers": [],
  "duration": "",
  "topics": [
    "Business & Education"
  ],
  "hasTranscript": true,
  "hasCode": true,
  "transcript": {
    "fullText": "♪ instrumental hip hop music ♪ ♪ Welcome to the \"Adopt declarative device management\" session.\n\nMy name is Cyrus Daboo, and I am an engineer on the Device Management team.\n\nI am here to tell you about the exciting new features in declarative device management.\n\nAt WWDC21, my colleague Melissa introduced declarative device management, a new paradigm for managing Apple devices, reenvisioning the MDM protocol itself.\n\nAs we learned in that session, declarative device management is powerful because it enables devices to be autonomous and proactive.\n\nThe device is autonomous, as it reacts to its own state changes and then applies management logic to itself, without prompting from the server.\n\nThe device is proactive, with the status channel asynchronously reporting to the server when important state changes occur, avoiding the need for servers to poll devices.\n\nThere are two key elements to the declarative device management data model: declarations and status.\n\nDeclarations encompass activations and predicates, configurations, assets, and management types.\n\nAnd status covers status items and status reporting.\n\nLet's take a moment to talk about why this matters, what it means for you, and the organizations that use your products.\n\nWe have created this technology to support new complex management strategies, enhance the overall user experience of managed devices, alleviate the repetitive and tedious tasks of an IT admin, and empower devices to be the driver in their own management state.\n\nFor you, as a developer of a device management solution, the declarative approach allows your servers to be lightweight and reactive.\n\nAnd with the declarative data model more closely mapping to how organizations are structured, that means changes to devices becomes more intuitive.\n\nStatus reports provide a rich feedback channel, which enable your servers to monitor devices more closely, and present pertinent information in a more timely and reliable fashion, without the need for complex strategies used to implement polling.\n\nAll of this means a simpler development effort, enabling you to focus on the device management features that add value where it matters most, and create a solution your customers will love.\n\nFor IT admins, the declarative approach inspires more confidence that the device is in the expected state.\n\nAnd in the situations where it is not, that it is in a safe state that protects any sensitive organization data, even when connectivity to the server is lost.\n\nIt provides critical feedback from devices via status reports, that also improves efficiency for admins through less utilization of resources such as network bandwidth.\n\nFor the organization's users, device management becomes a more responsive and reliable experience with faster onboarding, quicker recovery times and better support from their organization.\n\nWith all these benefits in mind, know that the focus of future protocol features will be declarative device management, making it even more important for you to adopt declarative device management in your products today.\n\nFor an in-depth introduction to declarative device management and the steps needed to adopt it, make sure you watch the WWDC21 session video.\n\nIn this release, we have three focus areas: expanding the scope of declarative device management, enhancing status reports, and enhancing predicates.\n\nLet's start with expanding the scope of declarative device management.\n\nWhen declarative device management was introduced, it was supported on only iOS with user enrollments.\n\nNow, declarative device management is available for every enrollment type MDM supports: automatic device enrollment, which includes supervised devices; profile-based enrollment; and profile and account-based user enrollments.\n\nDeclarative device management is now also available on Shared iPad.\n\nIn iOS 16, users can now find configurations in the MDM profile details view in the Settings app.\n\nTapping the Configurations row reveals details about the active configurations.\n\nAnd I am also pleased to announce that declarative device management is available on every platform MDM supports.\n\nmacOS Ventura now supports declarative device management, for all MDM enrollment types supported on macOS.\n\ntvOS 16 now supports declarative device management for MDM device enrollment types.\n\nWhere supported by the OS, the same set of declarations and status that are available on iOS are also available on macOS and tvOS.\n\nOn macOS, a Configurations section is present in the MDM profile details view, revealing the active configurations.\n\nThe same goes for tvOS, where a Configurations section is present in the MDM profile details view.\n\nOne last thing to note here: both macOS and Shared iPad devices each have two MDM channels.\n\nThese are the device and user channel.\n\nThe device channel allows management of device level state, whereas the user channel targets management state for specific users.\n\nTo use declarative device management on any channel, it must be enabled separately for that channel.\n\nThat means sending the DeclarativeManagement command on the corresponding channel.\n\nAlso, declarative device management status reports are separately generated for each channel, so they need to be separately monitored as well.\n\nNow on to our second focus area: status reports.\n\nLet's do a quick review of status reports.\n\nDevices can incrementally report status to the server, for subscribed status items.\n\nThe device tracks successful responses from the server to ensure status updates are reliable and not missed in the case of networking or other types of problem.\n\nStatus reporting makes the device proactive.\n\nThere is no need for servers to continuously poll the device to watch for state changes.\n\nIn iOS 15, we introduced a set of status items for device properties, such as model type and operating system version.\n\nFor this release we are expanding status in three areas: passcode state, accounts installed by configurations, and MDM installed apps.\n\nLet's start with passcode status.\n\nIn iOS 15, we introduced a passcode policy configuration.\n\nThere can be some lag between the policy being applied, and the passcode becoming compliant when changed by the user, just as there is with MDM passcode policy profiles.\n\nSo, MDM servers have to poll the device to determine when the passcode becomes compliant.\n\nBut with the new declarative device management passcode status items, there is no need to do that.\n\nWe have added two status items: Passcode.is-compliant and passcode.is-present.\n\nCompliance indicates if the passcode is compliant with all passcode policies applied via MDM profiles or configurations.\n\nThese status items have Boolean values that mirror the equivalent properties that can be retrieved via MDM queries.\n\nLet's explore a typical server behavior.\n\nOften, an organization has security sensitive state to apply to a device.\n\nFor example, VPN or Wi-Fi profiles to allow access to protected networks.\n\nThat state should only be active on a device, when a strong passcode policy is present, and the passcode is compliant with that policy.\n\nWith traditional MDM, a server has to send a passcode policy profile then poll the device, to wait for the passcode to become compliant when the user changes it.\n\nInitially the passcode is likely not compliant, so the Wi-Fi profile cannot be sent.\n\nEventually, the user changes the passcode to bring it into compliance.\n\nOn the server's next poll, it detects the changed compliant state and determines it is OK to send the Wi-Fi profile, which then gets installed on the device.\n\nDeclarative device management removes the need for the server to poll by using an activation predicate that is triggered by the passcode compliance state.\n\nThe server sends both the passcode policy and the Wi-Fi profile as configurations, with the Wi-Fi configuration tied to an activation predicated on the passcode compliance.\n\nThe passcode configuration is immediately activated and applies a strong passcode policy.\n\nInitially, the passcode is likely not compliant, so the activation predicate evaluates to false, and the Wi-Fi configuration is not activated.\n\nAt some point, the user updates the passcode to be compliant.\n\nThis triggers reevaluation of the activations and the predicate now evaluates to true, resulting in the Wi-Fi configuration being activated.\n\nAll this happens without any intervention from the server, and in fact can happen without any connection to the server being present.\n\nThe server does automatically get a status report from the device when the configuration activates, so it knows when the change takes place.\n\nThis illustrates how we have successfully moved business logic from the server to the device, to avoid the need to poll and get a more responsive and reliable device behavior.\n\nNow, let's turn to account status.\n\nIn iOS 15, we introduced account configurations to install accounts of various types on a device.\n\nThese are typically organization accounts, giving the user access to organization data.\n\nIt is useful for the admin to know when accounts have been successfully installed, and what state they are in, to help support users who might be having problems.\n\nThis release adds eight account status items for mail, calendar, and other account types.\n\nNote, that status is only reported for accounts installed by configurations and won't include accounts created manually or installed via MDM profiles.\n\nEach new status item corresponds to an account configuration type, with status for incoming and outgoing mail accounts reported separately.\n\nThe new status items each use a different type of JSON object, to represent the status of the corresponding account type.\n\nHere are examples of an incoming mail status item, and a subscribed calendar status item.\n\nThe value of the identifier key is a unique identifier for an object within the array of status item objects -- more on this in a minute.\n\nThe value of the declaration identifier key, matches the identifier property value of the configuration that installed the account, making it easy to cross-reference the status item object and its associated configuration.\n\nThese two keys are always present in all types of account status item object.\n\nThe other keys are specific to the type of account.\n\nFor example, hostname and port for the mail server, or calendar-URL for the subscribed calendar.\n\nThis release introduces status items whose value is an array, to support reporting on one or more accounts of the same type.\n\nSuch array values have special behavior.\n\nEach item in the array is a JSON object with the same schema used for all objects in a single array.\n\nEach object type always has an identifier key, acting as the primary key for locating objects within the array.\n\nOther keys are present and tied to the underlying type of status being reported.\n\nTo ensure forwards compatibility with any keys added in future OS releases, your server must accept unknown keys in array objects.\n\nChanges to an array value are always reported incrementally to the server on a per-object basis, for performance reasons.\n\nLet's run through an example that shows how this new feature works.\n\nIn this example, the server sends two mail account configurations to the device.\n\nThese are both active resulting in two mail accounts present on the device.\n\nThe server now sends a status subscription for the mail account status item.\n\nWhen the subscription is activated, status for the accounts is collected, and the device sends a status report to the server.\n\nThe status report will include the two account status objects in the status array, giving the server a complete picture of what is currently present on the device.\n\nEach array object has a different identifier.\n\nAfter processing this report, the server has status for two mail accounts, matching what is on the device.\n\nWhen the server adds a mail account on the device by sending a new configuration, the status item on the device has a new object added to its array value, and another status report is sent to the server.\n\nOnly the new item is reported.\n\nThe value of the identifier key does not match any the server already has, so the server can infer this corresponds to a new account.\n\nAfter processing this report, the server has status for three mail accounts, the two initial ones and the new one, again matching exactly what is on the device.\n\nWhen account status changes, such as when a user toggles the mail or notes enabled state, the status item on the device will have an updated object in its array value, and again, a status report is sent to the server.\n\nOnly the changed item is reported.\n\nIn this case, the user turned off the notes feature for the account.\n\nThe value of the identifier key matches one the server already has, so the server can infer that this is an update to an existing account.\n\nConsequently, it replaces the existing status item array object with the new one.\n\nAfter processing this report, the server has status for three mail accounts, but one has changed.\n\nWhen an account configuration is removed from the device, the status item on the device has the corresponding object marked for removal, and another status report is sent to the server.\n\nOnly the removed item is reported.\n\nTo indicate removal, the array item object contains only two keys: the identifier key -- whose value matches one the server already has -- and the removed key, set to the value true.\n\nThis allows the server to update its representation of the device state by removing the existing item.\n\nAfter processing this report, the server has status for only two mail accounts, correctly matching the state of the device.\n\nOne last point about status reports.\n\nThe device will limit the rate at which status reports are sent to avoid performance issues.\n\nThe device aggregates changes to status items over a variable interval of up to one minute before sending a status report to the server.\n\nThis means status is reported quickly, but it is not immediate.\n\nNext, let's turn our attention to solving a perennial MDM-bottleneck problem: monitoring application install status.\n\nMDM servers often install apps on devices to give users access to the tools needed for their work or education.\n\nServer-side logic is often dictated by whether an app is installed successfully or not.\n\nSo MDM servers need to monitor app installation progress and watch for the possibility of users removing managed apps on their device.\n\nCurrently, MDM servers can use the InstalledApplicationList or ManagedApplicationList commands to poll the device to observe app installation progress.\n\nWe can avoid polling by having the device proactively send app install progress to the server.\n\nAnd the tool to do that is declarative device management status reports.\n\nThis release adds an mdm.app status item.\n\nIts value is an array of objects that each represent an app that has been installed by the MDM server.\n\nSince this value is an array, it is reported incrementally, using the procedure described earlier.\n\nNote that only apps installed by MDM are reported here, even on supervised devices.\n\nThis status report includes a status item for an app that has finished installing.\n\nThe identifier key is the unique identifier for the array item object, and in this case, is the app's bundle identifier.\n\nThe name key indicates the name of the app.\n\nThe three version keys provide normal, short, and external version identifiers.\n\nAnd the state key is an enumeration that indicates the current install phase for the app.\n\nThe values of these keys correspond to the equivalent items in the MDM ManagedApplicationList command response.\n\nWith all this information, the server can immediately identify which app is being reported and what its state is.\n\nLet's examine an example of the flow of data as an app installs.\n\nOn the right side, we have an iOS 16 device that is being managed by an MDM server.\n\nThe server has already enabled declarative device management and sent a status subscription for the MDM-installed app status item.\n\nThe next step for the server is to install an app using the MDM InstallApplication command.\n\nSince this is a user enrollment, user approval is needed to install the app, so a prompt appears when the device processes the app install command.\n\nAt this point, the installation progress is paused, waiting for user input.\n\nThe device will send a status report to the server, and that will contain a single MDM-installed app status object, with the bundle ID of the app and the state set to prompting.\n\nAt some point, the user taps the Install button, and the app install starts on the device.\n\nAs the install proceeds, another status report will be sent, this time with the app state set to installing; indicating the app is being downloaded and installed.\n\nEventually, the app completes installation and is ready for use.\n\nAt that point, another status report will be sent with the app state set to managed, indicating the app is properly installed and managed.\n\nNow, let's say the user manually deletes the app on the device.\n\nAgain, a status report will be sent, this time with the app state set to managed-but-uninstalled.\n\nThis indicates the app is no longer installed, but its management state is still being tracked on the device.\n\nLet's assume the server wants to remove the app-management state.\n\nIt does that by sending a RemoveApplication command to the device.\n\nThat removes the internally maintained management state, and if the app were still present, it would be removed too.\n\nAnother status report will be sent with the app object marked as removed from the app status array.\n\nThis illustrates the power of the new MDM status item to help improve the responsiveness and reliability of app installs, and it only takes a few steps to implement.\n\nNow, let's examine our third focus area: predicates.\n\nLet's quickly review activation predicates.\n\nActivations can include an optional predicate that determines whether the configurations referenced in the activation will be applied to the device.\n\nPredicates can reference status items to allow the values of those status items to be tested.\n\nWhen a status item referenced in a predicate changes, the device will reprocess all of the activations, reevaluating any predicates.\n\nPredicates are specified as a string using the NSPredicate syntax documented on the Apple Developer site.\n\nTo support more complex predicate expressions, we have extended the predicate syntax to make it easier to detect status items in the expression.\n\nThe new syntax places the status item name inside an @status term in the predicate string.\n\nIn the example, the serial number status item appears in the predicate expression, using the new syntax.\n\nThe previous syntax will continue to work for backwards compatibility, however, it is now deprecated, so please switch to the new one.\n\nLet's examine how predicates can be used with status item array values.\n\nAs we just described, we now have status item values that are arrays for the accounts and MDM-installed app status items.\n\nIt is useful to be able to predicate an activation on an item in the array.\n\nFor example, we might want an activation to be triggered when an app with a particular bundle identifier is installed and managed on the device.\n\nNSPredicate has a SUBQUERY term that can be used to operate on arrays.\n\nThis NSPredicate expression uses a SUBQUERY targeting the MDM-installed app status item.\n\nThe status item is used as the first argument to the SUBQUERY.\n\nThe second argument defines a variable that will refer to each element of the array.\n\nThe third argument is a predicate expression that tests each element identified by that variable.\n\nThe SUBQUERY expression returns an array of elements that match the predicate in the third argument.\n\nThe @count operator then returns the length of that array, and the length is checked to determine if there is one resulting match.\n\nWhen the specified app is installed and managed, this SUBQUERY expression will return an array with a single element, and the predicate will evaluate to true.\n\nWhen the app is not installed, the SUBQUERY expression will return an empty array, and the predicate will evaluate to false.\n\nNote that in order to reference the keys in the status item array object, the @key extension term must be used to ensure the key paths are properly processed.\n\nThe new predicate syntax is extensible, and we will now discuss how it can be used to add predicate terms for a new type of data.\n\nServers need to be able to more directly control the evaluation of predicates, so that complex server-side logic can translate into simple state changes on the device, without the need to synchronize large sets of configurations to trigger those changes.\n\nAn example of this might be an organization that has users with multiple roles and wants efficient, just-in-time assignment of devices as they are handed out to users, or organizations that need to quickly distribute replacement devices, or quickly put devices into a safe mode to protect organization data.\n\nTo support this, I am pleased to say we are adding a new declaration to allow servers to set arbitrary properties on the device, that can be directly used in activation predicates.\n\nThis is the new management properties declaration.\n\nThe declaration consists of a JSON object whose key names are defined by the server.\n\nThe JSON object values can be any JSON value type, including arrays or objects.\n\nThe management properties declaration here, includes three properties: the name and age properties that have a string and integer value, and the roles property that is an array of strings.\n\nThis is an activation with a predicate that references some management properties.\n\nFirst, it tests the age property to determine if its integer value is greater than or equal to 18, then it tests the roles property to determine if the string Grade12 is in the property array value.\n\nEach property is referenced using the @property extension term, with the property key name inside the term.\n\nMultiple management properties declarations can be sent to the device, but the keys should be unique across all of them.\n\nIf there are duplicate keys, one of the values will be arbitrarily chosen when the property is referenced in a predicate, leading to unpredictable results.\n\nSo please avoid using duplicate key names.\n\nLet's explore an example use case.\n\nThis example involves a school.\n\nAnd of course, the school has a set of teachers.\n\nThe school has two divisions: Upper and Lower.\n\nEach division has its own campus with its own Wi-Fi network.\n\nSome teachers function as an IT Admin and require access to a shared mail account.\n\nSome teachers also function as a sports coach and should have a subscribed calendar for all the team game schedules.\n\nThere are thus four different roles that a teacher may have, and sometimes they have multiple roles.\n\nEach role has a set of configurations that must be applied to devices based on the roles of the teacher assigned to the device.\n\nLet's consider two teachers in our example.\n\nTeacher one teaches in Lower school and is also a sports coach.\n\nTeacher two teaches in Upper school and is also an IT admin.\n\nHow might such a use case be handled by a traditional MDM server? Typically, the server has to wait for a device to be assigned to a teacher before it can fully configure that device.\n\nThe server has to determine what roles the teacher has.\n\nIt then determines what profiles are linked to each role.\n\nIt then has to install each profile on the device one at a time.\n\nIf a teacher changes roles, the server has to add or remove profiles to match the new roles.\n\nThis is time-consuming and can introduce significant bottlenecks to a device-management system particularly at peak times, which in our case would be the first day of school when assignments are done.\n\nWith the new management properties declaration, we have a more efficient alternative to this.\n\nThis involves preloading a full set of declarations on the device ahead of time.\n\nConfigurations are assigned to activations, with predicates that are triggered for different roles via management properties.\n\nWhen a device is assigned to a teacher, the server sends only a management properties declaration with the teacher's roles, which triggers activation of the configurations for those roles.\n\nThis method minimizes the overall server and network traffic and reduces the complexity of making rapid changes to device state.\n\nLet's go back to our school example.\n\nThe server will preload the following sets of declarations: two activation/configuration pairs that set up the Wi-Fi network for each division.\n\nThen, we have an activation/configuration pair for the IT admin role, that installs a mail account.\n\nFinally, we have an activation and configuration that installs a subscribed calendar.\n\nEach activation has a predicate that tests the division or function's name using the roles management property.\n\nWhen initially loaded on an unassigned device, all the predicates evaluate to false, so nothing is applied.\n\nNow, let's examine what happens on the day of assignment.\n\nAll the server needs to do is create management properties declarations customized to each teacher.\n\nTeacher one has a roles property that lists Lower and Sports.\n\nTeacher two has a roles property that lists Upper and IT Admin.\n\nWhen these declarations are separately sent to each assigned device, the preloaded activations will all be reevaluated.\n\nSo teacher one's device has the configurations for Lower and Sports roles activated.\n\nAnd teacher two's device has the configurations for the Upper and IT Admin roles activated.\n\nOnly a single declaration is needed to trigger the application of many configurations.\n\nFinally, let's examine what happens when a teacher changes roles.\n\nIn this case, teacher two has become a sports coach in addition to their existing roles.\n\nThe management properties declaration for the teacher's assigned device is now updated to include the additional role name.\n\nWhen that declaration is updated on the device, all the activations are reevaluated.\n\nIn this case, the subscribed calendar configuration for the new Sports role will be applied.\n\nAgain, only a single declaration change is needed as a trigger.\n\nThis illustrates how the management properties declaration provides a powerful way to quickly and easily switch between sets of configurations on a device, so that complex server-side logic can translate into simple state changes on the device.\n\nNow, let's wrap up.\n\nWe have extended the scope of declarative device management on iOS 16, tvOS 16, and macOS Ventura, as well as making it available for all applicable types of MDM enrollment, including Shared iPad.\n\nThis provides full support for declarative device management across all Apple devices that support MDM.\n\nWe have added new status items for passcode, accounts, and MDM-installed apps.\n\nThe MDM-installed app status provides a great solution for one of MDM's key bottlenecks.\n\nFinally, we have enhanced the predicate syntax to make it more extensible and easy to use and added the new management properties declaration that gives servers even more opportunity to move complex business logic to the device.\n\nNow is the time to add declarative device management to your products.\n\nAnd we're excited to learn what you'll do to reimagine device management solutions using declarative device management! As always, your feedback is greatly appreciated.\n\nThank you and enjoy the rest of WWDC.\n\n♪ ♪",
    "segments": []
  },
  "codeExamples": [
    {
      "timestamp": "7:41",
      "title": "Passcode status items",
      "language": "swift",
      "code": "{\n  \"management\": {\n    \"client-capabilities\": {\n     \"supported-payloads\": {\n       \"status-items\": [\n          ...\n          \"passcode.is-compliant\",\n          \"passcode.is-present\",\n          ...\n        ]\n      }\n    }\n  }\n}"
    },
    {
      "timestamp": "10:52",
      "title": "Account status items",
      "language": "swift",
      "code": "{\n  ...\n      \"status-items\": [\n          ...\n          \"account.list.caldav\",\n          \"account.list.carddav\",\n          \"account.list.exchange\",\n          \"account.list.google\",\n          \"account.list.ldap\",\n          \"account.list.mail.incoming\",\n          \"account.list.mail.outgoing\",\n          \"account.list.subscribed-calendar\",\n          ...\n        ]\n  ...\n}"
    },
    {
      "timestamp": "11:19",
      "title": "Mail and subscribed calendar status item objects",
      "language": "swift",
      "code": "{\n  \"identifier\": \"592D763E-C15B-44F8-A1FC-F88EB1901646\",\n  \"declaration-identifier\": \"BF8FD199-467B-4BA5-886D-D82B7849E517\",\n  \"hostname\": \"mail.example.com\",\n  \"port\": 443,\n  \"username\": \"user01\",\n  \"is-mail-enabled\": true,\n  \"are-notes-enabled\": false\n}\n\n{\n  \"identifier\": \"592D763E-C15B-44F8-A1FC-F88EB1901646\",\n  \"declaration-identifier\": \"BF8FD199-467B-4BA5-886D-D82B7849E517\",\n  \"calendar-url\": \"https://holidays.example.com/country/US.ics\",\n  \"username\": \"user01\",\n  \"is-enabled\": true\n}"
    },
    {
      "timestamp": "17:13",
      "title": "MDM app status item",
      "language": "swift",
      "code": "{\n  \"management\": {\n    \"client-capabilities\": {\n     \"supported-payloads\": {\n       \"status-items\": [\n          ...\n          \"mdm.app\",\n          ...\n        ]\n      }\n    }\n  }\n}"
    },
    {
      "timestamp": "17:35",
      "title": "Status report with MDM app status item",
      "language": "swift",
      "code": "{\n  \"StatusItems\": {\n    \"mdm\": {\n      \"app\": [\n        {\n          \"identifier\": \"com.apple.Pages\",\n          \"name\": \"Pages\",\n          \"version\": \"7358.0.134\",\n          \"short-version\": “12.0\",\n          \"external-version-id\": \"844362702\",\n          \"state\": \"managed\"\n        }\n      ]\n    }\n  },\n  \"Errors\": []\n}"
    },
    {
      "timestamp": "22:15",
      "title": "Predicate subquery using the MDM app status item",
      "language": "swift",
      "code": "SUBQUERY(@status(mdm.app),\n         $app,\n         ($app.@key(identifier) == \"com.example.app\") AND ($app.@key(state) == \"managed\")\n        ).@count == 1"
    },
    {
      "timestamp": "24:10",
      "title": "Management properties declaration",
      "language": "swift",
      "code": "{\n  \"management\": {\n    \"client-capabilities\": {\n     \"supported-payloads\": {\n       \"declarations\": {\n         ...\n         \"management\": [\n          ...\n          \"com.apple.management.properties\",\n          ...\n         ]\n         ...\n        }\n      }\n    }\n  }\n}"
    },
    {
      "timestamp": "24:40",
      "title": "Management properties declaration object",
      "language": "swift",
      "code": "{\n  \"Type\": \"com.apple.management.properties\",\n  \"Identifier\": \"AAE09D73-6EF6-4F3B-9E15-11B0F86D5591\",\n  \"ServerToken\": \"AB4C5B91-3E08-4D4E-A9FF-1E44FE5BFDD4\",\n  \"Payload\": {\n    \"name\": \"Student One\",\n    \"age\": 7,\n    \"roles\": [\"grade1\", \"spanish\"]\n  }\n}"
    },
    {
      "timestamp": "24:53",
      "title": "Activation with management properties predicate",
      "language": "swift",
      "code": "{\n  \"Type\": \"com.apple.activation.simple\",\n  \"Identifier\": \"076F928B-9D8E-4BA2-AD34-5655805C82D7\",\n  \"ServerToken\": \"4FFA91BF-85AE-4053-B8FE-B1C3E507A9CB\",\n  \"Payload\": {\n    \"StandardConfigurations\": [\n      \"3BBB4407-238A-44B1-ABB1-5E7AB95160E0\"\n    ]\n  },\n  \"Predicate\": \"(@property(age) >= 18) AND (\"Grade12\" IN @property(roles))\"\n}"
    }
  ],
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "Device Management",
        "url": "https://developer.apple.com/documentation/DeviceManagement"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2022/10046/3/776B5FA8-B8C0-46DA-9EDE-7A0BE5F03772/downloads/wwdc2022-10046_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2022/10046/3/776B5FA8-B8C0-46DA-9EDE-7A0BE5F03772/downloads/wwdc2022-10046_sd.mp4?dl=1"
  },
  "relatedVideos": [
    {
      "id": "10041",
      "year": "2023",
      "title": "Explore advances in declarative device management",
      "url": "https://developer.apple.com/videos/play/wwdc2023/10041"
    },
    {
      "id": "10045",
      "year": "2022",
      "title": "What's new in managing Apple devices",
      "url": "https://developer.apple.com/videos/play/wwdc2022/10045"
    },
    {
      "id": "10131",
      "year": "2021",
      "title": "Meet declarative device management",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10131"
    }
  ],
  "extractedAt": "2025-07-18T09:27:01.347Z"
}