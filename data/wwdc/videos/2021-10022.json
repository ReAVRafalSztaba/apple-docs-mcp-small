{
  "id": "10022",
  "year": "2021",
  "url": "https://developer.apple.com/videos/play/wwdc2021/10022/",
  "title": "Demystify SwiftUI",
  "speakers": [],
  "duration": "",
  "topics": [
    "SwiftUI & UI Frameworks"
  ],
  "hasTranscript": true,
  "hasCode": false,
  "transcript": {
    "fullText": "♪ Bass music playing ♪  ♪ Matt Ricketson: Hi, I'm Matt, and later on I'll be joined by Luca and Raj.\n\nToday, we're going to demystify SwiftUI.\n\nNow, we've heard it many times before that SwiftUI is a declarative UI framework.\n\nThat means that you describe what you want for your app at a high level, and SwiftUI decides exactly how to make it happen.\n\nNow, most of the time, this works great! And that's when SwiftUI feels magical.\n\nBut there will always be those moments when SwiftUI does something that you might not expect.\n\nAnd in those moments, it helps to understand a bit more about what SwiftUI is doing behind the scenes to build a better intuition for how to get the results you're looking for.\n\nSo today's question is, When SwiftUI looks at your code, what does it see? The answer is three things: identity, lifetime, and dependencies.\n\nIdentity is how SwiftUI recognizes elements as the same or distinct across multiple updates of your app.\n\nLifetime is how SwiftUI tracks the existence of views and data over time.\n\nAnd dependencies are how SwiftUI understands when your interface needs to be updated and why.\n\nTogether, these three concepts inform how SwiftUI decides what needs to change, how, and when, resulting in the dynamic user interface you see onscreen.\n\nToday, we'll talk about each of these three concepts in more depth.\n\nLet's start with identity, and I have a few friends here to help me.\n\nThese Ruby Spaniels are adorable, but they're also the subject of a deep philosophical question.\n\nAre these two different dogs? Or are these, in fact, two pictures of the same dog? The truth is, it's impossible to say! We just don't have enough information.\n\nBut this question of whether things are the same or different is at the heart of what we call \"identity.\" Identity isn't just important for dogs though.\n\nIt's also a critical aspect of how SwiftUI understands your app.\n\nLet's look at an example.\n\nThis is an app I made called \"Good Dog, Bad Dog,\" which helps me keep track of whether my furry friend has been on her best behavior.\n\nIt's pretty simple.\n\nI can just tap anywhere on the screen to flip between the good and bad states.\n\nSo what does identity have to do with my app? Well, it's actually very similar to that philosophical question we just asked about the dogs.\n\nLooking at those icons, do those seem like two different views, completely distinct from each other? Or could they be the same view, just in a different place and with a different color? That distinction actually matters a great deal because it changes how our interface transitions from one state to another.\n\nLet's say those icons are, in fact, different views.\n\nThat means the icons should transition independently, such as fading in and out.\n\nBut what if they're, in fact, the same view? That would instead imply that the view should slide across the screen during the transition because it's the same view moving from one location to the other.\n\nSo connecting views across different states is important, because that's how SwiftUI understands how to transition between them.\n\nThis is the key concept behind view identity.\n\nViews that share the same identity represent different states of the same conceptual UI element.\n\nIn contrast, views that represent distinct UI elements will always have different identities.\n\nLater in the talk, Luca and Raj will talk about the practical impacts of view identity on your app's data and update cycle.\n\nFor now, let's look at how identity is represented in your code, focusing on the two different types of identity used by SwiftUI.\n\nFirst, explicit identity: using custom or data-driven identifiers.\n\nAnd second, structural identity: distinguishing views by their type and position in the view hierarchy.\n\nNow, to help understand these concepts, let me introduce you to some more of my friends.\n\nOK, remember that it can be difficult to tell dogs apart, especially when they look the same.\n\nSo what kind of extra information would help us identify our dogs? One way would be to simply ask for their names.\n\nIf two dogs look the same and also share the same name, then I'd say it's pretty likely that they're, in fact, the same dog.\n\nBut if they have different names, then we can guarantee that they are, in fact, different dogs.\n\nAssigning names or identifiers like this is a form of explicit identity.\n\nExplicit identity is powerful and flexible, but does require that someone, somewhere keeps track of all those names.\n\nOne form of explicit identity you may already be used to is pointer identity, which is used throughout UIKit and AppKit.\n\nNow, SwiftUI doesn't use pointer identity, but learning about it will help you better understand how and why SwiftUI works differently.\n\nLet's take a quick look.\n\nConsider a UIKit or AppKit view hierarchy, like this one.\n\nSince UIViews and NSViews are classes, they each have a unique pointer to their memory allocation.\n\nThe pointer is a natural source of explicit identity.\n\nWe can refer to individual views just using their pointer, and if two views share the same pointer, we can guarantee that they are really the same view.\n\nBut SwiftUI doesn't use pointers because SwiftUI views are value types, commonly represented as structs instead of classes.\n\nIn the \"SwiftUI essentials\" talk from 2019, we discussed why SwiftUI uses value types instead of classes for its views, so I recommend watching that talk to learn more.\n\nFor now, the important thing to know is that value types do not have a canonical reference that SwiftUI can use as a persistent identity for its views.\n\nInstead, SwiftUI relies on other forms of explicit identity.\n\nFor example, consider this list of rescue dogs.\n\nThe id parameter used here is a form of explicit identity.\n\nThe dog tag ID of each rescue dog is used to explicitly identify its corresponding view in the list.\n\nIf the collection of rescue dogs changes, SwiftUI can use those IDs to understand what exactly changed and generate the correct animations within the list.\n\nIn this case, SwiftUI was even able to correctly animate views moving between different sections.\n\nLet's look at a more advanced example.\n\nHere, we're using a ScrollViewReader to jump to the top of the view using a button at the bottom.\n\nThe id(_:) modifier provides a way to explicitly identify a view using a custom identifier -- in this case, our header view at the top of the page.\n\nThen we can pass that identifier to the scroll view proxy's scrollTo(_:) method to tell SwiftUI to go to that specific view.\n\nWhat's great about this is that we don't have to explicitly identify every view, just the ones we need to refer to elsewhere in the code, like our header text.\n\nBy comparison, the ScrollViewReader, ScrollView, backstory Text, and Bbutton do not need explicit identifiers.\n\nBut just because their identity isn't explicit, that doesn't mean these views have no identity at all because every view has an identity, even if it's not explicit.\n\nThis is where structural identity comes in.\n\nSwiftUI uses the structure of your view hierarchy to generate implicit identities for your views so you don't have to.\n\nNow, let me bring in some more of my friends to help explain what I mean by that.\n\nLet's say we have two similar dogs but we don't know their names, but we still need to identify each one.\n\nWell, suppose these are very good dogs and they're capable of sitting very still.\n\nIf we can guarantee they don't move, we could identify them just based on where they're sitting, like \"The dog on the left\" or \"The dog on the right\".\n\nWe're using the relative arrangement of our subjects to distinguish them from each other -- that's structural identity.\n\nSwiftUI leverages structural identity throughout its API, and a classic example is when you use if statements and other conditional logic within your View code.\n\nThe structure of the conditional statement gives us a clear way to identify each view.\n\nThe first view only shows when the condition is true, while the second view only shows when the condition is false.\n\nThat means we can always tell which view is which, even if they happen to look similarly.\n\nHowever, this only works if SwiftUI can statically guarantee that these views stay where they are and never swap places.\n\nSwiftUI accomplishes this by looking at the type structure of your view hierarchy.\n\nWhen SwiftUI looks at your views, it sees their generic types -- in this case, our if statement translated into a _ConditionalContent view, which is generic over its true and false content.\n\nThis translation is powered by a ViewBuilder, which is a type of result builder in Swift.\n\nThe View protocol implicitly wraps its body property in a ViewBuilder, which constructs a single generic view from the logic statements in our property.\n\nThe some View return type of our body property is a placeholder that represents this static composite type, hiding it away so it doesn't clutter up our code.\n\nUsing this generic type, SwiftUI can guarantee that the true view will always be the AdoptionDirectory, while the False view will always be the DogList, allowing them to be assigned an implicit, stable identity behind the scenes.\n\nIn fact, this is the key to understanding the Good Dog, Bad Dog app from earlier.\n\nWith the code on the top, we have an if statement that defines different views for each conditional branch.\n\nThis will cause the views to transition in and out because SwiftUI understands that each branch of the if statement represents a different view with a distinct identity.\n\nAlternatively, we could just have a single PawView that changes its layout and color.\n\nWhen it transitions to a different state, the view will smoothly slide to its next position.\n\nThat's because we're modifying a single view with a consistent identity.\n\nBoth of these strategies can work, but SwiftUI generally recommends the second approach.\n\nBy default, try to preserve identity and provide more fluid transitions.\n\nThis also helps preserve your view's lifetime and state, which Luca will talk about in more detail later on.\n\nNow that we understand structural identity, we need to talk about its evil nemesis, AnyView.\n\nTo understand the impact of using AnyView, let's look at the effect that it has on the structure of your views.\n\nEarlier we wrote this if statement to switch between the AdoptionDirectory and the DogList.\n\nWhen SwiftUI looks at this code, it sees the generic type structure on the right.\n\nNow let's look at a different example, one that uses AnyView extensively.\n\nThis is a helper function I've written to get a view that represents a dog's breed.\n\nEach conditional branch in the function returns a different kind of view, so I've wrapped them all in AnyViews because Swift requires a single return type for the whole function.\n\nUnfortunately, this also means that SwiftUI can't see the conditional structure of my code.\n\nInstead, it just sees an AnyView as a return type of the function.\n\nThis is because AnyView is what's called a \"type-erasing wrapper type\" -- it hides the type of the view it is wrapping from its generic signature.\n\nBut perhaps more importantly, this code is also just really hard to read for us mere humans.\n\nLet's see if we can simplify this code and also make more of its structure visible to SwiftUI.\n\nFirst, it looks like this branch is conditionally adding a SheepView alongside our BorderCollieView if there are sheep nearby.\n\nWe can simplify this by conditionally adding the view inside the HStack rather than conditionally adding the HStack around our views.\n\nWith that change, it's now easy to see that we're just returning a single view from each branch, so our local dogView variable isn't necessary.\n\nInstead, we can replace it with return statements inside of each branch.\n\nAs we saw earlier, normal SwiftUI View code can use if statements that return different types of views.\n\nBut if we just try deleting the return statements and AnyViews from our code, we see some errors and warnings appear.\n\nThis is because SwiftUI requires a single return type from our helper function.\n\nSo how can we avoid these errors? Recall that the body property of a view is special, because the View protocol implicitly wraps it in a ViewBuilder.\n\nThis translates the logic in the property into a single, generic view structure.\n\nNow, Swift does not infer helper functions to be view builders by default, but we can opt into that by manually applying the ViewBuilder attribute ourselves.\n\nAnd that allows us to remove the return statements and the AnyView wrappers without any warnings or errors.\n\nOK, our code is looking pretty good now! We've gotten rid of all of the AnyViews, making it easier to read than before.\n\nAnd if we look at the type signature of the result, it now exactly replicates the conditional logic of our function with a tree of conditional content, providing SwiftUI with a much richer perspective of the view and the identities of its components.\n\nBut there's one more small improvement we can make.\n\nThe top level of our function is just matching against different cases of the dog's breed.\n\nThis seems like an excellent use case for a switch statement, which are also supported by view builders.\n\nNow it's even easier to quickly understand all the different cases of our view.\n\nAnd because switch statements are really just syntactic sugar for conditional statements, our resulting view's type signature on the right remains exactly the same.\n\nStepping back, we just showed you how AnyViews erase type information from your code, and walked through how to get rid of unnecessary AnyViews by leveraging view builders.\n\nIn general, we recommend avoiding AnyViews whenever possible.\n\nHaving too many AnyViews will often make code harder to read and understand.\n\nTraditional control flow statements like if/else and switch make it much easier to see the different possible states of a view.\n\nAnd because AnyView hides static type information from the compiler, it can sometimes prevent helpful diagnostic errors and warnings from being surfaced in your code.\n\nFinally, keep in mind that using AnyView when you don't need to can result in worse performance.\n\nWhen possible, use generics to preserve static type information rather than passing AnyViews around your code.\n\nAnd with that, we've finished introducing the basic types of view identity in SwiftUI.\n\nWith explicit identity, we can tie the identity of our views to our data, or provide custom identifiers to refer to specific views.\n\nAnd with structural identity, we've learned how SwiftUI can identify our views just based on their type and position within the view hierarchy.\n\nAnd now I'll hand things over to Luca to discuss how the identity of your views is related to their lifetime and state.\n\nLuca Bernardi: Thanks, Matt.\n\nNow that we understand how SwiftUI identifies your views, let's explore how identity ties into the lifetime of your views and data.\n\nThis will help you better understand how SwiftUI works.\n\nTo help illustrate this, I'm also going to bring in a friend.\n\nThis is Theseus.\n\nIsn't he adorable, too? Someone will say more adorable, but I digress.\n\nIt is very intuitive for us to think that once we name our favorite pet, he'll always be the same adorable cat, even when he is in different states and he moves throughout the day.\n\nWhen we look at him one moment, he might be sleepy and a moment later, being a proper cat, he's annoyed by my presence -- but he'll always be Theseus.\n\nThis is the essence of connecting identity to lifetime.\n\nIdentity allows us to define a stable element for different values over time.\n\nIn other words, it allows us to introduce continuity over time.\n\nYou might be wondering, how does this apply to SwiftUI? So let's bring back a cat-friendly version of the app Matt was working on.\n\nJust like Theseus can be in different states at different moments in time, our views are also in different states throughout their lifetime.\n\nEvery single state is a different value for our view.\n\nIdentity connects these different values as a single entity -- a view -- over time.\n\nLet's look at some code to clarify this.\n\nHere we have a simple view that displays the intensity of purring.\n\nSpoiler: Theseus is pretty loud.\n\nThrough the evaluation of body, SwiftUI will create a new value for this view; in this case, with an intensity value of 25.\n\nTheseus is getting hungry and wants more attention.\n\nbody is invoked again with a higher intensity, and the new value for the view is created.\n\nThese are two distinct values created from the same view definition.\n\nSwiftUI will keep around a copy of the value to perform a comparison and know if the view has changed.\n\nBut after that, the value is destroyed.\n\nWhat it is important to understand here is that the view value is different from the view identity.\n\nView values are ephemeral and you should not rely on their lifetime.\n\nBut what you can control is their identity.\n\nWhen a view is first created and it appears, SwiftUI assigns it an identity using a combination of the techniques discussed before.\n\nOver time, driven by updates, new values for the view are created.\n\nBut from SwiftUI's perspective, these represent the same view.\n\nOnce the identity of the view changes or the view is removed, its lifetime ends.\n\nWhenever we talk about the lifetime of a view, we are referring to the duration of the identity associated with that view.\n\nBeing able to connect the identity of a view with its lifetime is fundamental to understand how SwiftUI persists your state.\n\nSo let's bring State and StateObject into the picture.\n\nWhen SwiftUI is looking at your view and sees a State or a StateObject, it knows that it needs to persist that piece of data throughout the view's lifetime.\n\nIn other words, State and StateObject are the persistent storage associated with your view's identity.\n\nAt the beginning of a view's identity, when it's created for the first time, SwiftUI is going to allocate storage in memory for State and StateObject using their initial values.\n\nHere we are focusing on the title state.\n\nThroughout the lifetime of the view, SwiftUI will persist this storage as it gets mutated and the view's body is re-evaluated.\n\nLet's look at a concrete example of how changes in identity affect the persistence of state.\n\nThis is an interesting example because we have the same view but in two separate branches.\n\nIf you remember from before, because of structural identity, the two views are considered to have different identities.\n\nMatt has discussed how this affects animations, but this also has a profound impact on the persistence of your state.\n\nLet's see this in practice.\n\nWhen we first evaluate body and we enter the true branch, SwiftUI will allocate persistent storage for the state with its initial value.\n\nThroughout the lifetime of this view, SwiftUI persists the state as it gets mutated by various actions.\n\nBut what happens if the value of dayTime changes and we enter the false branch? SwiftUI knows this is a different view with a distinct identity.\n\nIt creates new storage for the false view, starting with the state's initial value, and the storage for the true view is deallocated right after.\n\nBut what if we go back to the true branch? Well, that's a new view again, so SwiftUI creates new storage, starting again from the state's initial value.\n\nThe takeaway here is that whenever the identity changes, the state is replaced.\n\nLet me pause here for a moment and make sure that you understand this important point: the persistence of your state is tied to the lifetime of your views.\n\nThis is a very powerful concept because we can clearly separate what is the essence of a view -- its state -- and tie that to its identity.\n\nEverything else can be derived from it.\n\nAnd your data is so important that SwiftUI has a set of data-driven constructs that use the identity of your data as a form of explicit identity for your views.\n\nThe canonical example of this is ForEach.\n\nLet's now take a look at all of the different ways you can initialize a ForEach.\n\nThis will help us build a better intuition around this type.\n\nThe simplest form of ForEach is one that takes a constant range.\n\nThis is a very convenient initializer, especially when you are getting started prototyping some new UI.\n\nSwiftUI is going to use the offset in this range to identify the views produced by the view builder.\n\nBy requiring a constant range, we guarantee that the identities are stable for the lifetime of the view.\n\nIn fact, it is an error to use this initializer with a dynamic range.\n\nAnd new this year, you will see a warning when providing a non-constant range.\n\nLet's make things more interesting and bring in a dynamic collection of data.\n\nThis initializer takes a collection and a keypath to a property serving as an identifier.\n\nThis property must be hashable because SwiftUI is going to use its value to assign an identity to all the views generated from the elements of the collection.\n\nLater, Raj is going to show you some examples of how choosing a stable identity affects the performance and correctness of your app.\n\nThis idea of providing a stable identity for your data is so important that the standard library defines the Identifiable protocol to describe this capability.\n\nAnd SwiftUI takes full advantage of this protocol, allowing you to omit the key path and use the identifier provided by the protocol requirement to define the identity associated with your data and your views.\n\nSomething that I really love about Swift is that we can take advantage of its type system to precisely describe the constraints of the problem that we are solving.\n\nSo indulge with me in taking a look at the definition of the initializer we are using here.\n\nThere are a lot of interesting things in this short definition, so let's try to unpack them.\n\nForEach needs two main pieces: a collection -- here indicated by the generic argument Data -- and a way to generate a view from each element of the collection.\n\nThe shape of this initializer should give you the intuition that ForEach defines a relationship between a collection of data and a collection of views.\n\nBut actually, the most interesting part here is that we constrain the elements of the collection to be Identifiable.\n\nAgain, the purpose of the Identifiable protocol is to allow for your type to provide a stable notion of identity so that SwiftUI can keep track of your data throughout its lifetime.\n\nIn fact, this is very similar to the concepts of identity and lifetime that we discussed earlier.\n\nSwiftUI views that takes an Identifiable type and a view builder are data-driven components.\n\nThese views use the identity of the data that you provide to scope the lifetime of the views associated to it.\n\nChoosing a good identifier is your opportunity to control the lifetime of your views and data.\n\nSo let's recap what we have discussed in this section.\n\nViews values are ephemeral and you should not rely on their lifetime.\n\nBut their identity is not, and is what gives them continuity over time.\n\nYou are in control of the identity of your views, and you can use identity to clearly scope the lifetime of state.\n\nAnd finally, SwiftUI takes full advantage of the Identifiable protocol for data-driven components, so it's important to choose a stable identifier for your data.\n\nAnd now continuing the tradition, I'm going to hand it over to Raj. Raj? Raj Ramamurthy: Thanks, Luca! So far, we've explained what identity is and how it ties into a view's lifetime.\n\nNext, I'm going to dive into how SwiftUI updates the UI.\n\nThe goal is to give you a better mental model for how to structure SwiftUI code.\n\nI'm also going to show a few examples outlining everything at the end.\n\nTo kick this discussion of dependencies off, let's look at a view.\n\nHere's a simple view.\n\nIt shows a button that rewards a dog with a treat.\n\nSorry, Luca, but I'm more of a dog person.\n\nLet's focus on the structure of the view.\n\nFirst, let's look at the top.\n\nThere are two properties: one for a dog and another for a treat.\n\nThese properties are dependencies of the view.\n\nA dependency is just an input to the view.\n\nWhen a dependency changes, the view is required to produce a new body.\n\nThe body is where you build the hierarchy for the view.\n\nDiving into this view's hierarchy, we have a button with an action.\n\nActions are what trigger changes to a view's dependencies.\n\nLet's swap the code out for an equivalent diagram.\n\nHere's a diagram of our DogView.\n\nWhen we tap on the button, it dispatches an action to reward the dog.\n\nOur dog gulps down the treat in a flash.\n\nAnd that results in a change to the dog -- maybe he wants another.\n\nBecause the dependency changed, DogView produces a new body.\n\nTo learn more about the general concepts of data flow in SwiftUI, check out \"Data essentials in SwiftUI\" from WWDC 2020.\n\nNext, let's simplify this diagram a bit.\n\nFocusing in on the view hierarchy, notice how our views form a tree-like structure.\n\nAnd if we add the dog and treat dependencies back at the top, it still looks like a tree.\n\nHowever, the DogView is not the only view with dependencies.\n\nIn SwiftUI, each view can have its own set of dependencies.\n\nSo far, this still looks like a tree.\n\nBut note, there can be multiple views dependent on the same state or other data.\n\nFor example, one of the descendants might depend on the dog, too.\n\nAnd this could happen for one of our other dependencies.\n\nSo we started with a tree, but this structure only loosely resembles a tree now.\n\nIn fact, if we rearrange it to avoid overlapping lines, we end up with this structure, which reveals that this is actually a graph, not a tree.\n\nIn fact, we call this structure the \"dependency graph\".\n\nThis structure is important because it allows SwiftUI to efficiently update only those views that require a new body.\n\nTake, for example, the dependency at the bottom.\n\nIf we examine this dependency, it has two dependent views.\n\nThe secret of the graph is that if the dependency changes, only those views will be invalidated.\n\nSwiftUI will call each view's body, producing a new body value for each view.\n\nSwiftUI will instantiate the values of each invalidated view's body.\n\nThat may result in more dependencies changing, but not always! Because views are value types, SwiftUI can efficiently compare them to only update the right subset of views.\n\nThis is another way to look at what Luca discussed earlier.\n\nA view's value is short-lived.\n\nThe struct value is just used for comparison, but the view itself has a longer lifetime.\n\nAnd that's how we can avoid generating a new body for the view in the center.\n\nAn identity is the backbone of the dependency graph.\n\nAs Matt said, every view has identity, whether specified explicitly or structurally.\n\nThat identity is how SwiftUI routes changes to the right views and efficiently updates the UI.\n\nThere are many kinds of dependencies.\n\nWe saw a few examples earlier with the treat property and the dog binding, but you can also form dependencies by using the environment, state, or any of the observable object property wrappers.\n\nNext, I'd like to talk about how to improve the use of identity in your views.\n\nThis will help SwiftUI better understand your code.\n\nAs Luca said, the lifetime of a view is the duration of its identity, and that means the stability of an identifier is crucial.\n\nAn identifier that isn't stable can result in a shorter view lifetime.\n\nAnd having a stable identifier also helps performance, since SwiftUI doesn't need to continually create storage for the view and churn through updating the graph.\n\nAs you saw earlier, SwiftUI uses lifetime to manage persisted storage, so stable identifiers are also important for avoiding loss of state.\n\nLet's turn to a code example to explain the importance of identifier stability.\n\nIn this example, I have a list of my favorite pets.\n\nWe've got an identifier on our pet struct.\n\nBut there's actually a bug; every time I get a new pet, everything on screen flashes! Let's stop for a second and look at this code.\n\nCan you spot where the bug is? The bug is here, in our Identifiable conformance.\n\nIf you didn't pass the test, don't worry; there are no treats in this section.\n\nThe problem is that this identifier isn't stable, so anytime the data changes, we get a new identifier.\n\nWhat if instead, we used the indices of our pets array? Unfortunately, this has a similar problem.\n\nBy using the indices, views are now identified by the position of their respective pet in the collection.\n\nIf I decide I have a new first favorite pet, all the other pets will change their identity, which could cause a bad bug.\n\nIn this example, the button inserts a new element at index zero, but because the last index is the new one, we get an insertion at the end instead of the start.\n\nThis is because, like computed random identifiers, indices are not a stable form of identity.\n\nIn this example, we need to use a stable identifier, like one from a database or derived from stable properties of the pet.\n\nAny persistent identifier is a great choice.\n\nNow our animation looks great! But stability isn't the only property we need for good identifiers.\n\nAnother property of good identifiers is uniqueness.\n\nEach identifier should map to a single view.\n\nThis ensures that animations look great, performance is smooth, and the dependencies of your hierarchy are reflected in the most efficient form.\n\nLet's look at another example.\n\nIn this example, I'm working on a view with all of my pet's favorite treats.\n\nEach treat has a name, an emoji, and an expiration date.\n\nI've chosen to identify each treat by its name.\n\nAt this point -- I'm sure you can guess -- we have a bug here, too.\n\nWhat happens when we have more than one of the same kind of treat? I don't know about you, but I like to buy dog biscuits in bulk.\n\nWhen I add them to the jar, they might not show up! The problem is that the name of a treat is not a unique identifier for it.\n\nInstead, we can use a serial number or other unique ID per treat.\n\nAnd this ensures all the right data is shown in our jar.\n\nIt will also ensure better animations and better performance.\n\nWhen SwiftUI needs an identifier, it needs your help! Please be careful when using random identifiers, especially in computed properties.\n\nIn general, you want all of your identifiers to be stable.\n\nAn identifier shouldn't change over time; a new identifier represents a new item with a new lifetime.\n\nAnd lastly, identifiers need to be unique.\n\nMultiple views can't share an identifier.\n\nSwiftUI relies on these properties to make your app run smoothly and bug-free.\n\nNow that we've talked about explicit identity, I'd like to move on to structural identity.\n\nIn this example, I'm working on the treat jar from earlier.\n\nAs a responsible pet lover, I only feed my pets the finest, unexpired foods.\n\nTo help me tell when treats have gone bad, I've added a new modifier that optionally dims a treat cell when the treat is expired.\n\nI've highlighted the cell that's dimmed.\n\nLet's dive into the modifier.\n\nYou can see that in the modifier, I have a date and compare it to the current date to know when to dim the view.\n\nThis seems fine at first blush, but there's a subtle problem here.\n\nIf the condition changes and our treat becomes expired, we end up with a new identity because there is a branch here.\n\nAs Matt discussed, branches are a form of structural identity.\n\nThis means we have two copies of the content instead of a single, optionally modified copy.\n\nNote that the branch here is in a modifier.\n\nFor clarity, I've put the modifier and its use site on the same slide, but in your project, you might have branches like this across files without even being aware of it! Of course, everything we've discussed here applies to views and view modifiers.\n\nSo how can we avoid this? Well, one way is to fold the branches together and move the condition inside the opacity modifier, like so.\n\nBy removing this branch, we've correctly described this view as having a single identity.\n\nFurthermore, moving the condition inside the opacity modifier can help performance, because we've tightly scoped the dependent code.\n\nNow when the condition changes, only the opacity needs to change.\n\nThe trick to this is that when the condition is true, we have an opacity of 1, which looks like this.\n\nAn opacity of 1 has no effect.\n\nWe call modifiers like this \"inert modifiers,\" because they don't affect the rendered result.\n\nSwiftUI modifiers are cheap, so there is little inherent cost with this pattern.\n\nBecause there is no resulting visual effect, the framework can efficiently prune away the modifier, further reducing its cost.\n\nBranches are great, and they exist in SwiftUI for a reason.\n\nBut when used unnecessarily, they can cause poor performance, surprising animations, and, as Luca showed, even loss of state.\n\nWhen you introduce a branch, pause for a second and consider whether you're representing multiple views or two states of the same view.\n\nAs we saw, it often works better to use an inert modifier instead of a branch to identify a single view.\n\nHere are just a few examples of inert modifiers.\n\nI especially love transformEnvironment for conditionally writing to the environment.\n\nPutting everything together, we've shown you today that identity is one of the secrets to amazing performance.\n\nWe've discussed explicit and structural identity, and how you can take advantage of each to improve your app.\n\nFrom identity, we can derive a view's lifetime, which controls its associated storage, transitions, and more.\n\nAnd we've also explained that SwiftUI uses identity and lifetime to form dependencies, which are represented by a graph that can efficiently update the UI.\n\nAlong with demystifying SwiftUI, we've given you some tips and tricks to avoid bugs and improve performance in your apps.\n\nAnd now that you've learned these tricks, take a tour through your code to see if they can help you.\n\nThank you, and keep building great apps! ♪",
    "segments": []
  },
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2021/10022/7/72A67717-944A-4D86-BFDD-D1B307C722EC/downloads/wwdc2021-10022_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2021/10022/7/72A67717-944A-4D86-BFDD-D1B307C722EC/downloads/wwdc2021-10022_sd.mp4?dl=1"
  },
  "relatedVideos": [
    {
      "id": "10160",
      "year": "2023",
      "title": "Demystify SwiftUI performance",
      "url": "https://developer.apple.com/videos/play/wwdc2023/10160"
    },
    {
      "id": "10058",
      "year": "2022",
      "title": "SwiftUI on iPad: Organize your interface",
      "url": "https://developer.apple.com/videos/play/wwdc2022/10058"
    },
    {
      "id": "10019",
      "year": "2021",
      "title": "Discover concurrency in SwiftUI",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10019"
    },
    {
      "id": "10119",
      "year": "2021",
      "title": "SwiftUI Accessibility: Beyond the basics",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10119"
    },
    {
      "id": "10018",
      "year": "2021",
      "title": "What's new in SwiftUI",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10018"
    },
    {
      "id": "10040",
      "year": "2020",
      "title": "Data Essentials in SwiftUI",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10040"
    },
    {
      "id": "216",
      "year": "2019",
      "title": "SwiftUI Essentials",
      "url": "https://developer.apple.com/videos/play/wwdc2019/216"
    }
  ],
  "extractedAt": "2025-07-18T10:54:51.575Z"
}