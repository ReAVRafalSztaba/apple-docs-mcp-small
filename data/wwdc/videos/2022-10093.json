{
  "id": "10093",
  "year": "2022",
  "url": "https://developer.apple.com/videos/play/wwdc2022/10093/",
  "title": "Integrate your custom collaboration app with Messages",
  "speakers": [],
  "duration": "",
  "topics": [
    "App Services"
  ],
  "hasTranscript": true,
  "hasCode": true,
  "transcript": {
    "fullText": "♪ Mellow instrumental hip-hop music ♪ ♪ Devin Clary: Hi. I'm Devin, an engineer on the Messages team.\n\nLance Parker: And I'm Lance, also a Messages engineer.\n\nDevin: Welcome to \"Integrate your custom collaboration app with Messages.\" Collaboration starts with a conversation, and in iOS 16 and macOS Ventura, you can bring your app's custom collaboration experience right into the fabric of the conversation.\n\nIn this video, we'll go over the life cycle of a collaboration.\n\nThen, we'll show you how to prepare your app's collaborative content to be shared through Messages.\n\nNext, we'll give you everything you need to instantly verify recipient access, and respond to participant changes, all without compromising privacy.\n\nFinally, we'll show you how your app can post notices about the content right to the Messages conversation.\n\nThis video assumes your app has existing collaboration infrastructure, and has already adopted universal links.\n\nWe'll also build on some concepts introduced in \"Add Shared with You to your app\" and \"Enhance collaboration experiences with Messages.\" First up, I'll go over the life cycle of a custom collaboration message to illustrate how this API allows your users to start collaborating faster than ever.\n\nWhen a user decides to share a collaboration from your app through Messages, you first create metadata to represent the content.\n\nThe metadata includes share options the user can configure prior to sending the message, and a number of other properties you can customize.\n\nNext, you provide that metadata to the share sheet, or to drag and drop.\n\nThis allows a draft of the content to be staged in the Messages compose field.\n\nThe collaboration needs to be represented by a universal link.\n\nThat can be created immediately, but it's best deferred until right before the message is sent.\n\nThis is useful if your app's link creation depends on the selected share options, or recipients, as configured in the Messages compose field.\n\nThe user chooses the recipients and share options and taps the send button.\n\nBefore the message is sent, Messages asks your app for the universal link and a device independent identifier for the content.\n\nUsing that identifier, Messages provides a set of cryptographic identities representing the recipients of that specific collaboration message.\n\nYour app will use these identities later to allow the recipients to immediately open the link on any of their devices.\n\nYour app stores those identities on its servers and associates them with the shared content.\n\nOnce your app finishes this step, the message is sent to the recipients.\n\nNow, here's what happens on the receiving device.\n\nThe goal is to instantly verify access, pairing a recipient identity with an account on your server.\n\nWhen the recipient opens the link, your app receives a call to open the URL, just like it does for any other link.\n\nWhen your app detects that a user account doesn't yet have access to the document, it queries the system for a proof of user identity cryptographically signed by the recipient device.\n\nYour app sends that signed identity proof to your server for validation.\n\nIf the signature is valid, the server compares the proof against the identities previously provided by the sending device.\n\nIf there's a match, your server grants access to the user's account.\n\nAnd with that, the recipient has gained instant and secure access to the content, all without exchanging account information! And that's the life cycle of a collaboration message! Next, let's look more closely at the API for starting a collaboration.\n\nThe system needs some metadata about the collaboration.\n\nAnd for that, you use a new class in the Shared with You framework called SWCollaborationMetadata.\n\nThis class has a few properties for you to configure: the content's title, a local identifier to reference the content before its been shared; the initiator name and account handle, to provide transparency to the user about the account they're sharing from; and the default share options, for the user to configure.\n\nHere's how to create a metadata object and configure its properties.\n\nCreate a local identifier using SWLocalCollaborationIdentifier initialized with a string.\n\nThe string only needs to be sufficient for your app to identify the content locally, not across devices.\n\nInitialize a new metadata instance using the local identifier.\n\nSet the content title, the initiator's account handle, and their name using PersonNameComponents from the foundation framework.\n\nThe handle and name are only displayed locally so the user can confirm the account they're sharing from.\n\nNext, set the defaultShareOptions.\n\nBefore I show you how to do that, I'll first describe how options work.\n\nShare options are the settings a user configures on the collaboration in Messages or the share sheet.\n\nThe options selected by the user are provided to you before the message is sent.\n\nShare options might include settings like who can make edits to a collaboration or who should have access to the content.\n\nYou use a few classes to define options, starting with SWCollaborationOption.\n\nDepending on how they're grouped, options represent individual switches, or mutually exclusive values for a setting.\n\nOptions have a title and an identifier, and they are either selected or unselected.\n\nThere are two classes to represent a group of options: SWCollaborationOptionsGroup and SWCollaborationOptions PickerGroup.\n\nYou use SWCollaborationOptionsGroup to represent a collection of switches, while SWCollaborationOptions PickerGroup represents mutually exclusive values for a setting.\n\nFinally, SWCollaborationShareOptions defines the full set of option groups, to be set on the metadata's defaultShareOptions property.\n\nYou can also provide a summary string to describe the options.\n\nNow that I've described the option classes, here's an example showing how to use them.\n\nThis code defines two option groups.\n\nThe first group is initialized with an identifier and two possible options.\n\nThe identifier is an arbitrary string you later use to identify which option was selected by the user.\n\nSince this is a picker group, the options are mutually exclusive.\n\nThis group represents the permission settings for the content: readwrite or readonly.\n\nThen, the first option in that group is selected by default.\n\nAnd the title is set to a string describing this group.\n\nThe second option group is initialized the same way, and also contains two options.\n\nBut since this is a generic option group, the user will be able to configure whether to allow mentions and comments independently.\n\nFinally, the two option groups are used to initialize an instance of SWCollaborationShareOptions, which is then set on the metadata.\n\nNext, the metadata is provided to the share sheet or drag and drop, depending on how the user decides to share the content.\n\nIf your app uses SwiftUI, SWCollaborationMetadata is compatible with the new ShareLink API.\n\nWatch \"Meet Transferable\" and \"What's new in SwiftUI\" to learn more about Transferable and ShareLink.\n\nHere's how easy it is to support collaboration on a proxy representation in SwiftUI! From within a Transferable model object, set up a ProxyRepresentation to return a collaboration metadata instance.\n\nThen, from a view, initialize ShareLink with that model object.\n\nFor UIKit and AppKit apps, you use NSItemProvider to support sharing.\n\nAnd SWCollaborationMetadata conforms to NSItemProviderReading and writing.\n\nSo you simply register a metadata instance with an item provider, to support collaboration.\n\nIt's also good practice to register multiple representations of the content to support sharing through as many channels as possible.\n\nFor example, Messages automatically offers an option to send the content as a copy if you provide a file representation.\n\nYou'll use the NSItemProvider API with UIActivityViewController and UIDragItem on iOS and iPadOS and NSSharingServicePicker on macOS.\n\nHere's how to set that up with the share sheet on iOS.\n\nCreate an NSItemProvider instance.\n\nRegister the collaboration metadata created in the previous example, with visibility set to all processes on the system.\n\nInitialize UIActivityItemsConfiguration with the item provider, then initialize UIActivityViewController with that configuration.\n\nAnd finally, present the view controller.\n\nIt's just as easy to support drag and drop.\n\nInitialize NSItemProvider and register the metadata the same way, then create a UIDragItem with the item provider to use with the drag and drop APIs.\n\nThe API is similar on macOS for the sharing popover.\n\nAgain, set up the item provider.\n\nAnd this time, use it to initialize NSSharingServicePicker.\n\nAnd then show the picker relative to a target view.\n\nDrag and drop on macOS utilizes NSPasteboardItem rather than NSItemProvider.\n\nTo support this, SharedWithYou exports an NSPasteboardItem extension.\n\nUsing that extension, set the collaboration metadata directly on a new NSPasteboardItem instance in order to support drag and drop.\n\nAnd that's all you need for a draft of your collaborative content to be staged in Messages! Next, when the user taps the send button, the system coordinates with your app to set up the share.\n\nIt does this through a new class called SWCollaborationCoordinator.\n\nSWCollaborationCoordinator is a singleton, meaning there is a global shared instance.\n\nThat shared instance coordinates the collaboration through a delegate you define called an actionHandler.\n\nTo ensure your app is always available to coordinate collaborations, it will be launched in the background when needed.\n\nSo you should register the delegate soon after launch and handle actions immediately to avoid timeouts.\n\nHere's how to set up the collaboration coordinator after your app finishes launching.\n\nAccess the singleton coordinator instance through the shared property.\n\nThen, in the app delegate's didFinishLaunchingWithOptions method, set the actionHandler property to an object that conforms to the SWCollaborationActionHandler protocol.\n\nThe action handler protocol uses a new class called SWAction.\n\nSWActions represent work your app is expected to perform.\n\nYou fulfill actions to mark them as complete, and fail them otherwise.\n\nThe first action your app needs to handle is the start collaboration action.\n\nSWStartCollaborationAction contains the collaboration metadata you set up earlier, updated with the user's selected share options.\n\nOnce you've performed the necessary setup, you fulfill the start action with the universal link and a device-independent identifier for the collaboration.\n\nIf you explicitly fail the start action, the message is canceled.\n\nHere's an implementation to handle the start action using an example server request.\n\nFirst, retrieve the local identifier, and user-selected share options from the action's metadata property.\n\nSet up a server request to prepare the collaboration using the identifier and options.\n\nThen, send the request to the server.\n\nThis example uses async await.\n\nFinally, fulfill the action with the universal link and the device independent identifier from the response.\n\nOr, if there was an error, fail the action to cancel the message.\n\nIf the start action was successful, the system sends your app a second action to update the collaboration participants.\n\nThe SWUpdateCollaboration ParticipantsAction contains the cryptographic identities for the participants.\n\nThe identities are derived from the collaboration identifier fulfilled by the start action in the previous step.\n\nStore the identities on your server associated with the content.\n\nYou'll use this data for verifying access on the recipient devices.\n\nFinally, fulfilling this action will send the universal link in Messages.\n\nThis example shows how to handle the update participants action.\n\nRetrieve the collaboration identifier from the action's metadata.\n\nThis is the identifier you fulfilled while handling the start action.\n\nNext, retrieve the participant data to store on your servers using the action's addedIdentities property.\n\nEach identity has a Data property called a root hash.\n\nThis is the data you should store on your server for later use.\n\nLance will go over more of the details about this property in the Verifying Access section.\n\nSet up another server request, this time to add the participants to the collaboration with the target identifier.\n\nAnd just like before, send the request to your server, and fulfill or fail the action.\n\nThis time, the fulfill method does not take any parameters.\n\nNow that you've set up the collaboration, your app has everything it needs to grant immediate access to the recipients of the message.\n\nI'll hand it over to Lance to show you how to do that! Lance: Thanks, Devin. In this section, I'll show how to provide immediate access to the recipients using the identity data you stored on your server in the previous step.\n\nThe rootHash property on SWPersonIdentity is used to do this verification.\n\nA rootHash is a secure value used to uniquely identify a participant on their devices.\n\nIn order to perform verification, you'll need to understand how to compute a root hash.\n\nI'll take you through that now.\n\nWhen a collaboration message is sent, it's actually sent individually to each of a person's devices.\n\nMessages identifies each device using a cryptographic public key.\n\nSince the goal is to allow access only on this set of devices, the root hash is derived from the set of public keys registered to each recipient.\n\nThe root hash is the root node of a data structure called a Merkle tree.\n\nA Merkle tree is a binary tree that is built by performing a sequence of hashing operations.\n\nIn order to derive an identity for the user based on their public keys, the keys are used as the leaves of this tree.\n\nThe hashing algorithm used in the Merkle tree ensures that the root node can only be computed from that set of keys.\n\nIn this example, this user has three devices and three public keys.\n\nThe keys will be unique for each collaboration identifier provided by your app, using a process called key diversification.\n\nTo prevent tracking the number of devices registered to a user, the set is padded with random keys up to a fixed size.\n\nThe leaf nodes of the tree are created by hashing the padded set of diversified keys.\n\nThe SHA256 algorithm is used for the hashing operations in this tree.\n\nThen, each pair of leaf nodes are concatenated and then hashed to derive their parent nodes.\n\nThis process is repeated with the parent nodes and repeated again until a single root node remains.\n\nThis is the root hash used to uniquely represent this recipient's identity across their devices.\n\nNotice that it's possible to generate a root hash using a subset of the nodes from a complete Merkle tree.\n\nThe root hash in this tree can be reproduced using just the hashes H4, 7, and 11, along with the diversified public key P3.\n\nFirst, hash the public key to get the missing leaf node H3.\n\nUse H3 and H4 to generate H8.\n\nUse the given H7 node with H8 to generate H10.\n\nAnd finally, H10 and H11 produce the root hash.\n\nIt's important to note that you can prove the public key P3 was used to generate a given root hash, without needing to reconstruct the entire tree.\n\nThe subset of nodes needed to do this is called a proof of inclusion.\n\nVerification begins when a universal link is opened in your app.\n\nTo do this, you first need to check that the link is collaborative.\n\nSWCollaborationHighlight represents a collaborative link and is retrieved from SWHighlightCenter.\n\nUse that collaboration highlight to generate the proof of inclusion.\n\nTo represent a proof of inclusion, use a class called SWPersonIdentityProof.\n\nTo perform verification, you'll first generate this object along with a cryptographic signature to send to your server.\n\nRetrieve the proof using the getSignedIdentityProof method on SWHighlightCenter.\n\nIt takes an SWCollaborationHighlight and some arbitrary data to be signed by the device.\n\nUse the signature to ensure the request cannot be replayed by a bad actor to gain access to your collaboration.\n\nThe data could be a challenge you request from your server, or a nonce generated on the device.\n\nThis example uses the challenge approach.\n\nThe URL is passed to this method on your app's UIApplicationDelegate.\n\nThis URL is the universal link associated with the collaboration.\n\nThe URL is used to fetch the associated SWCollaborationHighlight from the SWHighlightCenter.\n\nNext, I'll request the challenge from my server, and pass the data I get back to the getSignedIdentityProof method on SWHighlightCenter, along with the highlight.\n\nThis method returns a signed identity proof.\n\nI'll discuss what your server should do to validate this data later on.\n\nNow I can send the signed proof to my server for verification.\n\nFinally, I update my user interface with the result.\n\nThe app sends the proof to the server, along with the public key and the signed data.\n\nThe data is signed using the elliptic curve digital signature algorithm over the P-256 elliptic curve, using SHA256 as a hash function.\n\nVerify the signature on the data using the public key in the identity proof.\n\nYou can do this with most commonly used encryption libraries.\n\nOnce you have verified the signature, you can trust that the identity proof was sent from the device associated with that public key.\n\nNext, you use the identity proof to recompute the root hash.\n\nHere is an example of what an SWPersonIdentityProof would contain using the example tree we looked at before.\n\nUse it to reconstruct the root hash of a Merkle tree.\n\nThe public key is P3.\n\nThe inclusion hashes are H4, 7, and 11.\n\nA local key index of 2 indicates the position of the public key in the tree.\n\nHere is an example implementation that reconstructs a root hash from the properties on the proof.\n\nA recursive algorithm works nicely when working with tree data structures, so that's what I've done here.\n\nOn the initial invocation, pass in the hash of the public key, the set of inclusion hashes, and the public key index.\n\nNext, the first inclusion hash is pulled out.\n\nThe public key index is checked to see if the key is on the left or the right of its sibling.\n\nThe selected hashes are concatenated in the correct order, and then hashed.\n\nNext, the consumed node in the inclusionHashes array is removed, and the rest are passed to a recursive call to this same function.\n\nThe public key index is also updated so that it's ready for the next node in the tree.\n\nWith this simple function, you can quickly compute a root hash given an identity proof.\n\nThe server can now check that this generated root hash is in the list of root hashes the owner of the document uploaded during sending.\n\nThe hash is present in the list of known hashes, so the server can grant access to the document.\n\nNow you can grant access to the document with confidence! To recap the steps you'll follow to verify an identity: first, look up the collaboration highlight for your content while handling its universal link.\n\nNext, sign some data and retrieve the proof of inclusion.\n\nSend the signed data and proof to your server.\n\nVerify the signature on the data.\n\nUsing the proof of inclusion, generate the root hash.\n\nFinally, compare the root hash to the list of known identities associated with that content.\n\nNow that you know all about verifying access to your collaboration links, I'll talk about how to coordinate participant changes with Messages.\n\nWhen the participants in a Messages group change, and that group is collaborating together, a user can choose to propagate those changes to your app, right from a banner in the Messages thread.\n\nIn this scenario, your app receives another SWUpdateCollaboration ParticipantsAction containing the added and removed identities.\n\nYou'll use the same code you wrote to handle this action when setting up a collaboration, but you'll also need to handle removed participants.\n\nFor removal, simply look up any account associated with a removed identity and revoke their access.\n\nIf no account is yet associated, simply delete the root hash from your database.\n\nHere's the implementation for the update participants action that Devin went over earlier.\n\nThis example uses the removed identities property on the action and passes them to a similar removal API request.\n\nNote that this code only shows handling removed identities, but a complete implementation should handle both added and removed identities.\n\nAnd that's all you need to handle participant changes! Lastly, when changes are made to a collaboration, your app posts notices about those changes to be shown directly in Messages.\n\nThere are a few types of supported notices I'll go over in this section.\n\nNotices are displayed as a banner right in the conversation where the link was shared.\n\nThe banner includes a description of what changed, as well as who made the change.\n\nIn this conversation, Charlie made edits to the Baking Recipes document.\n\nTapping the show button connects them right back to the content.\n\nTo represent a notice, the SharedWithYou framework has a protocol named SWHighlightEvent.\n\nHighlight events are initialized with SWHighlights retrieved from the SWHighlightCenter API.\n\nMessages supports several categories of events.\n\nA change event for content updates or comments, a membership event when a participant joins or leaves, a mention event when a user is mentioned in a collaboration, and a persistence event when content is moved or deleted.\n\nHere's an example showing how to post a change event for an edit to a collaboration.\n\nUsing the highlight center API, retrieve a collaboration highlight for the target identifier.\n\nRemember, this identifier is one you defined during the collaboration initiation, so your app should have this available for use when a content change is made.\n\nNext, create a highlight change event instance.\n\nThe initializer takes a highlight, and a trigger enum value; in this case, set it to the edit type.\n\nFinally, again using the highlight center, post the notice for that event.\n\nSimilarly, for membership changes, post a membership event, this time passing the addedCollaborator or removedCollaborator trigger type.\n\nNext, if your app supports user mentions, you can post a mention event.\n\nInitialize a person identity with the root hash of the mentioned user.\n\nRecall that you associated a person identity with a user account in your app while verifying access.\n\nThen, post the mention event in the same way, this time passing the mentioned identity as a parameter.\n\nThis notice will only be shown in Messages to the mentioned user.\n\nFinally, use the persistence event type when content is moved, renamed, or deleted.\n\nHere, the renamed trigger type is used, to signify that the user changed the name of the content.\n\nAnd that is how your app can notify collaborators, and they will get those updates right in Messages.\n\nDevin: And with that, you're ready to integrate your app's collaboration experience with messages by following a few steps.\n\nSet up your content to be shared collaboratively, cryptographically verify participant access, keep track of participant changes, and post notices in Messages to connect your users right back to the content.\n\nBe sure to check out the \"Enhance collaboration experiences with Messages\" video to learn more about the new UI elements you can display for collaborations.\n\nLance: We can't wait to get collaborating with your apps! Devin and Lance, cryptographically signing off.\n\nDevin: Thanks for watching! ♪",
    "segments": []
  },
  "codeExamples": [
    {
      "timestamp": "4:21",
      "title": "Configure SWCollaborationMetadata",
      "language": "swift",
      "code": "let localIdentifier = SWLocalCollaborationIdentifier(rawValue: \"identifier\")\nlet metadata = SWCollaborationMetadata(localIdentifier: localIdentifier)\nmetadata.title = \"Content Title\"\nmetadata.initiatorHandle = \"user@example.com\"\n\nlet formatter = PersonNameComponentsFormatter()\nif let components = formatter.personNameComponents(from: \"Devin\") {\n    metadata.initiatorNameComponents = components\n}\n\nmetadata.defaultShareOptions = ..."
    },
    {
      "timestamp": "6:34",
      "title": "Configure SWCollaborationShareOptions",
      "language": "swift",
      "code": "let permission = SWCollaborationOptionsPickerGroup(identifier: UUID().uuidString, \n                                                   options: [\n    SWCollaborationOption(title: \"Can make changes\", identifier: UUID().uuidString),\n    SWCollaborationOption(title: \"Read only\", identifier: UUID().uuidString)\n])\npermission.options[0].isSelected = true\npermission.title = \"Permission\"\n\nlet additionalOptions = SWCollaborationOptionsGroup(identifier: UUID().uuidString, \n                                                    options: [\n    SWCollaborationOption(title: \"Allow mentions\", identifier: UUID().uuidString),\n    SWCollaborationOption(title: \"Allow comments\", identifier: UUID().uuidString)\n])\nadditionalOptions.title = \"Additional Settings\"\nlet optionsGroups = [permission, additionalOptions]\nmetadata.defaultShareOptions = SWCollaborationShareOptions(optionsGroups: optionsGroups)"
    },
    {
      "timestamp": "7:58",
      "title": "SWCollaborationMetadata SwiftUI TransferRepresentation",
      "language": "swift",
      "code": "struct CustomCollaboration: Transferable {\n    var name: String\n\n    static var transferRepresentation: some TransferRepresentation {\n        ProxyRepresentation { customCollaboration in\n            SWCollaborationMetadata(\n                localIdentifier: .init(rawValue: \"com.example.customcollaboration\"),\n                title: customCollaboration.name,\n                defaultShareOptions: nil,\n                initiatorHandle: \"johnappleseed@apple.com\",\n                initiatorNameComponents: nil\n            )\n        }\n    }\n}"
    },
    {
      "timestamp": "8:16",
      "title": "Using a collaboration metadata TransferRepresentation with ShareLink",
      "language": "swift",
      "code": "struct ContentView: View {\n    var body: some View {\n        ShareLink(item: CustomCollaboration(name: \"Example\"), preview: .init(\"Example\"))\n    }\n}"
    },
    {
      "timestamp": "9:08",
      "title": "iOS Share Sheet",
      "language": "swift",
      "code": "func presentActivityViewController(metadata: SWCollaborationMetadata) {\n    let itemProvider = NSItemProvider()\n    itemProvider.registerObject(metadata, visibility: .all)\n    let activityConfig = UIActivityItemsConfiguration(itemProviders: [itemProvider])\n    let shareSheet = UIActivityViewController(activityItemsConfiguration: activityConfig)\n    present(shareSheet, animated: true)\n}"
    },
    {
      "timestamp": "9:42",
      "title": "iOS Drag and Drop",
      "language": "swift",
      "code": "func createDragItem(metadata: SWCollaborationMetadata) -> UIDragItem {\n    let itemProvider = NSItemProvider()\n    itemProvider.registerObject(metadata, visibility: .all)\n    return UIDragItem(itemProvider: itemProvider)\n}"
    },
    {
      "timestamp": "9:58",
      "title": "macOS Sharing Popover",
      "language": "swift",
      "code": "func showSharingServicePicker(view: NSView, metadata: SWCollaborationMetadata) {\n    let itemProvider = NSItemProvider()\n    itemProvider.registerObject(metadata, visibility: .all)\n    let picker = NSSharingServicePicker(items: [itemProvider])\n    picker.show(relativeTo: view.bounds, of: view, preferredEdge: .minY)\n}"
    },
    {
      "timestamp": "10:18",
      "title": "macOS Drag and Drop NSPasteboardItem extension",
      "language": "swift",
      "code": "func createPasteboardItem(metadata: SWCollaborationMetadata) -> NSPasteboardItem {\n    let pasteboardItem = NSPasteboardItem()\n    pasteboardItem.collaborationMetadata = metadata\n    return pasteboardItem\n}"
    },
    {
      "timestamp": "11:22",
      "title": "Set up SWCollaborationCoordinator",
      "language": "swift",
      "code": "private let collaborationCoordinator = SWCollaborationCoordinator.shared\n\nfunc application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]?) -> Bool {\n    // Conform to the SWCollaborationActionHandler protocol\n    collaborationCoordinator.actionHandler = self\n}"
    },
    {
      "timestamp": "12:27",
      "title": "SWStartCollaborationAction",
      "language": "swift",
      "code": "func collaborationCoordinator(_ coordinator: SWCollaborationCoordinator, \n                              handle action: SWStartCollaborationAction) {\n    let localID = action.collaborationMetadata.localIdentifier.rawValue\n    let selectedOptions = action.collaborationMetadata.userSelectedShareOptions\n    let prepareRequest = APIRequest.PrepareCollaboration(localID: localID, selectedOptions)\n    Task {\n        do {            \n            let response = try await apiController.send(request: prepareRequest)\n            let identifier = response.deviceIndependentIdentifier\n            action.fulfill(using: response.url, collaborationIdentifier: identifier)\n        } catch {\n            Log.error(\"Caught error while preparing the collaboration: \\(error)\")\n            action.fail() // cancels the message\n        }\n    }\n}"
    },
    {
      "timestamp": "13:40",
      "title": "SWUpdateCollaborationParticipantsAction",
      "language": "swift",
      "code": "func collaborationCoordinator(_ coordinator: SWCollaborationCoordinator, \n                              handle action: SWUpdateCollaborationParticipantsAction) {\n    let identifier = action.collaborationMetadata.collaborationIdentifier\n    let participants: [Data] = action.addedIdentities.compactMap { $0.rootHash }\n    let addParticipants = APIRequest.AddParticipants(identifier: identifier, participants)\n    Task {\n        do {            \n            try await apiController.send(request: addParticipants)\n            action.fulfill() // sends the URL provided by the start action\n        } catch {\n            Log.error(\"Caught error while adding participants to collaboration: \\(error)\")\n            action.fail() // cancels the message \n        }\n    }\n}"
    },
    {
      "timestamp": "19:12",
      "title": "Retrieve a signed identity proof for a highlight",
      "language": "swift",
      "code": "func application(_ app: UIApplication, open url: URL, \n               options: [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {\n    let highlightCenter: SWHighlightCenter = self.highlightCenter\n    let challengeRequest = APIRequest.GetChallengeData()\n    Task {\n        do {\n            let highlight = try highlightCenter.collaborationHighlight(for: url)\n            let challenge = try await apiController.send(request: challengeRequest)\n            let proof = try await highlightCenter.getSignedIdentityProof(for: highlight, \n                                                                       using: challenge.data)\n    let proofOfInclusionRequest = APIRequest.SubmitProofOfInclusion(for: proof)\n            let result = try await apiController.send(request: proofOfInclusionRequest)\n            documentController.update(currentDocument, with: result)\n        } catch {\n            Log.error(\"Caught error while generating proof of inclusion: \\(error)\")\n        }\n    }\n}"
    },
    {
      "timestamp": "21:20",
      "title": "Example code for root hash generation",
      "language": "swift",
      "code": "func generateRootHashFromArray(localHash: SHA256Digest, inclusionHashes: [SHA256Digest], \n                       publicKeyIndex: Int) -> SHA256Digest {\n    guard let firstHash = inclusionHashes.first else { return localHash }\n    // Check if the node is the left or the right child\n    let isLeft = publicKeyIndex.isMultiple(of: 2)\n    // Calculate the combined hash\n    var rootHash: SHA256Digest\n    if isLeft {\n        rootHash = hash(concatenate([localHash, firstHash]), using: .sha256)\n    } else {\n        rootHash = hash(concatenate([firstHash, localHash]), using: .sha256)\n    }\n    // Recursively pass in elements and move up the Merkle tree\n    let newInclusionHashes = inclusionHashes.dropFirst()\n    rootHash = generateRootHashFromArray(\n        localHash: rootHash,\n        inclusionHashes: Array(newInclusionHashes),\n        publicKeyIndex: (publicKeyIndex / 2)\n    )\n    return rootHash\n}"
    },
    {
      "timestamp": "24:12",
      "title": "SWUpdateCollaborationParticipantsAction - removing participants",
      "language": "swift",
      "code": "func collaborationCoordinator(_ coordinator: SWCollaborationCoordinator, \n                              handle action: SWUpdateCollaborationParticipantsAction) {\n    // Example of removing participants only. Handle the added identities here too.\n    let identifier = action.collaborationMetadata.collaborationIdentifier\n    let removed: [Data] = action.removedIdentities.compactMap { $0.rootHash }\n    let removeParticipants = APIRequest.RemoveParticipants(identifier: identifier, removed)\n    Task {\n        do {            \n            try await apiController.send(request: removeParticipants)\n            action.fulfill()\n        } catch {\n            log.error(\"Caught error while adding participants to collaboration: \\(error)\")\n            action.fail()\n        }\n    }\n}"
    },
    {
      "timestamp": "25:54",
      "title": "Post an SWHighlightChangeEvent Notice",
      "language": "swift",
      "code": "func postContentEditEvent(identifier: SWCollaborationIdentifier) throws {\n    let highlightCenter: SWHighlightCenter = self.highlightCenter\n    let highlight = try highlightCenter.collaborationHighlight(forIdentifier: identifier)\n\n    let editEvent = SWHighlightChangeEvent(highlight: highlight, trigger: .edit)\n\n    highlightCenter.postNotice(for: editEvent)\n}"
    },
    {
      "timestamp": "26:50",
      "title": "Post an SWHighlightMentionEvent Notice",
      "language": "swift",
      "code": "func postMentionEvent(identifier: SWCollaborationIdentifier, mentionedRootHash: Data) throws {\n    let mentionedIdentity = SWPerson.Identity(rootHash: mentionedRootHash)\n\n    let highlightCenter: SWHighlightCenter = self.highlightCenter\n    let highlight = try highlightCenter.collaborationHighlight(forIdentifier: identifier)\n\n    let mentionEvent = SWHighlightMentionEvent(highlight: highlight,\n                                               mentionedPersonIdentity: mentionedIdentity)\n    highlightCenter.postNotice(for: mentionEvent)\n}"
    },
    {
      "timestamp": "27:23",
      "title": "Post an SWHighlightPersistenceEvent Notice",
      "language": "swift",
      "code": "func postContentRenamedEvent(identifier: SWCollaborationIdentifier) throws {\n    let highlightCenter: SWHighlightCenter = self.highlightCenter\n    let highlight = try highlightCenter.collaborationHighlight(forIdentifier: identifier)\n\n    let renamedEvent = SWHighlightPersistenceEvent(highlight: highlight, trigger: .renamed)\n    highlightCenter.postNotice(for: renamedEvent)\n}"
    }
  ],
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2022/10093/3/D9CE5DEB-FE73-4FEF-9993-9551EB58CBDC/downloads/wwdc2022-10093_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2022/10093/3/D9CE5DEB-FE73-4FEF-9993-9551EB58CBDC/downloads/wwdc2022-10093_sd.mp4?dl=1"
  },
  "relatedVideos": [
    {
      "id": "10094",
      "year": "2022",
      "title": "Add Shared with You to your app",
      "url": "https://developer.apple.com/videos/play/wwdc2022/10094"
    },
    {
      "id": "10095",
      "year": "2022",
      "title": "Enhance collaboration experiences with Messages",
      "url": "https://developer.apple.com/videos/play/wwdc2022/10095"
    },
    {
      "id": "10062",
      "year": "2022",
      "title": "Meet Transferable",
      "url": "https://developer.apple.com/videos/play/wwdc2022/10062"
    },
    {
      "id": "10074",
      "year": "2022",
      "title": "What's new in AppKit",
      "url": "https://developer.apple.com/videos/play/wwdc2022/10074"
    },
    {
      "id": "10052",
      "year": "2022",
      "title": "What's new in SwiftUI",
      "url": "https://developer.apple.com/videos/play/wwdc2022/10052"
    }
  ],
  "extractedAt": "2025-07-18T09:14:54.878Z"
}