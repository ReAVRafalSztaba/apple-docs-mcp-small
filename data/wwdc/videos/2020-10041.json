{
  "id": "10041",
  "year": "2020",
  "url": "https://developer.apple.com/videos/play/wwdc2020/10041/",
  "title": "What's new in SwiftUI",
  "speakers": [],
  "duration": "",
  "topics": [
    "Swift",
    "SwiftUI & UI Frameworks"
  ],
  "hasTranscript": true,
  "hasCode": true,
  "transcript": {
    "fullText": "Hello and welcome to WWDC.\n\nMy name is Matt Ricketson, and I work on the SwiftUI team. Later on, I'll be joined by my colleague, Taylor. Last year we introduced SwiftUI, a powerful new way to build great user interfaces on all of Apple's platforms. We're incredibly excited to show you what's new in SwiftUI's second major release.\n\nAs you'll soon find out, there are a ton of new features this year, much more than we can cover in just one talk. But we'll try to cover as much as we can, and along the way, we'll let you know about other sessions that you can check out to learn more. First up, we'll introduce the new app and widget APIs.\n\nWe'll also talk about improvements to displaying lists and collections.\n\nWe'll introduce new multi-platform APIs for toolbars and controls...\n\nand also show you new kinds of visual effects for styling your apps.\n\nFinally, we'll discuss new ways for your SwiftUI apps to integrate with the rest of the system. But let's start with apps and widgets. For the first time, you can build an entire app using just SwiftUI instead of embedding your SwiftUI code within a UIKit, AppKit or WatchKit app. Let's take a look. What you see here is a complete SwiftUI app, a simple \"Hello, world!\" example.\n\nThat's right. This is a 100% functioning app. You can build and run this code.\n\nIn fact, it's so concise that you can fit the entire app into just 140 characters. But don't let this deceive you. SwiftUI packs a ton of intelligent, automatic, but also customizable behavior into a simple and flexible API for declarative apps. Here I've written an app for keeping track of the books I'm currently reading in my book club. At the bottom, I've written a custom view to represent my app's main user interface. And at the top, I'm using that view as the content of my app's main window. The first thing to notice here is how similar these two declarations are. We designed SwiftUI's new app API to follow the same declarative, state-driven patterns you're already used to in your view code.\n\nIn both cases, you define a struct conforming to a protocol.\n\nYou can declare data dependencies using properties, and that data is used within the body property, which, for both apps and views, defines their declarative user interface content.\n\nHowever, you may notice one key difference which is the return type of the app's body property. The body of an app returns a scene, a new concept in SwiftUI that represents pieces of an app's user interface that can be independently displayed by the platform. We've prepared a whole talk that goes into more depth on what scenes are and how they relate to apps and views.\n\nFor now, I just want to focus on the scene we're using in this app called WindowGroup. That's because WindowGroup is a powerful example of how scenes in SwiftUI can provide intelligent, multi-platform functionality out of the box.\n\nIn our iOS app, WindowGroup is creating and managing a single full-screen window for our application.\n\nBut the same code can also run on watchOS, also managing a single full-screen window. Of course, our watchOS app looks different than our iOS app, but the core app structure is the same on both platforms, allowing them to share a single app declaration. In fact, my app will also work on tvOS and on the iPad too. And since iPadOS supports multi-window apps, we get some additional functionality for free...\n\nlike being able to create multiple instances of the app that can appear side-by-side.\n\nThis also extends to macOS, which also supports multiple windows. I can create new windows using the standard command-N shortcut and gather them up into a single tabbed window.\n\nSwiftUI will even automatically add a new window menu command into my main menu.\n\nAnd all of this is made possible by this simple app declaration using the new WindowGroup API to define my interface.\n\nSwiftUI supports other types of scenes as well, which can be composed together, like views, to build more complex apps.\n\nLike the new Settings scene available on macOS for adding a preferences window to your Mac app.\n\nThe Settings scene will automatically set up the standard preferences command in the app menu and also give the window the correct style treatment.\n\nSwiftUI's scene APIs also support document-based apps like this app that I built for drawing vector shapes.\n\nNew this year is the DocumentGroup scene type, which automatically manages opening, editing and saving document-based scenes, supported on iOS, iPadOS and macOS.\n\nOn iOS and iPadOS, DocumentGroup will automatically present a document browser if no other main interface is provided.\n\nAnd on the Mac, DocumentGroup will open a different window for each new document, and also automatically add commands to the main menu for common document actions.\n\nSpeaking of menu commands, SwiftUI lets you add additional commands as well using the new commands modifier.\n\nFor example, here I've added a custom shape menu for adding new shapes to the canvas. macOS will automatically add custom menus in the correct section of the main menu and will show their keyboard shortcuts which we assigned using the new keyboardShortcut view modifier.\n\nCommands API has a lot more to offer than what we've shown here, such as being able to target commands based on user focus. It's really fun to work with. You can check out our reference documentation to learn more.\n\nThere's a lot more to say about apps and scenes, and we've prepared a few other talks to help you dig deeper into these new APIs. \"App Essentials in SwiftUI\" explains how views, scenes and apps all work together in more depth. And \"Document-Based Apps in SwiftUI\" dives deep into how to open and manage documents in your app.\n\nTo help you build these new apps, we've also updated the \"new project\" experience in Xcode by adding new multi-platform templates specifically for SwiftUI apps.\n\nThese new templates are optimized for multi-platform code, automatically setting up groups for shared code as well as platform-specific components and assets.\n\nAnother part of the project experience we're extending is how you configure your app's launch screen.\n\nNew this year is the Launch Screen Info.plist key.\n\nThis allows you to declare various combinations of standard launch screen components such as default images, background colors and empty top and bottom bars like I've configured here.\n\nYou may already be using a storyboard for your launch screen, which still works great, and there's no reason to switch. But for new SwiftUI projects that otherwise don't use storyboards, Launch Screen configurations are a simple alternative. Now let's talk about widgets, an exciting new feature on iOS, iPadOS and macOS.\n\nWidgets are built exclusively with SwiftUI.\n\nYou build widgets just like apps and views using a custom struct conforming to the new Widget protocol.\n\nYou can make many different types of widgets, like this one that periodically recommends a new album for me to listen to.\n\nWidgets can also be configured with other kinds of data such as Siri intents.\n\nThere's a lot to cover when it comes to building widgets, and we have several talks to help you get started. I'd recommend watching \"Build SwiftUI Views for Widgets\" to learn more.\n\nAnd finally, you can now use SwiftUI to build custom complications for Apple Watch. You can build a full-color complication like this weekly coffee chart I made and also customize how it looks within a tinted watch face, like this cool blue tint that I like to use.\n\nTo learn more, check out \"Build Complications in SwiftUI,\" or if you're new to building complications, I'd recommend starting with \"Creating Complications on Apple Watch.\" Next, let's talk about improvements to displaying lists and collections.\n\nLists are a vital component of many apps, often representing the primary interface that users interact with.\n\nIn this release, lists are gaining some great new features. I'm especially excited about the new support for outlines.\n\nRegular lists enable concise declarations of dynamic, data-driven content.\n\nBy providing a children key path to its initializer, a list can now build out recursive outlines of content. By default, this shows up using the expected system-standard styling on macOS... and on iOS and iPadOS.\n\nWe hope that easy-to-use outlines can help reduce the need for disruptive push-and-pop navigation patterns within content-focused apps. Along with lists and outlines, it's also common to show collections of content in other kinds of scrollable layouts such as grids.\n\nThis year, SwiftUI is adding support for lazy-loading grid layouts which can be composed with scroll views to create smooth-scrolling grids of content.\n\nGrids are powerful layouts that support a variety of different configurations, such as adapting the number of columns to fit the available space like we see here in both landscape and portrait.\n\nOr forcing a fixed number of columns that can each have their own sizing parameters, like this example that sticks with four columns in every orientation. And, of course, SwiftUI also supports horizontally scrolling grids. We're also exposing lazy-loading versions of the existing vertical and horizontal stack layouts, which are great for building custom scrollable layouts like this asymmetric gallery of images. Let's take a closer look.\n\nHere we're using a lazy vertical stack containing all of our gallery content.\n\nWe're also using the new view builder support for switch statements, allowing us to easily alternate between different image layouts within the stack such as the single large image shown at the top...\n\nthe asymmetric groups of three images...\n\nand the shorter rows of smaller images.\n\nTogether, composed with a lazy-loading vertically scrolling stack, they form a seamless gallery. Lists and collections are powerful features of SwiftUI, and we've only scratched the surface of what they're capable of in this talk. To learn more, you should really check out our talk on stacks, grids and outlines. And now to talk about toolbars and controls, I'll hand things over to Taylor. Thank you, Matt. It is so cool to see how easy it is to have our app's model come to life using SwiftUI with things like the new DocumentGroup and new collection views. Now let's jump into the powerful toolbar support in SwiftUI and new ways to customize controls. Toolbars and apps across our platforms have some amazing new updates, from their beautiful new look in macOS Big Sur to the updated iPad system experience to the primary actions in watchOS. And this year, SwiftUI has a new API for constructing all of these using the new toolbar modifier.\n\nToolbar items consists of the same views you use throughout the rest of SwiftUI, in this case, a button.\n\nThey'll be placed in idiomatic locations by default but can be explicitly customized through the use of toolbar items. In this case, the primary action is the default placement on watchOS, but there are other placements as well. For instance, confirmation and cancellation modal actions. These are examples of semantic placements where you're describing to SwiftUI the role that these toolbar items have, and SwiftUI automatically figures out the right spot. Another example is the principal placement to give an item prominence in your app, as you see here on iPad...\n\nand on macOS.\n\nToolbar items can have positional placements where you want to have that extra level of design control over where your items are placed. Particularly in narrow size classes, it's common to have items in bottom toolbars, and the literal bottomBar placement allows you to explicitly specify that.\n\nYou've probably noticed in a few of these examples the use of a new label view in SwiftUI. Let's take a closer look at that. This is a combined representation of a title and an icon that can be used to label UI elements. Here we have a string used as a localization key for its title and the name of a system image, or SF Symbol. And this year, not only are symbols available on macOS, but there are hundreds of new ones available for your apps to use. The \"SF Symbols 2.0\" talk goes into more detail on all the new enhancements to symbols this year. This construction of Label is actually a convenience for its full form, which is using any view for that title and icon.\n\nAnd its power comes from the semantics it provides for that title and icon, so they can be treated appropriately based on where they're used. So, returning to our toolbar example, in the context of a toolbar, by default it'll just be the icon visually presented as that button's label and the title used for accessibility purposes.\n\nThis behavior extends from toolbars, to context menus, to lists.\n\nNow, this list contains multiple rows of labels. The titles are perfectly aligned, regardless of image size and the power of Labels really shines when using different dynamic type sizes. This is showing the layout for the default large size category and as that changes to extra extra large, both the icon and title update automatically, including nicely reflowing the text and growing the list rows. An even further specialization happens at the larger accessibility sizes.\n\nAt those, the labels have updated text wrapping around the icon to maximize the amount of visible text.\n\nNow, with contexts like toolbars having clean, icon-only styles of labeling elements, providing additional help or context for those is more important than ever.\n\nWith the new help modifier, you can attach these descriptions of what effect a control will have and that will manifest as Tool Tips on macOS.\n\nWhat's really cool is that this modifier is available on all platforms as it also provides an accessibility hint to provide an even better voice over experience for your app everywhere. Here we can see a similar experience for an app on the phone for that same toolbar item. Progress button. Record new progress entry. It is so cool how our SwiftUI declarations can naturally improve the experience of our app for everyone.\n\nNow, another new way of bringing more flexibility and power to how people interact with your controls is using the keyboard shortcut modifier. These are most often used for scene commands as it's critical for allowing those commands to be accessible via keyboard shortcut on iPad and on macOS through the main menu, like Matt showed earlier.\n\nHowever, keyboard shortcuts can also be used for other controls that are shown on screen, such as creating Cancel and default action buttons that have keyboard shortcuts of Escape and Return keys.\n\nFrom keyboards, to TV remotes, to the watchOS digital crown, focus drives how these indirect inputs are routed in your app. And using the new default focus support, your app can now control where focus starts on screen and how that default might change alongside your app state. The \"SwiftUI for tvOS\" session goes into more detail on using that new support, as well as other tips for crafting a great tvOS app using SwiftUI.\n\nLast but not least, there are a couple of new controls that you can now use throughout your app. First, there are progress views. These can be used to display determinate and indeterminate progress over time. There are both linear and circular style progress views, the latter enabling everyone's favorite, spinning style, as a display of indeterminate progress.\n\nA similar new control are Gauges. Gauges are used to indicate the level of a value relative to some overall capacity.\n\nHere I have a circular watchOS gauge for tracking the acidity level of my garden's soil.\n\nGauge has additional optional customizations. Tomatoes are finicky enough to where I'd really like to see the exact pH level at a glance. So I can add a current value label to allow that to be displayed.\n\nGauge can also have minimum and maximum value labels. In some cases, those might be image icons, but here I'm just gonna display those pH levels as text.\n\nNow, this code snippet also highlights the new multiple trailing closure syntax in Swift. It allowed the expression of our gauge to grow naturally as it gained additional complexity. It is really nice having a new, expressive way of creating toolbars across all of the platforms my apps support, plus these new means of really fine-tuning the behavior of controls both in and out of toolbars.\n\nNext up, let's take a look at new ways of crafting immersive and fun experiences using SwiftUI. macOS Big Sur has a gorgeous revamp to Notification Center and the new Control Center in the menu bar, both built using SwiftUI.\n\nControl Center features these smooth animations in and out of its different modules using a new feature in SwiftUI that you can use in your own apps.\n\nHere I built a little prototype of UI to gather up my favorite albums. It consists of a scrolling grid of albums and a row of the selected ones. Now, on selection, rather than the albums just popping into that row, I'd really like them to fluidly transition from the grid. And using matched geometry effect, it's really easy. I can apply the matched geometry effect modifier to the albums in both the grid and the selected album row using the album's identifier as the identifier to connect the two views, as well as the namespace that those identifiers are relative to. In this case, it's the namespace associated with the containing view.\n\nAnd that's really all it takes to create this effect. As an album is removed from one section and inserted to the other, SwiftUI will automatically interpolate their frames as a seamless transition.\n\nAnother fantastic new tool is ContainerRelativeShape. This is a new shape type that will take on a similar path of the nearest containing shape. We can see the effect here in a widget for our favorite album.\n\nThe clip shape on our album artwork automatically took on a concentric corner radius relative to the shape of the widget and so fits perfectly within it.\n\nWe can really get a feel for how cool this is by changing that padding, which effectively changes the offset to that outer container shape, and thus the clipping of our view, using ContainerRelativeShape, reacts beautifully...\n\nautomatically maintaining that concentricity based on its offset.\n\nThere are a few other enhancements to refine the experience of text related elements as well. Custom fonts will automatically scale with dynamic type changes.\n\nFurther, now that images can be embedded within text, they'll act as a unified part of that text, including reacting to dynamic type. And for any custom non-text metrics, such as for layout, there's a new scaled metric property wrapper that automatically scales some base value against the current dynamic type size.\n\nAll together, these make it so easy to create responsive, custom layouts that react well in these larger accessibility sizes.\n\nThere'll be another talk that goes into detail on this, as well as other advanced font and typographic features that can be used to really make your app shine.\n\nNow, these were a few of the new tools for building creative and reactive custom views. But the enhancements to styling your app don't stop there. Even when using system controls, you can customize them to look and feel at home on your app and make your app stand out from the rest by using a custom accent color.\n\nNew this year is the ability to customize that accent color on macOS and new support for customizing that accent color directly in the asset catalog in Xcode 12. This lets you easily specify that color for all of the platforms that your app supports.\n\nNow, this is great for applying a broad theme color across your app. But there are also cases where you might wanna specifically customize the tint of a single control.\n\nNow, by default, cyber icons on iPadOS and macOS follow the app accent color. With a new listItemTint modifier you can customize the tint of those icons per item or even for an entire section.\n\nThe same affect applies to macOS sidebars where these modifiers also react appropriately for changes to the system accent color.\n\nThis same modifier also applies to watchOS where it's used to tint the standard platter background.\n\nAnd we've brought this tinting support to other controls as well.\n\nUsing new style customizations, controls like buttons and toggles can now be explicitly tinted. Here, the switch fill is customized to follow the overall themed accent color rather than the default green. Now, all of these new views and interactions enable even more polished and fun experiences within your app.\n\nAnd last, but certainly not least, let's look at new ways your app can integrate and take advantage of functionality and services provided by the system.\n\nThis year, SwiftUI has a first-class API for opening URLs, available on all platforms.\n\nOne form of this is in a new Link view, which takes the URL to open and the label of the link.\n\nIt does what you'd expect, creating a visual element with that label and opening that URL with the default web browser.\n\nBut in addition, it can also open universal links directly into other apps. In this case, News.\n\nLinks also even work within widgets, where they can even link directly back into content within your main app.\n\nNow, in the context of apps, there are cases where URLs need to be programmatically opened. For these advanced cases, there's also an openURL action in the environment, which can be called with the URL to open in an optional completion handler.\n\nBecause it's in the context of a specific view, SwiftUI automatically opens that URL relative to its containing window. In an update to iPadOS 13, SwiftUI gained support for enabling your app to both drag to other apps and receive drops from those apps, making your iPad app even more powerful and integrated.\n\nIn iOS 14 and macOS Big Sur, this API is built on top of a new framework that enables stronger typed identifiers for the contents being dragged, using the new Uniform Type Identifiers framework.\n\nThis has been adopted throughout SwiftUI, allowing you to take advantage of its features throughout your app, from extending it with your app's custom exported or imported types to introspecting a type. For instance, getting its human presentable description or validating its conformance.\n\nThe \"Document-Based Apps in SwiftUI\" talk has more details, such as the differences between imported and exported types. And there's also some great documentation available on Apple's website.\n\nOne last example of enabling your app to integrate with other services is the Sign in with Apple button.\n\nThis is again a first-class SwiftUI API provided by AuthenticationServices and available on every platform. What's really cool is that simply by importing AuthenticationServices and SwiftUI together, you get these new APIs. There's no new import or framework needed.\n\nAnd this is just one example of the many Apple frameworks that are now providing SwiftUI views and modifiers. From video players, to maps, to app clip overlays, it's even easier to bring these advanced features into your SwiftUI app.\n\nMany of these are fully multi-platform including natively on watchOS, meaning when you learn how to use these frameworks for one platform, you can apply that anywhere. And that was a quick summary of some of the new ways your apps can integrate and take advantage of the various system features now available in SwiftUI. We've run through a lot of new features and APIs and like Matt mentioned in the beginning, there's just so much more that we didn't have time to talk about. But as one last callout, throughout the talk we came across a few examples where our app's SwiftUI code was made even better from improvements to the language itself. This year's \"What's New in Swift\" goes into more details on all of the awesome changes in Swift. It has more examples of syntax refinements like builder inference and support for switch and if let inside of builders.\n\nThe compiler now has even better diagnostics that helps more quickly pinpoint build errors in your code. And finally, improved performance, such as reductions of code size for your SwiftUI apps and faster code completion.\n\nAnd these are the types of things that make using SwiftUI that much more enjoyable. We are so excited to share all this with you this year, but lastly, thank you. Thank you for the excitement and passion we've seen from the community. Thank you for the reports on Feedback Assistant, the commentary on social media, the discourse on the forums, the many days of tutorials, and all of the amazing prototypes and explorations people have built. We were just blown away by the excitement we've seen and are really looking forward to what's yet to come. [chimes]",
    "segments": []
  },
  "codeExamples": [
    {
      "timestamp": "1:26",
      "title": "Hello World",
      "language": "swift",
      "code": "@main\nstruct HelloWorld: App {\n    var body: some Scene {\n        WindowGroup {\n            Text(\"Hello, world!\").padding()\n        }\n    }\n}"
    },
    {
      "timestamp": "1:56",
      "title": "Book Club app",
      "language": "swift",
      "code": "@main\nstruct BookClubApp: App {\n    @StateObject private var store = ReadingListStore()\n\n    var body: some Scene {\n        WindowGroup {\n            ReadingListViewer(store: store)\n        }\n    }\n}\n\nstruct ReadingListViewer: View {\n    @ObservedObject var store: ReadingListStore\n\n    var body: some View {\n        NavigationView {\n            List(store.books) { book in\n                Text(book.title)\n            }\n            .navigationTitle(\"Currently Reading\")\n        }\n    }\n}\n\nclass ReadingListStore: ObservableObject {\n    init() {}\n\n    var books = [\n        Book(title: \"Book #1\", author: \"Author #1\"),\n        Book(title: \"Book #2\", author: \"Author #2\"),\n        Book(title: \"Book #3\", author: \"Author #3\")\n    ]\n}\n\nstruct Book: Identifiable {\n    let id = UUID()\n    let title: String\n    let author: String\n}"
    },
    {
      "timestamp": "4:46",
      "title": "Settings",
      "language": "swift",
      "code": "@main\nstruct BookClubApp: App {\n    @StateObject private var store = ReadingListStore()\n\n    @SceneBuilder var body: some Scene {\n        WindowGroup {\n            ReadingListViewer(store: store)\n        }\n        \n    #if os(macOS)\n        Settings {\n            BookClubSettingsView()\n        }\n    #endif\n    }\n}\n\nstruct BookClubSettingsView: View {\n    var body: some View {\n        Text(\"Add your settings UI here.\")\n            .padding()\n    }\n}\n\nstruct ReadingListViewer: View {\n    @ObservedObject var store: ReadingListStore\n\n    var body: some View {\n        NavigationView {\n            List(store.books) { book in\n                Text(book.title)\n            }\n            .navigationTitle(\"Currently Reading\")\n        }\n    }\n}\n\nclass ReadingListStore: ObservableObject {\n    init() {}\n\n    var books = [\n        Book(title: \"Book #1\", author: \"Author #1\"),\n        Book(title: \"Book #2\", author: \"Author #2\"),\n        Book(title: \"Book #3\", author: \"Author #3\")\n    ]\n}\n\nstruct Book: Identifiable {\n    let id = UUID()\n    let title: String\n    let author: String\n}"
    },
    {
      "timestamp": "5:10",
      "title": "Document groups",
      "language": "swift",
      "code": "import SwiftUI\nimport UniformTypeIdentifiers\n\n@main\nstruct ShapeEditApp: App {\n    var body: some Scene {\n        DocumentGroup(newDocument: ShapeDocument()) { file in\n            DocumentView(document: file.$document)\n        }\n    }\n}\n\nstruct DocumentView: View {\n    @Binding var document: ShapeDocument\n    \n    var body: some View {\n        Text(document.title)\n            .frame(width: 300, height: 200)\n    }\n}\n\nstruct ShapeDocument: Codable {\n    var title: String = \"Untitled\"\n}\n\nextension UTType {\n    static let shapeEditDocument =\n        UTType(exportedAs: \"com.example.ShapeEdit.shapes\")\n}\n\nextension ShapeDocument: FileDocument {\n    static var readableContentTypes: [UTType] { [.shapeEditDocument] }\n    \n    init(fileWrapper: FileWrapper, contentType: UTType) throws {\n        let data = fileWrapper.regularFileContents!\n        self = try JSONDecoder().decode(Self.self, from: data)\n    }\n\n    func write(to fileWrapper: inout FileWrapper, contentType: UTType) throws {\n        let data = try JSONEncoder().encode(self)\n        fileWrapper = FileWrapper(regularFileWithContents: data)\n    }\n}"
    },
    {
      "timestamp": "5:49",
      "title": "Custom Commands",
      "language": "swift",
      "code": "import SwiftUI\nimport UniformTypeIdentifiers\n\n@main\nstruct ShapeEditApp: App {\n    var body: some Scene {\n        DocumentGroup(newDocument: ShapeDocument()) { file in\n            DocumentView(document: file.$document)\n        }\n        .commands {\n            CommandMenu(\"Shapes\") {\n                Button(\"Add Shape...\", action: addShape)\n                    .keyboardShortcut(\"N\")\n                Button(\"Add Text\", action: addText)\n                    .keyboardShortcut(\"T\")\n            }\n        }\n    }\n    \n    func addShape() {}\n    func addText() {}\n}\n\nstruct DocumentView: View {\n    @Binding var document: ShapeDocument\n    \n    var body: some View {\n        Text(document.title)\n            .frame(width: 300, height: 200)\n    }\n}\n\nstruct ShapeDocument: Codable {\n    var title: String = \"Untitled\"\n}\n\nextension UTType {\n    static let shapeEditDocument =\n        UTType(exportedAs: \"com.example.ShapeEdit.shapes\")\n}\n\nextension ShapeDocument: FileDocument {\n    static var readableContentTypes: [UTType] { [.shapeEditDocument] }\n    \n    init(fileWrapper: FileWrapper, contentType: UTType) throws {\n        let data = fileWrapper.regularFileContents!\n        self = try JSONDecoder().decode(Self.self, from: data)\n    }\n\n    func write(to fileWrapper: inout FileWrapper, contentType: UTType) throws {\n        let data = try JSONEncoder().encode(self)\n        fileWrapper = FileWrapper(regularFileWithContents: data)\n    }\n}"
    },
    {
      "timestamp": "7:55",
      "title": "Widgets",
      "language": "swift",
      "code": "import SwiftUI\nimport WidgetKit\n\n@main\nstruct RecommendedAlbum: Widget {\n    var body: some WidgetConfiguration {\n        StaticConfiguration(\n            kind: \"RecommendedAlbum\",\n            provider: Provider(),\n            placeholder: PlaceholderView()\n        ) { entry in\n            AlbumWidgetView(album: entry.album)\n        }\n        .configurationDisplayName(\"Recommended Album\")\n        .description(\"Your recommendation for the day.\")\n    }\n}\n\nstruct AlbumWidgetView: View {\n    var album: Album\n\n    var body: some View {\n        Text(album.title)\n    }\n}\n\nstruct PlaceholderView: View {\n    var body: some View {\n        Text(\"Placeholder View\")\n    }\n}\n\nstruct Album {\n    var title: String\n}\n\nstruct Provider: TimelineProvider {\n    struct Entry: TimelineEntry {\n        var album: Album\n        var date: Date\n    }\n\n    public func snapshot(with context: Context, completion: @escaping (Entry) -> ()) {\n        let entry = Entry(album: Album(title: \"Untitled\"), date: Date())\n        completion(entry)\n    }\n\n    public func timeline(with context: Context, completion: @escaping (Timeline<Entry>) -> ()) {\n        var entries: [Entry] = []\n\n        // Generate a timeline consisting of five entries an hour apart, starting from the current date.\n        let currentDate = Date()\n        for hourOffset in 0 ..< 5 {\n            let entryDate = Calendar.current.date(byAdding: .hour, value: hourOffset, to: currentDate)!\n            let entry = Entry(album: Album(title: \"Untitled #\\(hourOffset)\"), date: entryDate)\n            entries.append(entry)\n        }\n\n        let timeline = Timeline(entries: entries, policy: .atEnd)\n        completion(timeline)\n    }\n}"
    },
    {
      "timestamp": "8:31",
      "title": "Complications using SwiftUI",
      "language": "swift",
      "code": "struct CoffeeHistoryChart: View {\n    var body: some View {\n        VStack {\n            ComplicationHistoryLabel {\n                Text(\"Weekly Coffee\")\n                    .complicationForeground()\n            }\n            HistoryChart()\n        }\n        .complicationChartFont()\n    }\n}\n\nstruct ComplicationHistoryLabel: View { ... }\nstruct HistoryChart: View { ... }\n\nextension View {\n    func complicationChartFont() -> some View { ... }\n}"
    },
    {
      "timestamp": "9:22",
      "title": "Outlines",
      "language": "swift",
      "code": "struct OutlineContentView: View {\n    var graphics: [Graphic]\n    \n    var body: some View {\n        List(graphics, children: \\.children) { graphic in\n            GraphicRow(graphic)\n        }\n        .listStyle(SidebarListStyle())\n    }\n}\n\nstruct Graphic: Identifiable {\n    var id: String\n    var name: String\n    var icon: Image\n    var children: [Graphic]?\n}\n\nstruct GraphicRow: View {\n    var graphic: Graphic\n    \n    init(_ graphic: Graphic) {\n        self.graphic = graphic\n    }\n    \n    var body: some View {\n        Label {\n            Text(graphic.name)\n        } icon: {\n            graphic.icon\n        }\n    }\n}"
    },
    {
      "timestamp": "10:09",
      "title": "Adaptive grids",
      "language": "swift",
      "code": "struct ContentView: View {\n    var items: [Item]\n\n    var body: some View {\n        ScrollView {\n            LazyVGrid(columns: [GridItem(.adaptive(minimum: 176))]) {\n                ForEach(items) { item in\n                    ItemView(item: item)\n                }\n            }\n            .padding()\n        }\n    }\n}\n\nstruct Item: Identifiable {\n    var name: String\n    var id = UUID()\n    \n    var icon: Image {\n        Image(systemName: name)\n    }\n    var color: Color {\n        colors[colorIndex % (colors.count - 1)]\n    }\n\n    private static var nextColorIndex: Int = 0\n    private var colorIndex: Int\n\n    init(name: String) {\n        self.name = name\n\n        colorIndex = Self.nextColorIndex\n        Self.nextColorIndex += 1\n    }\n}\n\nstruct ItemView: View {\n    var item: Item\n\n    var body: some View {\n        ZStack {\n            RoundedRectangle(cornerRadius: 8, style: .continuous)\n                .fill()\n                .layoutPriority(1)\n                .foregroundColor(item.color)\n            item.icon\n                .resizable()\n                .aspectRatio(contentMode: .fit)\n                .padding(.all, 16)\n                .foregroundColor(.white)\n        }\n        .frame(width: 176, height: 110)\n    }\n}"
    },
    {
      "timestamp": "10:28",
      "title": "Fixed-column grids",
      "language": "swift",
      "code": "struct ContentView: View {\n    var items: [Item]\n\n    var body: some View {\n        ScrollView {\n            LazyVGrid(columns: Array(repeating: GridItem(), count: 4)]) {\n                ForEach(items) { item in\n                    ItemView(item: item)\n                }\n            }\n            .padding()\n        }\n    }\n}\n\nstruct Item: Identifiable {\n    var name: String\n    var id = UUID()\n    \n    var icon: Image {\n        Image(systemName: name)\n    }\n    var color: Color {\n        colors[colorIndex % (colors.count - 1)]\n    }\n\n    private static var nextColorIndex: Int = 0\n    private var colorIndex: Int\n\n    init(name: String) {\n        self.name = name\n\n        colorIndex = Self.nextColorIndex\n        Self.nextColorIndex += 1\n    }\n}\n\nstruct ItemView: View {\n    var item: Item\n\n    var body: some View {\n        ZStack {\n            RoundedRectangle(cornerRadius: 8, style: .continuous)\n                .fill()\n                .layoutPriority(1)\n                .foregroundColor(item.color)\n            item.icon\n                .resizable()\n                .aspectRatio(contentMode: .fit)\n                .padding(.all, 16)\n                .foregroundColor(.white)\n        }\n        .frame(width: 176, height: 110)\n    }\n}"
    },
    {
      "timestamp": "10:38",
      "title": "Horizontal grids",
      "language": "swift",
      "code": "struct ContentView: View {\n    var items: [Item]\n\n    var body: some View {\n        ScrollView(.horizontal) {\n            LazyHGrid(rows: [GridItem(.adaptive(minimum: 110))]) {\n                ForEach(items) { item in\n                    ItemView(item: item)\n                }\n            }\n            .padding()\n        }\n    }\n}\n\nstruct Item: Identifiable {\n    var name: String\n    var id = UUID()\n    \n    var icon: Image {\n        Image(systemName: name)\n    }\n    var color: Color {\n        colors[colorIndex % (colors.count - 1)]\n    }\n\n    private static var nextColorIndex: Int = 0\n    private var colorIndex: Int\n\n    init(name: String) {\n        self.name = name\n        colorIndex = Self.nextColorIndex\n        Self.nextColorIndex += 1\n    }\n}\n\nstruct ItemView: View {\n    var item: Item\n\n    var body: some View {\n        ZStack {\n            RoundedRectangle(cornerRadius: 8, style: .continuous)\n                .fill()\n                .layoutPriority(1)\n                .foregroundColor(item.color)\n            item.icon\n                .resizable()\n                .aspectRatio(contentMode: .fit)\n                .padding(.all, 16)\n                .foregroundColor(.white)\n        }\n        .frame(width: 176, height: 110)\n    }\n}"
    },
    {
      "timestamp": "10:58",
      "title": "Lazy stacks",
      "language": "swift",
      "code": "struct WildlifeList: View {\n    var rows: [ImageRow]\n\n    var body: some View {\n        ScrollView {\n            LazyVStack(spacing: 2) {\n                ForEach(rows) { row in\n                    switch row.content {\n                    case let .singleImage(image):\n                        SingleImageLayout(image: image)\n                    case let .imageGroup(images):\n                        ImageGroupLayout(images: images)\n                    case let .imageRow(images):\n                        ImageRowLayout(images: images)\n                    }\n                }\n            }\n        }\n    }\n}"
    },
    {
      "timestamp": "12:24",
      "title": "Toolbar modifier",
      "language": "swift",
      "code": "struct ContentView: View {\n    var body: some View {\n        List {\n            Text(\"Book List\")\n        }\n        .toolbar {\n            Button(action: recordProgress) {\n                Label(\"Record Progress\", systemImage: \"book.circle\")\n            }\n        }\n    }\n\n    private func recordProgress() {}\n}"
    },
    {
      "timestamp": "12:40",
      "title": "ToolbarItem",
      "language": "swift",
      "code": "struct ContentView: View {\n    var body: some View {\n        List {\n            Text(\"Book List\")\n        }\n        .toolbar {\n            ToolbarItem(placement: .primaryAction) {\n                Button(action: recordProgress) {\n                    Label(\"Record Progress\", systemImage: \"book.circle\")\n                }\n            }\n        }\n    }\n\n    private func recordProgress() {}\n}"
    },
    {
      "timestamp": "12:47",
      "title": "Confirmation and cancellation toolbar placements",
      "language": "swift",
      "code": "struct ContentView: View {\n    var body: some View {\n        Form {\n            Slider(value: .constant(0.39))\n        }\n        .toolbar {\n            ToolbarItem(placement: .confirmationAction) {\n                Button(\"Save\", action: saveProgress)\n            }\n            ToolbarItem(placement: .cancellationAction) {\n                Button(\"Cancel\", action: dismissSheet)\n            }\n        }\n    }\n\n    private func saveProgress() {}\n    private func dismissSheet() {}\n}"
    },
    {
      "timestamp": "13:00",
      "title": "Principal toolbar placement",
      "language": "swift",
      "code": "struct ContentView: View {\n    enum ViewMode {\n        case details\n        case notes\n    }\n\n    @State private var viewMode: ViewMode = .details\n\n    var body: some View {\n        List {\n            Text(\"Book Detail\")\n        }\n        .toolbar {\n            ToolbarItem(placement: .principal) {\n                Picker(\"View\", selection: $viewMode) {\n                    Text(\"Details\").tag(ViewMode.details)\n                    Text(\"Notes\").tag(ViewMode.notes)\n                }\n            }\n        }\n    }\n}"
    },
    {
      "timestamp": "13:17",
      "title": "Bottom bar toolbar placement",
      "language": "swift",
      "code": "struct ContentView: View {\n    var body: some View {\n        List {\n            Text(\"Book Detail\")\n        }\n        .toolbar {\n            ToolbarItem {\n                Button(action: recordProgress) {\n                    Label(\"Progress\", systemImage: \"book.circle\")\n                }\n            }\n            ToolbarItem(placement: .bottomBar) {\n                Button(action: shareBook) {\n                    Label(\"Share\", systemImage: \"square.and.arrow.up\")\n                }\n            }\n        }\n    }\n\n    private func recordProgress() {}\n    private func shareBook() {}\n}"
    },
    {
      "timestamp": "13:38",
      "title": "Label",
      "language": "swift",
      "code": "Label(\"Progress\", systemImage: \"book.circle\")"
    },
    {
      "timestamp": "14:06",
      "title": "Label expanded form",
      "language": "swift",
      "code": "Label {\n    Text(\"Progress\")\n} icon: {\n    Image(systemName: \"book.circle\")\n}"
    },
    {
      "timestamp": "14:36",
      "title": "Context menu Labels",
      "language": "swift",
      "code": "struct ContentView: View {\n    var body: some View {\n        List {\n            Text(\"Book List Row\")\n            .contextMenu {\n                Button(action: recordProgress) {\n                    Label(\"Progress\", systemImage: \"book.circle\")\n                }\n                Button(action: addToFavorites) {\n                    Label(\"Add to Favorites\", systemImage: \"heart\")\n                }\n                Button(action: shareBook) {\n                    Label(\"Share\", systemImage: \"square.and.arrow.up\")\n                }\n            }\n        }\n    }\n\n    private func recordProgress() {}\n    private func addToFavorites() {}\n    private func shareBook() {}\n}"
    },
    {
      "timestamp": "14:39",
      "title": "List Labels",
      "language": "swift",
      "code": "struct ContentView: View {\n    var body: some View {\n        List {\n            Group {\n                Label(\"Introducing SwiftUI\", systemImage: \"hand.wave\")\n                Label(\"SwiftUI Essentials\", systemImage: \"studentdesk\")\n                Label(\"Data Essentials in SwiftUI\", systemImage: \"flowchart\")\n                Label(\"App Essentials in SwiftUI\", systemImage: \"macwindow.on.rectangle\")\n            }\n            Group {\n                Label(\"Build Document-based apps in SwiftUI\", systemImage: \"doc\")\n                Label(\"Stacks, Grids, and Outlines\", systemImage: \"list.bullet.rectangle\")\n                Label(\"Building Custom Views in SwiftUI\", systemImage: \"sparkles\")\n                Label(\"Build SwiftUI Apps for tvOS\", systemImage: \"tv\")\n                Label(\"Build SwiftUI Views for Widgets\", systemImage: \"square.grid.2x2.fill\")\n                Label(\"Create Complications for Apple Watch\", systemImage: \"gauge\")\n                Label(\"SwiftUI on All Devices\", systemImage: \"laptopcomputer.and.iphone\")\n                Label(\"Integrating SwiftUI\", systemImage: \"rectangle.connected.to.line.below\")\n            }\n        }\n    }\n}"
    },
    {
      "timestamp": "15:28",
      "title": "Help modifier",
      "language": "swift",
      "code": "struct ContentView: View {\n    var body: some View {\n        Button(action: recordProgress) {\n            Label(\"Progress\", systemImage: \"book.circle\")\n        }\n        .help(\"Record new progress entry\")\n    }\n\n    private func recordProgress() {}\n}"
    },
    {
      "timestamp": "16:12",
      "title": "Keyboard shortcut modifier",
      "language": "swift",
      "code": "@main\nstruct BookClubApp: App {\n    var body: some Scene {\n        WindowGroup {\n            List {\n                Text(\"Reading List Viewer\")\n            }\n        }\n        .commands {\n            Button(\"Previous Book\", action: selectPrevious)\n                .keyboardShortcut(\"[\")\n            Button(\"Next Book\", action: selectNext)\n                .keyboardShortcut(\"]\")\n        }\n    }\n\n    private func selectPreviousBook() {}\n    private func selectNextBook() {}\n}"
    },
    {
      "timestamp": "16:28",
      "title": "Cancel and default action keyboard shortcuts",
      "language": "swift",
      "code": "struct ContentView: View {\n    var body: some View {\n        HStack {\n            Button(\"Cancel\", action: dismissSheet)\n                .keyboardShortcut(.cancelAction)\n\n            Button(\"Save\", action: saveProgress)\n                .keyboardShortcut(.defaultAction)\n        }\n    }\n\n    private func dismissSheet() {}\n    private func saveProgress() {}\n}"
    },
    {
      "timestamp": "17:08",
      "title": "ProgressView",
      "language": "swift",
      "code": "struct ContentView: View {\n    var percentComplete: Double\n\n    var body: some View {\n        ProgressView(\"Downloading Photo\", value: percentComplete)\n    }\n}"
    },
    {
      "timestamp": "17:19",
      "title": "Circular ProgressView",
      "language": "swift",
      "code": "struct ContentView: View {\n    var percentComplete: Double\n\n    var body: some View {\n        ProgressView(\"Downloading Photo\", value: percentComplete)\n            .progressViewStyle(CircularProgressViewStyle())\n    }\n}"
    },
    {
      "timestamp": "17:25",
      "title": "Activity indicator ProgressView",
      "language": "swift",
      "code": "struct ContentView: View {\n    var body: some View {\n        ProgressView()\n    }\n}"
    },
    {
      "timestamp": "17:32",
      "title": "Gauge",
      "language": "swift",
      "code": "struct ContentView: View {\n    var acidity: Double\n\n    var body: some View {\n        Gauge(value: acidity, in: 3...10) {\n            Label(\"Soil Acidity\", systemImage: \"drop.fill\")\n                .foregroundColor(.green)\n        }\n    }\n}"
    },
    {
      "timestamp": "17:52",
      "title": "Gauge with current value label",
      "language": "swift",
      "code": "struct ContentView: View {\n    var acidity: Double\n\n    var body: some View {\n        Gauge(value: acidity, in: 3...10) {\n            Label(\"Soil Acidity\", systemImage: \"drop.fill\")\n                .foregroundColor(.green)\n        } currentValueLabel: {\n            Text(\"\\(acidity, specifier: \"%.1f\")\")\n        }\n    }\n}"
    },
    {
      "timestamp": "18:00",
      "title": "Gauge with minimum and maximum value labels",
      "language": "swift",
      "code": "struct ContentView: View {\n    var acidity: Double\n\n    var body: some View {\n        Gauge(value: acidity, in: 3...10) {\n            Label(\"Soil Acidity\", systemImage: \"drop.fill\")\n                .foregroundColor(.green)\n        } currentValueLabel: {\n            Text(\"\\(acidity, specifier: \"%.1f\")\")\n        } minimumValueLabel: {\n            Text(\"3\")\n        } maximumValueLabel: {\n            Text(\"10\")\n        }\n    }\n}"
    },
    {
      "timestamp": "18:57",
      "title": "Initial Album Picker",
      "language": "swift",
      "code": "struct ContentView: View {\n    @State private var selectedAlbumIDs: Set<Album.ID> = []\n\n    var body: some View {\n        VStack(spacing: 0) {\n            ScrollView {\n                albumGrid.padding(.horizontal)\n            }\n\n            Divider().zIndex(-1)\n\n            selectedAlbumRow\n                .frame(height: AlbumCell.albumSize)\n                .padding(.top, 8)\n        }\n        .buttonStyle(PlainButtonStyle())\n    }\n\n    private var albumGrid: some View {\n        LazyVGrid(columns: [GridItem(.adaptive(minimum: AlbumCell.albumSize))], spacing: 8) {\n           ForEach(unselectedAlbums) { album in\n              Button(action: { select(album) }) {\n                 AlbumCell(album)\n              }\n           }\n        }\n    }\n\n    private var selectedAlbumRow: some View {\n        HStack {\n            ForEach(selectedAlbums) { album in\n                AlbumCell(album)\n            }\n        }\n    }\n\n    private var unselectedAlbums: [Album] {\n        Album.allAlbums.filter { !selectedAlbumIDs.contains($0.id) }\n    }\n    private var selectedAlbums: [Album] {\n        Album.allAlbums.filter { selectedAlbumIDs.contains($0.id) }\n    }\n\n    private func select(_ album: Album) {\n        withAnimation(.spring(response: 0.5)) {\n            _ = selectedAlbumIDs.insert(album.id)\n        }\n    }\n}\n\nstruct AlbumCell: View {\n    static let albumSize: CGFloat = 100\n\n    var album: Album\n\n    init(_ album: Album) {\n        self.album = album\n    }\n\n    var body: some View {\n        album.image\n            .frame(width: AlbumCell.albumSize, height: AlbumCell.albumSize)\n            .background(Color.pink)\n            .cornerRadius(6.0)\n    }\n}\n\nstruct Album: Identifiable {\n    static let allAlbums: [Album] = [\n        .init(name: \"Sample\", image: Image(systemName: \"music.note\")),\n        .init(name: \"Sample 2\", image: Image(systemName: \"music.note.list\")),\n        .init(name: \"Sample 3\", image: Image(systemName: \"music.quarternote.3\")),\n        .init(name: \"Sample 4\", image: Image(systemName: \"music.mic\")),\n        .init(name: \"Sample 5\", image: Image(systemName: \"music.note.house\")),\n        .init(name: \"Sample 6\", image: Image(systemName: \"tv.music.note\"))\n    ]\n\n    var name: String\n    var image: Image\n\n    var id: String { name }\n}"
    },
    {
      "timestamp": "19:17",
      "title": "Matched geometry effect Album Picker",
      "language": "swift",
      "code": "struct ContentView: View {\n    @Namespace private var namespace\n    @State private var selectedAlbumIDs: Set<Album.ID> = []\n\n    var body: some View {\n        VStack(spacing: 0) {\n            ScrollView {\n                albumGrid.padding(.horizontal)\n            }\n\n            Divider().zIndex(-1)\n\n            selectedAlbumRow\n                .frame(height: AlbumCell.albumSize)\n                .padding(.top, 8)\n        }\n        .buttonStyle(PlainButtonStyle())\n    }\n\n    private var albumGrid: some View {\n        LazyVGrid(columns: [GridItem(.adaptive(minimum: AlbumCell.albumSize))], spacing: 8) {\n           ForEach(unselectedAlbums) { album in\n              Button(action: { select(album) }) {\n                 AlbumCell(album)\n              }\n              .matchedGeometryEffect(id: album.id, in: namespace)\n           }\n        }\n    }\n\n    private var selectedAlbumRow: some View {\n        HStack {\n            ForEach(selectedAlbums) { album in\n                AlbumCell(album)\n                .matchedGeometryEffect(id: album.id, in: namespace)\n            }\n        }\n    }\n\n    private var unselectedAlbums: [Album] {\n        Album.allAlbums.filter { !selectedAlbumIDs.contains($0.id) }\n    }\n    private var selectedAlbums: [Album] {\n        Album.allAlbums.filter { selectedAlbumIDs.contains($0.id) }\n    }\n\n    private func select(_ album: Album) {\n        withAnimation(.spring(response: 0.5)) {\n            _ = selectedAlbumIDs.insert(album.id)\n        }\n    }\n}\n\nstruct AlbumCell: View {\n    static let albumSize: CGFloat = 100\n\n    var album: Album\n\n    init(_ album: Album) {\n        self.album = album\n    }\n\n    var body: some View {\n        album.image\n            .frame(width: AlbumCell.albumSize, height: AlbumCell.albumSize)\n            .background(Color.pink)\n            .cornerRadius(6.0)\n    }\n}\n\nstruct Album: Identifiable {\n    static let allAlbums: [Album] = [\n        .init(name: \"Sample\", image: Image(systemName: \"music.note\")),\n        .init(name: \"Sample 2\", image: Image(systemName: \"music.note.list\")),\n        .init(name: \"Sample 3\", image: Image(systemName: \"music.quarternote.3\")),\n        .init(name: \"Sample 4\", image: Image(systemName: \"music.mic\")),\n        .init(name: \"Sample 5\", image: Image(systemName: \"music.note.house\")),\n        .init(name: \"Sample 6\", image: Image(systemName: \"tv.music.note\"))\n    ]\n\n    var name: String\n    var image: Image\n\n    var id: String { name }\n}"
    },
    {
      "timestamp": "19:53",
      "title": "Container Relative Shape",
      "language": "swift",
      "code": "struct AlbumWidgetView: View {\n    var album: Album\n\n    var body: some View {\n        album.image\n            .clipShape(ContainerRelativeShape())\n            .padding()\n    }\n}\n\nstruct Album {\n    var name: String\n    var artist: String\n    var image: Image\n}"
    },
    {
      "timestamp": "20:34",
      "title": "Dynamic Type scaling",
      "language": "swift",
      "code": "struct ContentView: View {\n    var album: Album\n    @ScaledMetric private var padding: CGFloat = 10\n\n    var body: some View {\n        VStack {\n            Text(album.name)\n                .font(.custom(\"AvenirNext-Bold\", size: 30))\n\n            Text(\"\\(Image(systemName: \"music.mic\")) \\(album.artist)\")\n                .font(.custom(\"AvenirNext-Bold\", size: 17))\n\n        }\n        .padding(padding)\n        .background(RoundedRectangle(cornerRadius: 16, style: .continuous).fill(Color.purple))\n    }\n}\n\nstruct Album {\n    var name: String\n    var artist: String\n    var image: Image\n}"
    },
    {
      "timestamp": "22:08",
      "title": "Initial Sidebar List",
      "language": "swift",
      "code": "struct ContentView: View {\n    var body: some View {\n        NavigationView {\n            List {\n                Label(\"Menu\", systemImage: \"list.bullet\")\n\n                Label(\"Favorites\", systemImage: \"heart\")\n\n                Label(\"Rewards\", systemImage: \"seal\")\n\n                Section(header: Text(\"Recipes\")) {\n                    ForEach(1..<4) {\n                        Label(\"Recipes \\($0)\", systemImage: \"book.closed\")\n                    }\n                }\n            }\n            .listStyle(SidebarListStyle())\n        }\n    }\n}"
    },
    {
      "timestamp": "22:17",
      "title": "List Item Tint in Sidebars",
      "language": "swift",
      "code": "struct ContentView: View {\n    var body: some View {\n        NavigationView {\n            List {\n                Label(\"Menu\", systemImage: \"list.bullet\")\n\n                Label(\"Favorites\", systemImage: \"heart\")\n                    .listItemTint(.red)\n\n                Label(\"Rewards\", systemImage: \"seal\")\n                    .listItemTint(.purple)\n\n                Section(header: Text(\"Recipes\")) {\n                    ForEach(1..<4) {\n                        Label(\"Recipes \\($0)\", systemImage: \"book.closed\")\n                    }\n                }\n                .listItemTint(.monochrome)\n            }\n            .listStyle(SidebarListStyle())\n        }\n    }\n}"
    },
    {
      "timestamp": "22:33",
      "title": "List Item Tint on watchOS",
      "language": "swift",
      "code": "struct ContentView: View {\n    var body: some View {\n        NavigationView {\n            List {\n                Label(\"Menu\", systemImage: \"list.bullet\")\n\n                Label(\"Favorites\", systemImage: \"heart\")\n                    .listItemTint(.red)\n\n                Label(\"Rewards\", systemImage: \"seal\")\n                    .listItemTint(.purple)\n\n                Section(header: Text(\"Recipes\")) {\n                    ForEach(1..<4) {\n                        Label(\"Recipes \\($0)\", systemImage: \"book.closed\")\n                    }\n                }\n                .listItemTint(.monochrome)\n            }\n        }\n    }\n}"
    },
    {
      "timestamp": "22:46",
      "title": "SwitchToggleStyle tint",
      "language": "swift",
      "code": "struct ContentView: View {\n    @State var order = Order()\n\n    var body: some View {\n        Toggle(\"Send notification when ready\", isOn: $order.notifyWhenReady)\n            .toggleStyle(SwitchToggleStyle(tint: .accentColor))\n    }\n}\n\nstruct Order {\n    var notifyWhenReady = true\n}"
    },
    {
      "timestamp": "23:15",
      "title": "Link",
      "language": "swift",
      "code": "let appleURL = URL(string: \"https://developer.apple.com/tutorials/swiftui/\")!\nlet wwdcAnnouncementURL = URL(string: \"https://apple.news/AjriX1CWUT-OfjXu_R4QsnA\")!\n\nstruct ContentView: View {\n    var body: some View {\n        Form {\n            Section {\n                Link(destination: apple) {\n                    Label(\"SwiftUI Tutorials\", systemImage: \"swift\")\n                }\n                Link(destination: wwdcAnnouncementURL) {\n                    Label(\"WWDC 2020 Announcement\", systemImage: \"chevron.left.slash.chevron.right\")\n                }\n            }\n        }\n    }\n}"
    },
    {
      "timestamp": "23:56",
      "title": "OpenURL Environment Action",
      "language": "swift",
      "code": "let customPublisher = NotificationCenter.default.publisher(for: .init(\"CustomURLRequestNotification\"))\nlet apple = URL(string: \"https://developer.apple.com/tutorials/swiftui/\")!\n\nstruct ContentView: View {\n    @Environment(\\.openURL) private var openURL\n\n    var body: some View {\n        Text(\"OpenURL Environment Action\")\n            .onReceive(customPublisher) { output in\n                if output.userInfo![\"shouldOpenURL\"] as! Bool {\n                    openURL(apple)\n                }\n            }\n    }\n}"
    },
    {
      "timestamp": "24:44",
      "title": "Uniform Type Identifiers",
      "language": "swift",
      "code": "import UniformTypeIdentifiers\n\nextension UTType {\n    static let myFileFormat = UTType(exportedAs: \"com.example.myfileformat\")\n}\n\nfunc introspecContentType(_ fileURL: URL) throws {\n    // Get this file's content type.\n    let resourceValues = try fileURL.resourceValues(forKeys: [.contentTypeKey])\n    if let type = resourceValues.contentType {\n        // Get the human presentable description of the type.\n        let description = type.localizedDescription\n\n        if type.conforms(to: .myFileFormat) {\n            // The file is our app’s format.\n        } else if type.conforms(to: .image) {\n            // The file is an image.\n        }\n    }\n}"
    },
    {
      "timestamp": "25:16",
      "title": "Sign in with Apple Button",
      "language": "swift",
      "code": "import AuthenticationServices\nimport SwiftUI\n\nstruct ContentView: View {\n    var body: some View {\n        SignInWithAppleButton(\n            .signUp,\n            onRequest: handleRequest,\n            onCompletion: handleCompletion\n        )\n        .signInWithAppleButtonStyle(.black)\n    }\n\n    private func handleRequest(request: ASAuthorizationAppleIDRequest) {}\n    private func handleCompletion(result: Result<ASAuthorization, Error>) {}\n}"
    }
  ],
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "SwiftUI",
        "url": "https://developer.apple.com/documentation/SwiftUI"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2020/10041/7/85DB087C-0A27-4779-B73A-7C5C888A7C82/wwdc2020_10041_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2020/10041/7/85DB087C-0A27-4779-B73A-7C5C888A7C82/wwdc2020_10041_sd.mp4?dl=1"
  },
  "relatedVideos": [
    {
      "id": "10037",
      "year": "2020",
      "title": "App essentials in SwiftUI",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10037"
    },
    {
      "id": "10048",
      "year": "2020",
      "title": "Build complications in SwiftUI",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10048"
    },
    {
      "id": "10039",
      "year": "2020",
      "title": "Build document-based apps in SwiftUI",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10039"
    },
    {
      "id": "10042",
      "year": "2020",
      "title": "Build SwiftUI apps for tvOS",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10042"
    },
    {
      "id": "10033",
      "year": "2020",
      "title": "Build SwiftUI views for widgets",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10033"
    },
    {
      "id": "10040",
      "year": "2020",
      "title": "Data Essentials in SwiftUI",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10040"
    },
    {
      "id": "10119",
      "year": "2020",
      "title": "Introduction to SwiftUI",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10119"
    },
    {
      "id": "10028",
      "year": "2020",
      "title": "Meet WidgetKit",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10028"
    },
    {
      "id": "10056",
      "year": "2020",
      "title": "Optimize the interface of your Mac Catalyst app",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10056"
    },
    {
      "id": "10207",
      "year": "2020",
      "title": "SF Symbols 2",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10207"
    },
    {
      "id": "10031",
      "year": "2020",
      "title": "Stacks, Grids, and Outlines in SwiftUI",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10031"
    },
    {
      "id": "10175",
      "year": "2020",
      "title": "The details of UI typography",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10175"
    },
    {
      "id": "10143",
      "year": "2020",
      "title": "What's new in Mac Catalyst",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10143"
    },
    {
      "id": "10170",
      "year": "2020",
      "title": "What's new in Swift",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10170"
    },
    {
      "id": "10034",
      "year": "2020",
      "title": "Widgets Code-along, part 1: The adventure begins",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10034"
    },
    {
      "id": "10035",
      "year": "2020",
      "title": "Widgets Code-along, part 2: Alternate timelines",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10035"
    },
    {
      "id": "10036",
      "year": "2020",
      "title": "Widgets Code-along, part 3: Advancing timelines",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10036"
    }
  ],
  "extractedAt": "2025-07-18T10:50:42.179Z"
}