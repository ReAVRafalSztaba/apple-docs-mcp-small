{
  "id": "10049",
  "year": "2021",
  "url": "https://developer.apple.com/videos/play/wwdc2021/10049/",
  "title": "Add intelligence to your widgets",
  "speakers": [],
  "duration": "",
  "topics": [
    "App Services"
  ],
  "hasTranscript": true,
  "hasCode": true,
  "transcript": {
    "fullText": "♪ Bass music playing ♪  ♪ Daniel Li: Welcome to \"Add intelligence to your widgets.\" My name’s Daniel, and I’m an engineer on the Proactive Intelligence team at Apple.\n\nIn this session, I’ll show you how your widgets can work with the system to provide intelligent experiences for your users so your widgets can show up right when they need them.\n\nWidgets live in many places.\n\nFrom the Home screen on iOS to Notification Center on macOS, widgets provide users with information that they can quickly view with just a glance.\n\nWith iPadOS 15, widgets come to the iPad Home screen as well.\n\nThere are now more places than ever for your widgets to call home.\n\nI’ll first talk about what it means for widgets to be intelligent in the system, and then I’ll show you how you can enable intelligence for your widgets by donating relevant information with the available APIs.\n\nLet’s first go over widget intelligence.\n\nOn iPhone and iPad, widgets can be placed together in a Smart Stack, where they can be scrolled through to provide different kinds of information in one place.\n\nWhen a user edits a stack, in addition to being able to add, remove, or reorder widgets, they can also view and manage the stack’s intelligent behaviors.\n\niOS 14 introduced Smart Rotate.\n\nSmart Rotate allows the system, at the right time, to automatically scroll to a widget that is already in a stack.\n\nTo know when to rotate to a widget, the system uses relevance signals that the widget provides alongside its timeline entries.\n\nIt can also rotate to a widget by learning patterns in the user’s behavior.\n\nIt does so by receiving donations from the app whenever the user views information corresponding to the widget.\n\nWith Smart Rotate, if I have a Weather widget, a Reminders widget, and a Calendar widget in a stack, the Weather widget might tell the system to suggest itself in the morning when I wake up to give me an overview of the day.\n\nAt 9:30, the Calendar widget may tell the system that I have a meeting coming up at 10, so my stack might rotate to Calendar.\n\nIn the afternoon, one of my reminders has a due date of 3:00 p.m., so the widget might tell the stack to rotate to Reminders.\n\nAnd in the evening, the Weather widget might tell the system to show me the weather again because it just started raining, so I know to take an umbrella if I go out for dinner.\n\niOS 15 introduces a new feature called Widget Suggestions, a brand-new way for users to discover your widget and receive proactive and relevant information.\n\nFor Smart Stacks with Widget Suggestions enabled, the system can insert a new widget into a stack that doesn’t already contain it.\n\nThe system can do this given an explicit donation from your app.\n\nAnd like with Smart Rotate, the system can also make a Widget Suggestion by learning the user’s behavioral patterns in your app.\n\nWith Widget Suggestions, if I only had a Weather widget and a Reminders widget in my stack, I would still see Smart Rotations to these widgets throughout the day.\n\nBut since I have that meeting at 10:00, and I don’t have the Calendar widget in my stack, the Calendar app may tell the system to proactively insert the widget into my stack at 9:30 so I don’t forget.\n\nAfter the widget is no longer relevant, the system will remove it from my stack.\n\nWhen I finish my evening workout, the system might show me the Fitness widget so I can get a quick summary of my day’s progress in closing my rings.\n\nAnd afterward, the stack will again return to its original state.\n\nSince apps tell the system to temporarily insert widgets when they’re useful, they can help users discover widgets that they may not even know existed.\n\nNow let’s see how you can adopt both Smart Rotate and Widget Suggestions using the available APIs to donate relevant signals to the system.\n\nWhen donating, you should consider all the possible information your widget can show and determine which types are more suitable for a suggestion than others.\n\nThe end goal when choosing how to make donations to the system is to provide timely, glanceable information with obvious value to the user, so you should consider highlighting situations that users may find more interesting than others.\n\nA weather widget, for example, could consider imminent rainfall to be a situation suitable for suggestion as opposed to, say, a point in time where only the temperature has changed by an unremarkable amount.\n\nYou can adopt Smart Rotate and Widget Suggestions for your widgets in three separate ways.\n\nFirst, your app can donate an INRelevantShortcut to tell the system when it should create a Widget Suggestion for one of your widgets.\n\nSecond, your widget can provide relevance scores through TimelineEntryRelevance to enable Smart Rotations when the widget is in a stack.\n\nAnd third, if your widget is configurable, when your app donates the configuration intent using INInteraction, the system can learn the user’s behavioral patterns to promote your widget through both Smart Rotations and Widget Suggestions.\n\nEach of these APIs enhances your widget’s presence in powerful ways but they all work a bit differently, so let’s break it down.\n\nLet’s start with donating INRelevantShortcuts for Widget Suggestions.\n\nWhether you use an intent to configure your widget or not, when your app becomes aware of a highly relevant situation to show your widget to the user, donating an INRelevantShortcut allows the system to proactively insert your widget into one of the user’s stacks if they don’t already have your widget on their Home screen.\n\nA relevant shortcut can either specify a period of time that it’s relevant or have the system determine when to insert the widget based on the user’s behavioral patterns.\n\nINRelevantShortcut supports both static and intent-configured widgets but the donation will look a little different for each configuration type, so let’s take a look at how to adopt for both types.\n\nIf your widget supports StaticConfiguration, simply create a new INRelevantShortcut without an intent and set the widgetKind property to the widget’s kind string.\n\nThis tells the system which of your app’s widgets to suggest.\n\nThen, optionally set the relevanceProviders property to an array of INRelevanceProviders.\n\nThis tells the system when to suggest your widget.\n\nI’ll explain this in more detail in a bit.\n\nIf your widget supports IntentConfiguration, create an instance of the intent used for configuration with the necessary parameters.\n\nThen create the INRelevantShortcut by passing in the intent as an INShortcut.\n\nAnd of course, set the widgetKind and relevanceProviders properties just as you would for a static widget.\n\nTo donate a relevant shortcut, include it in an array of relevant shortcuts to set in the default INRelevantShortcutStore.\n\nTo update the donated shortcuts, you can replace the array of relevant shortcuts in the store to a new array.\n\nThis means that you can invalidate a previously donated relevant shortcut by omitting it in the new array.\n\nAnd donating a relevant shortcut that contains an intent can also surface the intent on the Siri watch face.\n\nTo tell the system when it can insert your widget, set an array of INRelevanceProviders on your relevant shortcut.\n\nThere are two options here.\n\nFirst, you can use INDateRelevanceProvider to supply start and end dates for a fixed, known time period of relevance, such as an upcoming event or breaking news.\n\nYou can even use multiple providers to specify more than one relevant time period.\n\nSecond, you can also choose to supply an empty array of relevance providers to tell the system that your widget has something new to show, and the system will choose a time to suggest the widget based on when the user typically uses your app.\n\nAll other relevance providers support INRelevantShortcuts for Siri watch face and are not supported by Widget Suggestions.\n\nNow I’ll walk you through what an adoption might look like using an example app.\n\nWe built an app called Cards that lets you view the transactions and balances on all of your credit cards and includes a widget that shows recent purchases.\n\nLet’s see how we can enable Widget Suggestions for the Recent Purchases widget by donating INRelevantShortcuts in our app.\n\nWe want to suggest the widget after a recent purchase has just been made on one of our cards.\n\nSince the widget is configured with an intent, in order to allow Widget Suggestions, we’re first going to make sure that our intent supports donations in our intent definition file.\n\nHere’s our intent editor for our ViewRecentPurchases intent, which tells our widget which credit card to show and which merchant category to filter the purchases by.\n\nWe want to make sure that \"Intent is eligible for Siri Suggestions\" is checked.\n\nThis enables suggestions for our widget on the Home screen as well as suggestions in other places around iOS if we choose to donate them, but we’ll get to that later with INInteractions.\n\nThen we need to create a parameter combination that includes the necessary parameters to form the intent.\n\nSince we need both the credit card and the merchant category to configure our widget, we’ll create a supported combination with both card and category parameters.\n\nNow we can create the intent in our code.\n\nIn this code, our app was just notified that the user has just made a purchase.\n\nTo make a donation, we start by creating an empty array of INRelevantShortcuts, in case we want to donate multiple shortcuts.\n\nWe initialize the intent that we used to configure the Recent Purchases widget, and set any parameters that we might need.\n\nHere, we want to set the card parameter on the intent to a card object referring to the card that the recent purchase was made on, and set the category to all to have the widget show all purchases on that card.\n\nThen we create an INShortcut with the intent and create an INRelevantShortcut with it.\n\nWe set the shortcut role to be the information shortcut role, since the user views information in the widget, and set the widgetKind.\n\nWe provide an INDateRelevanceProvider starting now and ending in 30 minutes, or 1800 seconds, so that the system can remove it 30 minutes right after the purchase was made.\n\nThen we add the shortcut to our array of relevantShortcuts.\n\nFinally, we donate the shortcut by setting our relevantShortcuts array in the default INRelevantShortcutStore and handle any errors in the completion handler.\n\nNow whenever a recent purchase is made, the system can make a Widget Suggestion with the widget by proactively inserting it into a Smart Stack.\n\nNow let’s talk about TimelineEntryRelevance.\n\nWhen your widget provides timelines to WidgetKit, you can specify the relevance of your widget by providing TimelineEntryRelevance in each timeline entry.\n\nAnnotating an entry with relevance indicates how worthy the widget is of a Smart Rotation at the time of the entry.\n\nThis worthiness of rotation is relative to all other entries in the timelines that the widget provides, so you should determine which entries may be more relevant to the user than others.\n\nTimelineEntryRelevance is an optional struct property on TimelineEntry, along with the date of the entry.\n\nThe relevance struct contains a score and duration.\n\nThe struct’s float score represents how relevant this entry is compared to others.\n\nThe higher the score, the more likely the system is to rotate to the widget.\n\nWhen determining what scores to return, know that positive scores indicate timeline entries that are eligible for Smart Rotate.\n\nA score of zero tells the system that the widget should not be rotated to, such as when the widget doesn’t have any information to show and rotating to the widget would not be a positive experience for the user.\n\nRemember that the significance of any provided score is relative to others in the widget’s timelines.\n\nWhatever scaling you decide to use for your relevance scores, just make sure that it’s consistent across the timelines you return.\n\nWe’ll go over an example in a just a bit.\n\nThe duration in the relevance struct specifies how long the relevance score is valid.\n\nThe system uses this, along with the entry’s date, to determine the valid timeframe in which to rotate the stack to the widget.\n\nAfter the duration passes, the system will treat the score as zero until relevance is provided again in a future entry.\n\nYou can specify a duration of zero to keep the score valid until the next entry that provides relevance.\n\nLet’s take a look at what this looks like in code.\n\nHere we have our CardRecentPurchasesEntry struct, which conforms to the TimelineEntry protocol.\n\nSince the protocol requires an optional relevance property, we can declare the relevance property in our struct.\n\nNow when we create the timeline entry, we can attach a TimelineEntryRelevance instance to our entries when we create our timeline.\n\nNow let’s work through what a timeline might look like for the Recent Purchases widget and see some examples for scores we can provide for our timeline relevance.\n\nHere’s an example timeline that the Recent Purchases widget might return throughout a day.\n\nWe might think, perhaps, that a user cares more about purchases that involve higher spending.\n\nWe can then make our scores for our purchases scale linearly with the amount spent.\n\nLet’s leave the relevance durations as 0 for now.\n\nAt 8:15, we would return a score of 0, since there’s no purchases to show.\n\nAt 9:41, our 52 dollar and 60 cent purchase means that our score would be 52.6, and so on.\n\nPlotting it on a graph, we see that our shopping spree has a relatively high score compared to other scores, so the system will prioritize rotating to our widget more with this entry than with other entries.\n\nThe other entries still have positive scores, so the system could still rotate to the widget at those times, though with a lower priority.\n\nAnd since we set our durations to 0, the relevance scores stay valid until the next timeline entry with a relevance update.\n\nWe could just as well have chosen another scoring mechanism.\n\nLet’s say we return a score of 50 if the purchase is above 50 dollars, and 1 for purchases below.\n\nOnce again, we return 0 if there’s no purchases at all.\n\nFor our grocery and shopping purchases we returned 50, and for our spending at the Soup Diner and the movie theater, we return 1.\n\nWith the score graph, we can see that the score rises to 50 at 9:41 and stays there until 6:52.\n\nSince 50 is the highest possible score in our timeline, the system is most likely to show our widget at this time.\n\nSince our widget shows recent purchases, we don’t want the system to rotate to our widget with purchases made a long time ago.\n\nSo let’s only allow the system to rotate to our widget within the 30 minutes after the purchase was made.\n\nTo achieve this, we can use the duration property on the relevance struct.\n\nWe set a relevance duration of 30 minutes, or 1800 seconds, for each entry.\n\nBy setting the duration of relevance to be half an hour, we’re telling the system to mark the entries as eligible for rotation for half an hour, and then mark them as ineligible for rotation afterward.\n\nIn these examples, we’re basing our score off of the purchase amount, but really, timeline relevance scores can be whatever you like.\n\nWe could have also used which credit card it is, where the purchase was made, when the purchase was made, or something else entirely.\n\nThere’s no one right way to do it.\n\nNow onto donating INInteractions.\n\nIn your app, you can create and donate an intent used to configure your widget to enable both Smart Rotations and Widget Suggestions through INInteractions.\n\nAn app donates an INInteraction every time the user views information in the app corresponding to information that the widget shows.\n\nEach donation is a data point for the system’s behavioral model that learns when the user tends to view information in the app.\n\nWhenever the model predicts that the user may want to perform the interaction again, the system creates a suggestion for the intent.\n\nAnd as long as the donated intent is the same one used to configure your widget, the system will automatically produce both Smart Rotations and Widget Suggestions from the prediction, along with other suggestions around the system.\n\nTo get going with donating INInteraction in the Cards project, just as with donating INRelevantShortcuts, we want to make sure that our intent is eligible for suggestions, and create a supported combination with the parameters necessary to configure our widget.\n\nHere, also make sure to eventually design the suggestion UI for when your donation shows up in other locations in the system.\n\nIn the Cards app, whenever our user views all of the recent purchases for a card, we can donate our widget’s intent to let the system know that the user is currently interested in the information that our widget shows.\n\nFirst, we initialize our intent.\n\nWe set the card parameter to the card that the user is currently viewing, and set the category to be all, since the user is currently viewing all transactions for this card.\n\nThen we’ll wrap our intent with an INInteraction and call the donate method.\n\nNow the system will know that the user has just looked at the recent purchases for this card in our app.\n\nAfter a while, the system can learn when the user tends to do this, and suggest the matching widget at the most opportune times.\n\nNot only do the INInteraction donations you make enable Smart Rotations and Widget Suggestions, but they also allow the system to show your intent as a Siri Suggestion on the Lock Screen, in Spotlight, and in the Siri Shortcut Suggestions widget.\n\nThis is true even if your widget doesn’t adopt intents.\n\nTo learn more about what donating INInteractions can do for your app and getting even more out of the on-device intelligence, be sure to check out the talk, “Donate intents and expand your app’s presence.” So, INRelevantShortcut, TimelineEntryRelevance, and INInteraction are the three ways in which you can support Smart Rotate and Widget Suggestions for your widgets.\n\nDue to other donations in the system, along with performance considerations, a donation is not a guarantee that your widget will be surfaced.\n\nBut by adopting these APIs in a cohesive manner, you can work with the system to give your widget the best shot possible at being shown.\n\nWhile developing, it may also be helpful to bypass the system’s limitations for surfacing widgets by turning on WidgetKit Developer Mode, found in Developer Settings in the Settings app.\n\nSo to wrap up, Widget Suggestions are a brand-new way for your widgets to proactively show up right when your users need them, who may not even know they existed.\n\nAnd for your widgets already added to a stack, Smart Rotate lets them be a reliable and dependable part of your user’s day.\n\nBy working with the system and leveraging on-device intelligence, these features allow your widget to be more discoverable and more proactive, and contribute to an intelligent Home screen experience.\n\nWe’re incredibly excited to see how you add intelligence to your widgets.\n\nThank you and have a wonderful WWDC.\n\n♪",
    "segments": []
  },
  "codeExamples": [
    {
      "timestamp": "9:14",
      "title": "Donate INRelevantShortcuts for Widget Suggestions",
      "language": "swift",
      "code": "// Donate INRelevantShortcut for Widget Suggestions in app\n// User has just made a purchase\n\nvar relevantShortcuts: [INRelevantShortcut] = []\n\nlet intent = ViewRecentPurchasesIntent()\nintent.card = Card(identifier: card.identifier)\nintent.category = .all\n\nif let shortcut = INShortcut(intent: intent) {\n    let relevantShortcut = INRelevantShortcut(shortcut: shortcut)\n    relevantShortcut.shortcutRole = .information\n    relevantShortcut.widgetKind = “CardRecentPurchasesWidget”\n\n    let dateProvider = INDateRelevanceProvider(start: Date(), \n                                               end: Date(timeIntervalSinceNow: 1800))\n    relevantShortcut.relevanceProviders = [dateProvider]\n\n    relevantShortcuts.append(relevantShortcut)\n}\n\nINRelevantShortcutStore.default.setRelevantShortcuts(relevantShortcuts) { (error) in\n    if let error = error {\n        print(\"Failed to set relevant shortcuts. \\(error))\")\n    } else {\n        print(\"Relevant shortcuts set.\")\n    }\n}"
    },
    {
      "timestamp": "12:35",
      "title": "Adopting TimelineEntryRelevance for Smart Rotate",
      "language": "swift",
      "code": "// Appending TimelineEntryRelevance to a TimelineEntry in widget extension for Smart Rotate\n\nstruct CardRecentPurchasesEntry: TimelineEntry {\n    let date: Date\n    let relevance: TimelineEntryRelevance?\n    let card: IntentCard?\n    let category: PurchaseCategory\n}\n\nlet relevance = TimelineEntryRelevance(score: 16.29, duration: 1800)\nlet entry = CardRecentPurchasesEntry(date: Date(), relevance: relevance, card: card,\n                                     category: category)"
    },
    {
      "timestamp": "17:01",
      "title": "Donate INIntents through INInteraction for Widget Suggestions and Smart Rotations",
      "language": "swift",
      "code": "// Donate INIntent in a card's purchases list in the app\n\n.onAppear {\n    let intent = ViewRecentPurchasesIntent()\n    intent.card = Card(identifier: card.id.uuidString, displayString: card.name)\n    intent.category = .all\n\n    let interaction = INInteraction(intent: intent, response: nil)\n    interaction.donate { error in\n        if let error = error {\n            print(error.localizedDescription)\n        }\n    }\n}"
    }
  ],
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "Making a configurable widget",
        "url": "https://developer.apple.com/documentation/WidgetKit/Making-a-Configurable-Widget"
      },
      {
        "title": "TimelineEntry",
        "url": "https://developer.apple.com/documentation/WidgetKit/TimelineEntry"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2021/10049/5/79001019-5F3C-4B12-A9F7-01FCE02A0381/downloads/wwdc2021-10049_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2021/10049/5/79001019-5F3C-4B12-A9F7-01FCE02A0381/downloads/wwdc2021-10049_sd.mp4?dl=1"
  },
  "relatedVideos": [
    {
      "id": "10231",
      "year": "2021",
      "title": "Donate intents and expand your app’s presence",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10231"
    }
  ],
  "extractedAt": "2025-07-18T09:15:43.188Z"
}