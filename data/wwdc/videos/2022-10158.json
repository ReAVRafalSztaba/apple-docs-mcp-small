{
  "id": "10158",
  "year": "2022",
  "url": "https://developer.apple.com/videos/play/wwdc2022/10158/",
  "title": "Adopt Variable Color in SF Symbols",
  "speakers": [],
  "duration": "",
  "topics": [
    "Design"
  ],
  "hasTranscript": true,
  "hasCode": false,
  "transcript": {
    "fullText": "♪ Mellow instrumental hip-hop music ♪ ♪  Hi, there! I'm Paul, and I work on the SF Symbols app.\n\nToday, we're going to talk about a brand-new feature of SF Symbols: Variable Color.\n\nWe'll be going over how to bring symbols with Variable Color into your projects, and how the SF Symbols app can help you with every step along the way.\n\nFirst, we'll take a look at Variable Color in system-provided SF Symbols.\n\nWe'll go over how it works and when to use it.\n\nThen, we'll go over how to bring Variable Color into your own custom symbols.\n\nBefore we get started, if this is your first time using SF Symbols, or if you just want a refresher, I recommend you watch last year's session, \"Explore the SF Symbols 3 app,\" to find out more about how to find and organize symbols for your projects.\n\nAnd if you haven't yet, check out Thalia's talk, \"What's new in SF Symbols 4,\" for an overview of the visual design of SF Symbols and the different rendering modes we'll be showing today.\n\nNow, let's talk about Variable Color.\n\nVariable Color is a new feature of SF Symbols that allows you to affect the appearance of a symbol using a percentage value.\n\nBy changing this percentage value, you can easily create symbols that reflect values that can change over time, like signal strength or progress.\n\nI think the best way to see how Variable Color works is to jump into the SF Symbols app and let the system speak for itself.\n\nThis year in the SF Symbols app, we added a new preview area here in the rendering inspector that allows you to see a symbol in every rendering mode at a glance.\n\nYou can also click on the different representations to switch between rendering modes.\n\nThere's also a new Automatic option here in the picker.\n\nThis option allows each symbol to choose its own preferred rendering mode, which you can see selected in the preview area here.\n\nFor example, this square.and.arrow.up symbol prefers Monochrome, while these iPhone symbols prefer Hierarchical.\n\nBelow the color controls, you'll find a new set of controls for Variable Color.\n\nAnd there's a new category for symbols that support Variable Color, which is a great place to start experimenting.\n\nLet's select this speaker symbol, switch to Multicolor, and switch to the gallery view to get a closer look.\n\nI'll start by clicking this button to turn Variable Color on, and pull the slider all the way down to decrease the percentage we're using.\n\nYou can see pieces of the symbol dimming as the percentage value decreases.\n\nAnd as I pull the slider back up, those pieces of the symbol regain all of their color.\n\nIf you keep an eye on the preview area, you can see this happening in all four rendering modes.\n\nAnd if I switch back to grid view, you can see all of the symbols in the Variable category are reacting to the changes.\n\nSo what did we just learn about Variable Color? First off, Variable Color can be used with every single rendering mode available for SF Symbols.\n\nEvery system symbol that supports Variable Color supports it in Monochrome, Hierarchical, Palette, and Multicolor modes.\n\nSecond, there are no rules for how many parts of a symbol can be affected by Variable Color.\n\nSome symbols only have one layer that's affected; some have dozens.\n\nRegardless, because Variable Color is controlled using percentages, you don't need to worry about this.\n\nJust pass in a percentage and you're good to go.\n\nSo how does the system interpret those percentages? How do we know when a particular layer is going to have Variable Color applied? Well, like the rest of SF Symbols, we designed Variable Color to make your apps feel right at home on Apple platforms.\n\nAnd that means that we took inspiration from the behavior of system-level indicators that you might be familiar with.\n\nLet's look at this microphone symbol as an example.\n\nThe four dots on the left side of the microphone are each in a separate layer that participates in Variable Color.\n\nSo, each dot will activate when the percentage value crosses a certain threshold.\n\nThose thresholds are spaced out evenly between zero and 100 percent.\n\nZero percent is a special case where no layers will be active.\n\nAny value greater than zero percent will activate the first dot.\n\nAt 26 percent and greater, the second dot will also be activated.\n\nFifty-one percent and greater will activate the third dot.\n\nAnd 76 up through 100 percent will activate all four dots.\n\nSo, Variable Color symbols will only appear visually empty at exactly zero percent.\n\nYou can see this behavior in system-level indicators like Wi-Fi strength and battery level.\n\nVariable Color symbols will start appearing visually full at a value less than 100 percent.\n\nYou can see this behavior in system-level indicators like brightness and volume.\n\nNow, this next symbol has three layers that use Variable Color, which means that the thresholds between layers might fall at awkward values like 33.3333 and 66.6667 percent.\n\nWe didn't want rounding errors to make symbols appear in unexpected ways, and we didn't want you to have to worry about how many significant digits you typed into your code.\n\nSo, thresholds between layers are rounded to the nearest percentage point, and we don't activate the next layer until you're one full percentage point above that rounded value.\n\nSo, for the first threshold, 33.3 percent rounds down to 33 percent, so the second layer activates one percentage point higher at 34 percent.\n\nThe final threshold rounds from 66.7 percent up to 67 percent, so the last layer activates at one percentage point higher than that, at 68 percent.\n\nOf course, system-provided symbols are only one half of the story.\n\nWith the SF Symbols app, you can make and annotate your own custom symbols, and even better, you can make your custom symbols just as flexible and just as powerful as symbols provided by the system.\n\nWhat do I mean by flexible and powerful? Well, system-provided SF Symbols are available in nine different weights, and each one of those nine weights is available at three different scales.\n\nEach one of those 27 variants is available in four rendering modes with and without Variable Color.\n\nThat's 216 possible configurations.\n\nLuckily, that doesn't mean that you need to draw your custom symbols 216 times.\n\nLast year, to streamline the process of drawing symbols, we introduced variable templates.\n\nWhen using this kind of template, instead of drawing 27 different combinations of weights and scales, you only need to draw three, and the system can generate the other 24 for you automatically.\n\nAfter you've drawn your custom symbol, you can adopt different rendering modes through a process we call \"annotation.\" Last year, if you wanted your symbol to adopt the Hierarchical and Palette rendering modes, you broke your custom symbol into different layers and assigned each layer a hierarchy level.\n\nIf you wanted your symbol to adopt the multicolor rendering mode, you broke your custom symbol into different layers again and assigned a color to each layer.\n\nThis meant that, to support all the available rendering modes, you had to manage two separate layer structures.\n\nThis year, we're streamlining that workflow with unified annotation.\n\nUnified annotation uses a single-layer structure for a symbol, and shares that structure across all rendering modes.\n\nSo, instead of having to break your symbol into layers multiple times, you only need to do it once.\n\nYou now also have control over how your symbol will look in Monochrome rendering mode, in addition to the previous control you had over Hierarchical, Palette, and Multicolor.\n\nAnd of course, unified annotation allows you to add Variable Color to your symbols.\n\nSo let's work on annotating a custom symbol to get to know unified annotation.\n\nLast year, I was working on an app so my family could play card games together, even when we couldn't be in the same room.\n\nA few months after that, I discovered a new obsession: puzzle cubes! So this year, I want to make an app that's going to help me practice solving mine.\n\nI've got a custom puzzle cube symbol that I've made here on my desktop.\n\nI'll drag it into the app to make a new custom symbol.\n\nI based this symbol off of the system-provided cube symbol, and notice how I've left some of the details of the puzzle cube out.\n\nThis helps the symbol come across clearly, even at small sizes and different weights.\n\nNow, remember this preview area from before? It's especially handy when annotating custom symbols.\n\nAs I make changes to the annotation, I can see how my custom symbol looks in all the different rendering modes at a glance.\n\nAnd when I switch rendering modes by clicking here or picking a different option in the picker, the annotation controls in the list change accordingly.\n\nMonochrome looks pretty good, but let's add some depth in Hierarchical mode.\n\nI'll switch to that mode and pull the top and the side of the cube into new layers.\n\nYou can see that these new layers automatically get switched to the less-prominent secondary and tertiary levels.\n\nThis gives my symbol a little bit more depth and visual interest.\n\nAnd remember that the Hierarchical annotation that we create is also used to support Palette rendering mode.\n\nSo I've just gotten two new rendering modes for the price of one.\n\nNow, let's switch over to Multicolor mode to give this symbol some color.\n\nNotice that when I switch to Multicolor mode, I still see the same layers that I separated out in Hierarchical mode.\n\nRemember, in unified annotation, changes made to the layer structure in one rendering mode will carry through to all the others.\n\nLet's make the front face red, the top face blue, and the side face yellow.\n\nAll right, this looks pretty great.\n\nBut the most important part of learning to solve a puzzle cube is practice, practice, and more practice.\n\nSo, I would love to use my cube symbol as a timer, and have it fill up with color as I spend more time practicing.\n\nThe solution for that is Variable Color.\n\nThese separate pieces in the front face look like a great place to add some variable color for our timer.\n\nLet's separate out each of these pieces into a different layer.\n\nNotice the order that I'm arranging these in the layer list.\n\nThe layers that I want to fill in first go on the bottom, and the layers I want to fill in last go on top.\n\nThen, we'll select all of these layers and click on this button, which will enable Variable Color on all of them.\n\nAnd that's it! Let's move the Variable Color slider around to see what happens.\n\nRemember to keep an eye on the preview area to see what's happening in all the different rendering modes.\n\nYou can see that, as we change the percentage used in Variable Color, the front face adjusts its color in every rendering mode.\n\nThat's the power of unified annotation.\n\nBecause edits in one rendering mode can carry through to other rendering modes.\n\nIn many cases, you only need to do work once or twice to get great results in all four rendering modes.\n\nAnd in situations where things are a bit trickier, the SF Symbols app still has you covered.\n\nLet's look at a more complicated symbol.\n\nHere's my cube symbol again, but this time, it's set inside of a circle, like many of the .circle.fill symbols in the system library.\n\nNow, I've already started annotating this symbol.\n\nYou can see here that I've separated the circle and the parts of the cube into different layers.\n\nMy symbol looks great in Multicolor and Hierarchical modes, but in Monochrome, there's not much contrast between the cube and the circle behind it.\n\nWhen all the paths in the symbol were in one layer, the cube paths created holes in the circle path, which looked great in Monochrome.\n\nBut now that I've moved the circle onto its own layer, the cube paths no longer create holes.\n\nInstead, they create a solid cube on top of a solid circle.\n\nSo we can't see it very well.\n\nLuckily, there's a new feature of unified annotation that can help us here.\n\nWe can choose Erase to make a layer create a hole in the layers behind it.\n\nThat's looking much better.\n\nNow, let's add Variable Color again.\n\nThis time, I'll just select all of the pieces of the front face and choose Split into New Layers from the contextual menu.\n\nThen I'll use this button to turn on Variable Color again.\n\nAnd I'm done! And by the way, the paths are split up using the order that they appear in your symbol template, so if you pay attention to the order of your symbol's paths as you're drawing, you can save some time later.\n\nSo that is unified annotation in a nutshell.\n\nIt's a fast and powerful way to annotate your custom symbols.\n\nYou create one layer structure that applies across all rendering modes.\n\nYou can now control the appearance of your symbol in Monochrome rendering mode.\n\nYou can add Variable Color to individual layers in your symbol.\n\nThe z-order of the layers determines the order that they will fill in as the passed-in percentage increases, and the thresholds used for each layer are spaced evenly between zero and 100 percent.\n\nAnd because it's part of the layer structure, when a layer opts in to Variable Color, this setting is shared across all rendering modes.\n\nAnd there are two new layer options in unified annotation that make it easier to work with the new shared layer structure.\n\nSetting a layer to Erase will use that layer's shape to erase layers behind it.\n\nThis is really useful in situations like Monochrome and Hierarchical symbols that have badges with a plus, a minus, or some other shape inside of them.\n\nAnd finally, setting a layer to Hidden will exclude it from a particular rendering mode.\n\nIf you're in a situation where a layer truly can't be used across all the rendering modes, you can use this option to only apply that layer to certain modes.\n\nAll of these new features are supported by a new template format, 4.0.\n\nWhen you're exporting a symbol from the SF Symbols app to import into Xcode, make sure that you export a 4.0 template to control Monochrome rendering and use Variable Color.\n\nIf you already have custom symbols that you annotated last year, they will be automatically updated to use unified annotation.\n\nYour Hierarchical and Multicolor annotations will be brought in with no extra work required from you.\n\nAnd, if you need to support earlier platforms, the previous 3.0 and 2.0 formats are still available for use.\n\nBefore we wrap up, there's one more thing I want to do.\n\nI've had a lot of fun learning about how to solve puzzle cubes, but the best part so far is that my daughter saw me solving them and wanted to learn too.\n\nSo naturally, I also want her to be able to use my app to help her practice.\n\nNow, she's starting kindergarten this fall, so we're going to start her off a little slower.\n\nBut this is where symbols with Variable Color truly shine.\n\nWe could design our timer UI like this.\n\nText and numbers are descriptive and helpful, but they could be intimidating for someone like her who's still learning or is unable to read the text.\n\nBut seeing a puzzle cube that looks just like the one she's holding, and seeing it fill up with color as time passes, is friendly and intuitive.\n\nI don't even need to change my timer code; all I need to do is change the name of the symbol I'm using and keep passing in the same percentage values I used for my bigger cube symbol, and SF Symbols takes care of the rest.\n\nAnd that's the power of symbols.\n\nThey allow us to convey ideas in a way that transcends language and text.\n\nThey give us a way to make our apps more inclusive.\n\nAnd Variable Color in both system-provided symbols and your custom symbols gives us even more expressive power for concepts like progress, signal strength, and time.\n\nAll of that from three drawings and one unified annotation.\n\nThat's pretty amazing.\n\nAnd, I might add, it's way easier than solving a puzzle cube.\n\n♪",
    "segments": []
  },
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2022/10158/4/94078977-F8B3-4097-A94F-9C4931D9A1FE/downloads/wwdc2022-10158_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2022/10158/4/94078977-F8B3-4097-A94F-9C4931D9A1FE/downloads/wwdc2022-10158_sd.mp4?dl=1"
  },
  "relatedVideos": [
    {
      "id": "10074",
      "year": "2022",
      "title": "What's new in AppKit",
      "url": "https://developer.apple.com/videos/play/wwdc2022/10074"
    },
    {
      "id": "10157",
      "year": "2022",
      "title": "What's new in SF Symbols 4",
      "url": "https://developer.apple.com/videos/play/wwdc2022/10157"
    },
    {
      "id": "10068",
      "year": "2022",
      "title": "What's new in UIKit",
      "url": "https://developer.apple.com/videos/play/wwdc2022/10068"
    },
    {
      "id": "110930",
      "year": "2022",
      "title": "WWDC22 Day 2 recap",
      "url": "https://developer.apple.com/videos/play/wwdc2022/110930"
    }
  ],
  "extractedAt": "2025-07-18T09:36:42.938Z"
}