{
  "id": "10211",
  "year": "2021",
  "url": "https://developer.apple.com/videos/play/wwdc2021/10211/",
  "title": "Symbolication: Beyond the basics",
  "speakers": [],
  "duration": "",
  "topics": [
    "Developer Tools"
  ],
  "hasTranscript": true,
  "hasCode": true,
  "transcript": {
    "fullText": "♪ Bass music playing ♪  ♪ Alejandro Lucena: Hello, everyone.\n\nThank you for attending this session on symbolication.\n\nWhile symbolication may seem like a vague term, we'll see the instrumental role it plays in helping you to quickly identify the root causes of bugs, crashes, and performance bottlenecks.\n\nWe'll gain a deeper intuition as to how symbolication works and cover several tools that you have at your disposal to follow along firsthand.\n\nAlong the way, we'll discuss the various sources of debug information that are necessary for a rich symbolication experience and how you can configure your app to best utilize this information.\n\nLet's get started by familiarizing ourselves with a concrete definition and example of symbolication.\n\nFundamentally, symbolication is a mechanism to convert or translate how our devices see our apps at runtime — which is in terms of memory addresses and instructions — back to how we as developers see our apps — which is in terms of functions, names, and files.\n\nWithout this bridging layer, it vastly complicates diagnosing a bug even for a few lines of code.\n\nAs an example, let's consider this Swift code.\n\nHere I have a function, `generateMagicNumber()`, that selects a particular number from a list of candidate numbers.\n\nTo do this, we first call into `numberChoices()` that returns an array of 10 randomly generated numbers.\n\nThen, we pass that array into `selectMagicNumber(choices:)`, which returns the number at a particular index.\n\nThis seems like a reasonable program, but I encounter a crash when I first run it.\n\nMy first recourse is to check the crash log, which is rather unfruitful.\n\nAll I can tell from the thread backtrace is that my MagicNumbers app crashed somewhere.\n\nThanks, but I already knew that.\n\nI have no idea what any of the registers are referring to either.\n\nI can try to step through the app with the debugger and identify the crash, but what if this only happens in particular circumstances that I can't reproduce? Using the debugger won't necessarily pinpoint the problem for me in that case.\n\nOr I can try to look at the disassembly, but it's much more difficult to keep track of things.\n\nThis clearly isn't a viable way to diagnose the problem, and more importantly, with the help of symbolication, we don't have to debug from this starting point.\n\nThe Xcode Organizer tells me I can download the dSYM for this app, which will reprocess the crash log.\n\nIn doing so, Xcode applies the concepts of symbolication so that I can diagnose the issue with a much nicer crash log, where I can not only see all of my functions actually being called, but I can also determine the file and line number to refer back to in my code.\n\nThis updated crash log also tells me that we tried to access an index out of range.\n\nAlternatively, If I already have the dSYM, I can use the `atos` command to get the same information.\n\nLooking back at my code, I come to realize that `MAGIC_CHOICE` is far outside the bounds of our 10-element array.\n\nOops.\n\nIn another instance, I'm interested in profiling my app to deliver the fastest user experience.\n\nHere, Instruments shows me that the app cycles through periods of high utilization and low utilization.\n\nIf we focus on a period of low utilization, Instruments tells us that the app was writing some content to a file.\n\nHowever, when I inspect a period of high utilization, I get the same exact backtrace.\n\nHow is this possible? Isn't this executing the same exact code? As we'll see, this Instruments trace is only partially symbolicated.\n\nFor instance, I don't see any file names or line numbers in the backtrace as I did with the updated crash log.\n\nAs a result, it's missing some information.\n\nWith that in mind, I can similarly locate my dSYM in Instruments.\n\nAfter doing this, my new Instruments trace shows that the high-utilization regions were indeed writing to a file, but they were specifically within a debug code path that I left in the program.\n\nThe low-utilization areas avoid this and represent how my app behaves in production.\n\nJust as Xcode utilized the dSYM to symbolicate a rather uninformative crash log, Instruments also used the dSYM to enrich a partially symbolicated trace and tell me the exact cause of the performance issue.\n\nNow, while it's great that these tools leverage symbolication to pinpoint problem areas in my code, it naturally begs a few questions.\n\nHow does this all work? Where else can I apply this? And is this all about dSYMs? To answer these questions and unlock symbolication's capabilities, we'll need to take a deeper dive into the details.\n\nThis may seem a little overwhelming, but these are important concepts to understand.\n\nThere are many tools to aid in debugging and profiling that build upon symbolication.\n\n`atos` alone already gave us the exact root cause of a crash, and there are many more tools built into Xcode.\n\nFurther, we specified flags like `o`, `l`, and `i` to `atos`, but what do they mean? Do we always use the same set of flags? What if we don't have one of the values available? You'll also gain a good foundation in understanding when and why your backtraces may not be fully symbolicated and how to fix that, as we saw in the Instruments case.\n\nLastly, there are a number of build settings that you're in control of that influence the richness of symbolication.\n\nWe'll go through these build settings so you have a solid intuition about how they're utilized.\n\nTo that end, I'd like to introduce the two-step process for symbolication.\n\nStep number one is going back to the file, and step number two is to consult debug information.\n\nAs we'll see, going back to the file is all about converting or translating runtime memory addresses into a more stable, usable form.\n\nThis allows us to communicate with our debug information to make a meaningful connection between a raw memory address and the source code.\n\nLet's start off by discussing step number one, going back to the file.\n\nThe ultimate goal in this step is to translate a runtime memory address, such as those we saw in the original crash log, to a corresponding address in your binary on disk.\n\nJust like we have runtime addresses, your apps and frameworks have an address space on disk, too! The on disk address space differs from the address space that your app occupies at runtime, and we need a mechanism to figure out those differences.\n\nFirst, we should understand exactly what the on disk addresses are.\n\nThese addresses are assigned by the linker when you build your app.\n\nSpecifically, the linker groups your binary into segments.\n\nEach segment contains related data and has properties such as a name, a size, and their assigned addresses.\n\nFor example, the `__TEXT` segment of your binary contains all of the functions and methods you've written, and the `__DATA` segment contains program-wide state such as global variables.\n\nEach of these segments gets assigned a different address such that they don't overlap.\n\nThe linker records this information at the very beginning of your executables as part of the Mach-O header.\n\nMach-O is the format used for all executable binaries and libraries, and the system knows that it needs to read this header to run your apps.\n\nLooking a little more closely, the Mach-O header contains a number of load commands that hold the segment properties.\n\nThe system uses these load commands to load the segments into memory.\n\nNote that if your apps are Universal 2, then the app will have one header and a set of segments for each architecture.\n\nWe can see for ourselves by using the `otool -l` command, which prints the load commands for a specified file.\n\nHere, we're looking a segment load command identified with `LC_SEGMENT_64`.\n\nThis load commands says that the `__TEXT` segment starts at the address in `vmaddr` and is `vmsize` bytes long.\n\nSo if the kernel follows these load commands to load the segments into memory, what exactly is the difference between the runtime and the linker addresses? Well, before the kernel actually loads the segments, it initializes a random value known as the ASLR slide.\n\nThe kernel then adds the ASLR slide to the addresses in the load commands.\n\nSo rather than loading the `__TEXT` segment at address A and the `__DATA` segment at address B, the kernel instead loads them to A+S and B+S, where S is the ASLR slide.\n\nSince A+S and B+S are the true addresses that the system uses, they're also known as load addresses.\n\nWith that in mind, we now know that the difference between a runtime address and the linker address is the ASLR slide.\n\nWe can calculate the ASLR slide with the following equation: S = L-A, where S is the ASLR slide, L is the load address, and A is the linker address.\n\nWe'll see examples of this equation shortly, but the key point is that we can always go back to the file address space once we know the ASLR slide.\n\nThe ASLR slide equation required two addresses — the load address and the linker address — so where do we get them from? We already saw how we can query the load commands to know the linker address using `otool`.\n\nTo know the runtime address, the system queries your app either at the point of a crash or as its being profiled by Instruments for its runtime address space.\n\nThis information is reflected in the Binary Images list in your crash logs.\n\nYou can also see the load addresses interactively with the `vmmap` tool, which enumerates the active memory regions in your program.\n\nLet's compute the ASLR slide value ourselves from the original crash log.\n\nIn the Binary Images list, I have the load address of the `__TEXT` segment.\n\nI also have the linker address for the binary on disk when I looked at the load commands.\n\nSubtracting these two yields an ASLR slide value of 0x45c000.\n\nThis means that every address in my program's runtime `__TEXT` segment is 0x45c000 bytes away from the linker `__TEXT` segment address.\n\nSo to see what a backtrace address from the crash log corresponds to in the file, I can subtract 0x45c000 from it to get the address on disk.\n\nSince this address is now part of the on-disk address space, I can inspect my app to see what resides there.\n\nThe crash log tells me that a thread crashed while executing whatever is at this address, so we can use `otool` again to see the problematic instruction.\n\nThis time, I specified the `-tV` flags to `otool`, which will print the disassembly.\n\nNotice that I'm also specifying the architecture as arm64.\n\nThis is so that otool knows which Mach-O header and segments to consider since the app is built as Universal 2.\n\nThe output of `otool` reveals a `brk` instruction at the address.\n\n`brk` signals an exception or a problem in the app.\n\nTools such as `atos` also calculate the ASLR slide using the same technique we went through together.\n\n`atos` will read the load commands for the file indicated by the `-o` flag, and we tell it about the load address with the `-l` flag.\n\nAs I mentioned, `vmmap` can also tell us about the load addresses of a running app.\n\nLet's try this calculation again, but this time we'll use `vmmap` instead of the binary image list to determine the ASLR slide.\n\nI ran the MagicNumbers program again and got the `__TEXT` segment load address before the program crashed.\n\nUsing the previous formula, I can determine that this time the ASLR slide value was 0x104d14000.\n\nAgain, to go back to the file, I need to subtract the ASLR slide value.\n\nIf I subtract 0x104d14000 from the topmost entry in the new crash log, I get the same exact file address as before.\n\nAnd this is no coincidence; the kernel just picked a different ASLR value so our load addresses changed between the crash logs.\n\nHowever, we can still determine the file address that was responsible for the crash.\n\nThe important takeaway here is that we have a mechanism to understand exactly what our app was doing down to the instruction level, regardless of its runtime address.\n\nAnd with that mapping, we can then consult our debug information for the source code that was compiled to those instructions.\n\nBefore we move on, I want to present a summary of what we covered and the tools we used.\n\nApp binaries and frameworks are Mach-O files.\n\nThis means that they have related content in their different segments.\n\nThese segments are created by the linker.\n\nThe Mach-O header load commands describe the properties of those segments, including an address.\n\nWe used `otool` with the `-l` flag to print out the load commands.\n\nNext, we learned that the kernel adds a random value, known as the ASLR slide, to the linker addresses.\n\nThe addition of the ASLR slide and the linker address is known as a load address.\n\nWe can check the binary image list in a crash log to see the load addresses in the event of a crash, or we can use `vmmap` to see the load addresses for a running app.\n\nFinally, we walked through some examples of calculating the ASLR slide to get back to the file address space.\n\nNow we can discuss debug information, which contains the crucial links between the file addresses and the source code.\n\nXcode creates the debug information when you build your app and will either embed it directly into your app binaries or store it as a separate file, such as a dSYM.\n\nThere are a few categories or types of debug info.\n\nEach one offers a different level of detail for a given file address.\n\nWe'll look at three different types of debug info today.\n\nFirst, we'll cover the function starts, which by itself doesn't add too much value, but it is a common starting point.\n\nNext we'll see the nlist symbol tables, which add function and method names.\n\nLastly, we'll look at DWARF, which comes from dSYMs and static libraries.\n\nDWARF adds the most detail, including file names, line numbers, and optimization records.\n\nSince DWARF offers the most detail, we really want to strive to have this type of debug info whenever possible.\n\nWe'll learn about each of these and how they can be used to build up the fully symbolicated crash log.\n\nLet's begin with function starts.\n\nAs we saw in the table, function starts offers the least source code detail.\n\nAlso keeping true to its name, this type of debug information only tells us about the first address — or the literal start — of our functions.\n\nFor example, this would tell us that a function begins and exists at a certain address.\n\nHowever, it doesn't tell us which functions begin at those addresses, only that they exist.\n\nThe function starts debug info does this by encoding the list of addresses in your app's `__LINKEDIT` segment.\n\nSince this is embedded directly in your app, the Mach-O header also has a load command to inform us where we can find it, which is `LC_FUNCTION_STARTS`.\n\nYou can see these for yourself with the `symbols` command and the `-onlyFuncStartsData` flag.\n\nHere we get back a list of addresses and null placeholders.\n\nThese placeholders would ideally have function and method names instead of null, but the function starts data doesn't provide names.\n\nAgain, this isn't the most descriptive data.\n\nHowever, it does allow for a slight update to the crash log.\n\nWe can now view the file addresses as offsets from a function.\n\nFor example, first we go back to the file by subtracting the ASLR slide value.\n\nThen we find the function starts value that could contain the file address.\n\nIn this case, only the first value could contain the address because all of the other values are larger than the address.\n\nFinally we can claim that our file address is actually 264 bytes into this function.\n\nThis is primarily useful for debuggers, since they can understand the details of how this function was set up and which registers were modified.\n\nWhat this means for you, however, is that if you ever encounter a crash log that lacks function names, you're probably dealing with this lowest level of debug information.\n\nThis is good news because it means there are plenty of opportunities to enrich the crash log with better debug information.\n\nNaturally, the next level of detail we'd like to see are function names.\n\nThis gives us our first real opportunity to take a crash log or an Instruments trace and use it to track down an issue in our source code.\n\nThis leads us to nlist symbol tables.\n\nThe symbol tables build on the idea of function starts and also encode a list of information in the `__LINKEDIT` segment, and has its own load command too.\n\nHowever, rather than just encoding addresses, they encode C structs.\n\nThis lets us add more details for any given entry compared to function starts.\n\nSpecifically, they encode the `nlist_64` struct.\n\nHere we have the definition of that struct.\n\nA cursory glance shows that we have access to a name and several properties.\n\nThe values of these struct fields are determined by the nlist's `n_type`.\n\nThere are three primary n_types that we're interested in, but for now we'll only focus on two.\n\nThe first is known as a direct symbol.\n\nThese are functions and methods that you have fully defined within your apps and frameworks.\n\nDirect symbols have a name and an address in the `nlist_64` struct.\n\nAdditionally, they're represented by a particular bit pattern in the `n_type` field.\n\nSpecifically, `n_type` will have the second, third, and fourth least significant bits set.\n\nThese bits are also known as `N_SECT`.\n\nWe can see these with `nm` and specifying the `-defined-only` and `--numeric-sort` flags.\n\nHere, `nm` walked through the defined symbols of the MagicNumbers program and listed them in address order.\n\nThe names we get back appear cryptic.\n\nThat's because the names that are actually stored in the symbol tables are mangled names.\n\nThese mangled names help the compiler and linker to uniquely identify a function, but they aren't easy to understand unless they're demangled.\n\nTo get a friendlier version of these names, I passed the output to `swift-demangle`.\n\nNow we get some familiar names, such as `main` and `numberChoices`, because they're directly defined in my app.\n\nSimilarly, the `symbols` tool has an option to show the nlist data, and it also demangles the names automatically.\n\nNow that we can associate a function name to an address, this lets us update the crash log once again.\n\nHere we can observe that our offset expression that we got from the function starts data also matches an entry from the direct symbols, and that entry has a name.\n\nPutting these two together, we can now say that our crash happened at 264 bytes into main.\n\nThis still leaves some details to be desired, since we know for a fact that main isn't the only function involved.\n\nAnd it would also help to have an exact line number too.\n\nWe encountered something similar to this in the Instruments trace example — we had some function names available, but it missed others.\n\nOne reason for this is that the symbol table only has direct symbol entries for functions that are involved in linking.\n\nThese are functions that you use across modules or functions that you export from your frameworks.\n\nThis makes it useful for identifying API boundaries.\n\nAnd it also means that it has the necessary data to power dynamic loading with functions such as `dlsym()` and `dladdr()`.\n\nOne downside though is that local or static functions aren't represented in the symbol table since they aren't referenced outside of their module.\n\nThis ends up omitting implementation functions where we may have a significant portion of the app logic.\n\nFurther, it's common for binaries built in Release mode to have their symbol table stripped.\n\nThis means that unnecessary entries are removed from the symbol table, which helps reduce the size of your app.\n\nIf we think about it, it's rather uncommon for our app's primary driver to export functionality anywhere, so we'd be wasting space keeping those symbol table entries around.\n\nFor our frameworks and libraries, we definitely have exported functions that clients should use, but there's no need to keep around the locally shared functions since they can't be used anywhere else.\n\nStripping our primary app executables will almost always leave the symbol table practically empty.\n\nStripping our frameworks and libraries leaves only the exported functions.\n\nYou may have come across build settings in Xcode such as Strip Linked Product, Strip Style, and Strip Swift Symbols.\n\nThese build settings control how your app is stripped during the build.\n\nIf Strip Linked Product is enabled, then the binary is stripped according to Strip Style.\n\nFor example, All Symbols will perform the most invasive removal and leave behind only the bare essentials.\n\nNon Globals removes direct symbols that are used within different modules of your app but are not exported for use in other apps.\n\nDebugging Symbols removes the third type of nlist type that we'll discuss later when we get to DWARF.\n\nHowever, this strip style does preserve the direct symbols.\n\nFor example, here I have a framework that defines two public interfaces and one internal shared implementation function.\n\nSince all of these functions play a role in linking, they all have direct symbol entries.\n\nIf I strip non globals, then I'm only left with my interfaces.\n\nThe shared implementation function was only used within my framework, so it isn't considered global.\n\nSimilarly, stripping all symbols still leaves the interface since these are required for other apps to use the framework.\n\nYou can also notice in the `symbols --onlyNListData` output that there are function starts addresses interspersed between the direct symbols.\n\nThese addresses represent functions that were either never in the direct symbols, or were stripped.\n\nYou can tailor these strip settings to your desired level of symbol table visibility.\n\nWith this information, we can determine when we're working with direct symbols.\n\nSome telltale signs of this are having function names but no line numbers or file names; or having a mix of function names and function starts addresses, as we have here with the framework example.\n\nThe second type of nlist struct we'll analyze is known as an indirect symbol, as opposed to direct symbol.\n\nThis is when the `n_type` matches only the `N_EXT` bit pattern.\n\nThese are functions and methods that you're using from other frameworks or libraries, such as `print()`.\n\nYou can see these with `nm`, only this time we'll specify `--undefined-only` instead of `--defined-only`.\n\nWe'll also add the `-m` flag, which will show you which frameworks or libraries the functions should be found in.\n\nFor example, the MagicNumbers app depends on a variety of Swift functions that are defined in libswiftCore.\n\nNow that we've covered two of the three debug information categories, let's make sure we understand their properties.\n\nFunction starts are a list of addresses, so they lack names, but do allow us to determine offsets.\n\nnlist symbol tables encode entire structs of information and can associate a name to an address.\n\nThey describe direct symbols — which are defined in your app — and indirect symbols, which are provided by dependencies.\n\nDirect symbols are generally reserved for functions involved in linking, and the strip build settings influence which direct symbols are available.\n\nFinally, both the function starts and the nlist symbol tables are embedded directly in your app.\n\nWhat we haven't seen yet is the richer levels of detail, such as file names and line numbers.\n\nThis is provided to us by DWARF.\n\nDWARF takes the concepts of nlist symbol tables to a completely different level.\n\nRather than keeping only a subset of functions, DWARF strives to describe everything.\n\nWe saw that nlist symbol tables added vastly more information versus the function starts.\n\nIt accomplished that by adding a dimension.\n\nRemember, we started with just a single dimension, which were the addresses, when we looked at function starts.\n\nThen we upgraded to two dimensions by encoding a struct full of information in the nlist symbol table.\n\nDWARF adds a third dimension, which is about relationships.\n\nDWARF recognizes that functions aren't isolated.\n\nThey call other functions, they have parameters, return meaningful data, and are defined in a particular file.\n\nEncoding these relationships unlocks the most powerful aspects of symbolication.\n\nWhen we're analyzing DWARF, we're primarily referring to a dSYM bundle.\n\nIn addition to other metadata such as plists, the dSYM bundle contains a binary with DWARF.\n\nWhat makes this binary so special? The binary contains its data in a special `__DWARF` segment.\n\nThe DWARF specification mentions three streams of data within the segment that we'll focus on.\n\n`debug_info` contains the raw data, `debug_abbrev` assigns structure to the data, and `debug_line` contains the file names and line numbers.\n\nDWARF also defines two vocabulary types that we'll study first: the compile unit and the subprogram.\n\nWe'll introduce a third one later.\n\nA compile unit represents a single source file that went into building the product.\n\nFor example, we can expect to have one compile unit for each Swift file in our project.\n\nDWARF assigns properties to a compile unit, such as the name of the file, the SDKs, the portion of the `__TEXT` segment its functions occupy, and much more.\n\nThe main.swift compile unit contains these properties in the `debug_info` stream on the left, and it has a corresponding entry in the `debug _abbrev` stream on the right which tells us what the values represent.\n\nHere we see the file name, the language it's written in, and a low/high pair representing the `__TEXT` segment range.\n\nA subprogram represents a defined function.\n\nWe saw defined functions in the nlist symbol table already, but the subprogram can describe static and local functions too.\n\nA subprogram also has a name and its `__TEXT` segment address range.\n\nOne fundamental relationship between compile units and subprograms is that subprograms are defined in a compile unit.\n\nDWARF represents this with a tree.\n\nThe compile unit is at the root of the tree and it has subprogram entries as children.\n\nThe children are searchable by following their address ranges.\n\nWe can examine these in more detail with the `dwarfdump` command.\n\nFirst we'll look at a compile unit.\n\nThis matches some of the properties of a compile unit I mentioned earlier.\n\n`dwarfdump` helpfully combines the `debug_ info` and `debug _abbrev` contents to show you the structure and content of the data in your dSYMs.\n\nAnd if we scroll down the output, we'll encounter one subprogram child.\n\nThe address range it occupies is within the bounds of the compile unit and we can also see the name of the function.\n\nI mentioned that DWARF describes its data in extreme detail.\n\nWhile we won't spend much time on all of these details, I think it's fun to see details such as function parameters.\n\nThey have their own vocabulary type that describes the name and type of the parameter.\n\nFollowing the tree model, a parameter is a child of a subprogram.\n\nHere we come across the entry for the choices parameter that we supply to a function.\n\nNext, file names and line numbers come from the `debug_line` stream.\n\nThis stream doesn't have a tree structure.\n\nInstead, it defines a line table program where the individual file addresses can be mapped back to an exact line of code.\n\nThis ends up generating a list of source code details which we can search to find the file and line.\n\nIf we parse the `debug_info` tree and generate the `debug_line` list, we end up with a structure like the following.\n\nSo if want to match a file address, we can traverse the tree.\n\nFirst, we'll start at the compile unit and follow the branches.\n\nThen we'll pick up any of the `debug_line` entries that matched.\n\nWe can automate this again with `atos`, only this time I'm specifically leaving out the `-i` flag.\n\nNotice anything slightly odd here? Yes, we have the function name and line number, so we're definitely using DWARF.\n\nOther than that though, this isn't all too different from the nlist symbol table update.\n\nIn fact, when we compare it to the first time we used `atos`, it still looks like we're missing so many valuable functions and details! What happened here? The only thing that changed was that we didn't specify the `-i` to `atos` this time.\n\nThat flag stands for \"inlined functions.\" Inlining is a routine optimization that compilers perform.\n\nThis involves substituting a function call with the body of the function directly.\n\nOne cool effect that it has is making code seemingly disappear.\n\nWe can think of it as, rather than calling `numberChoices()`, the entirety of the code for `numberChoices()` was dropped in place.\n\nSuddenly there's no function call to `numberChoices()` anymore! DWARF represents this with an inlined subroutine.\n\nThis is the third and final vocabulary type for DWARF that we'll discuss today.\n\nAn inlined subroutine is a subprogram — so it's a function — that was inlined into another subprogram.\n\nSince an inlined function is completely engulfed by another node in the relationship tree, the inlined subroutine is a child of that node.\n\nThis definition applies recursively too, meaning that an inlined subroutine can have other inlined children.\n\nAgain, with `dwarfdump`, we can look for inlined subroutines.\n\nThey're listed as children of other nodes and have similar properties to subprograms, such as names and addresses.\n\nHowever, in DWARF, these properties are frequently accessed through a common node, known as the abstract origin.\n\nIf there are many inlined copies of a particular function, then their common, shared properties are kept in the abstract origin so that they aren't duplicated everywhere.\n\nOne unique property that inlined subroutines have is a call site.\n\nThis is the location in our source code where we wrote the actual function call, but the optimizer replaced it.\n\nHere for instance, we made the call to `generateANumber` on line 36 of the main.swift file.\n\nThis lets us update our tree with new child nodes.\n\nAnd now this is looking like a much more comprehensive view of our program.\n\nThe optimization details for inlined functions were the key details in getting us to the fully symbolicated crash log.\n\nThe `-i` flag for `atos` instructs the tool to consider them during symbolication.\n\nThey were also the missing details from our Instruments trace.\n\nThe reason why we needed a dSYM both for Instruments and for the crash log was precisely so that we could extract all of this content.\n\nThere is another source where you'll find DWARF, and that is from static libraries and object files.\n\nIn the absence of a dSYM, you can still gather DWARF for functions that you linked from a static library or object file.\n\nIn those cases, you'll find the Debugging Symbols nlist types.\n\nThese were one of the symbol types that could be stripped.\n\nThey don't hold the DWARF themselves though.\n\nRather, they associate a function back to the file they came from.\n\nIf the library was built with debug information, then the nlist entry can point us to that DWARF.\n\nThese types of nlist entries can be seen verbosely with `dsymutil -dump-debug-map`.\n\nHere we have the list of different functions and where they were pulled from.\n\nThose locations can be scanned and processed for DWARF.\n\nTo summarize, DWARF is a vital source of in-depth symbolication data.\n\nDWARF exposes important relationships between functions and files.\n\nOptimizations such as function inlining have an enormous impact on the quality of symbolication, and DWARF can express it very well.\n\nWe also saw that dSYMs and static libraries contain DWARF.\n\nHowever, please prefer dSYMs as you can easily transfer them to others and have built-in support from several tools.\n\nFinally, I want to share different tools and tips you can use to facilitate symbolication.\n\nFor local development builds, you'll generally have a great deal of debug information if you build in debug mode.\n\nFor release mode, you can ensure that Xcode generates a dSYM by checking the Debug Information Format build setting.\n\nMake sure Release is set to DWARF with dSYM File.\n\nFor apps that were submitted to the App Store, you can download your dSYMs through App Store Connect.\n\nThis also includes any apps with bitcode enabled.\n\nIf you want to check that a certain dSYM is already on your device, you can use the `mdfind` command.\n\nThe alphanumeric string here is your binary's UUID, which is a unique identifier defined in a load command.\n\nYou can see the UUID for your dSYMs with `symbols -uuid`.\n\nSometimes, a toolchain could generate invalid DWARF.\n\nYou can check this with `dwarfdump -verify`.\n\nIf you see any reported errors, please file a bug! DWARF data also has a cap of four gigabytes per binary.\n\nIf you're running into issues with your dSYMs and see that they're exceeding four gigabytes, consider splitting the project into separate components so that each one has its own smaller dSYM.\n\nYou can make sure that the dSYM you're using matches the specific build of your app that you're interested in by comparing UUIDs.\n\nThe app's UUID is in the Binary Images list section of crash reports and you can also see it with the `symbols` command.\n\nYou should ensure that both your app and your dSYM have the same UUIDs.\n\nThe `symbols` tool also lets you check the types of debug information your app has available.\n\nWe've already seen examples of this, but it's a helpful reminder that these tags in square brackets tell you the information source.\n\nIt's useful if you aren't sure which debug information you might be dealing with.\n\nIf you're certain that you have dSYMs available but still aren't getting names for your functions in Instruments traces, please check your entitlements and code signing.\n\nSpecifically, with the `codesign` command, you can verify that you have a proper code signature.\n\nYou should also verify that locally built apps for development have the `get-task-allow` entitlement.\n\nThis entitlement grants permissions to tools such as Instruments to symbolicate your app.\n\nXcode should set this entitlement automatically with the Profile action, but it's helpful to verify.\n\nIf you don't have the `get-task-allow` entitlement enabled, you should check your Code Signing Inject Base Entitlements build setting and make sure that it's enabled as you're developing.\n\nLastly, for Universal 2 apps, you should specify the architecture that you're interested in to the tools.\n\n`symbols`, `otool`, and `dwarfdump` all have an `-arch` flag to only operate on a particular architecture slice.\n\nThis concludes \"Symbolication: Beyond the basics.\" If nothing else, I want to really emphasize a few key points.\n\nUUIDs and file addresses are a consistent and reliable way to identify what your app was doing since they're independent of the ASLR slide.\n\nThey're also our key to querying the debug info.\n\nYou should also use dSYMs whenever possible.\n\ndSYMs contain the richest debug information in the form of DWARF and are supported by Xcode and Instruments.\n\nLastly, we covered several tools.\n\nThese tools are readily available to you in Xcode and they offer powerful diagnostics and insights.\n\nYou should strive to incorporate them into your workflows for debugging and optimizing.\n\nIf you're interested in learning more, I recommend these two sessions from WWDC18 to learn how your apps spring to life upon launch: \"Optimizing app startup time\" and \"App startup time: Past, present, and future\".\n\nThank you all very much for joining me to learn about symbolication! Have a wonderful rest of the week.\n\n♪",
    "segments": []
  },
  "codeExamples": [
    {
      "timestamp": "1:11",
      "title": "MagicNumbers",
      "language": "swift",
      "code": "func selectMagicNumber(choices: [Int]) -> Int {\n    return choices[MAGIC_CHOICE]\n}\n\nfunc randomValue() -> Int {\n    return Int.random(in: 1...100)\n}\n\nfunc numberChoices() -> [Int] {\n    var choices = [Int]()\n    for _ in 1...10 {\n        choices.append(randomValue())\n    }\n    return choices\n}\n\nfunc generateMagicNumber() -> Int {\n    let numbers = numberChoices()\n    let magic = selectMagicNumber(choices: numbers)\n    return magic\n}\n\nprint(\"The magic number is: \\(generateMagicNumber())\")"
    },
    {
      "timestamp": "2:51",
      "title": "atos symbolication",
      "language": "swift",
      "code": "atos -o MagicNumbers.dSYM/Contents/Resources/DWARF/MagicNumbers -arch arm64 -l 0x10045c000 -i 0x10045fb70"
    },
    {
      "timestamp": "7:34",
      "title": "Load commands",
      "language": "swift",
      "code": "otool -l MagicNumbers | grep LC_SEGMENT -A8"
    },
    {
      "timestamp": "10:31",
      "title": "Disassembly",
      "language": "swift",
      "code": "otool -tV MagicNumbers -arch arm64"
    },
    {
      "timestamp": "11:32",
      "title": "vmmap",
      "language": "swift",
      "code": "vmmap MagicNumbers | grep __TEXT"
    },
    {
      "timestamp": "15:09",
      "title": "Function starts",
      "language": "swift",
      "code": "symbols -onlyFuncStartsData -arch arm64 MagicNumbers"
    },
    {
      "timestamp": "17:06",
      "title": "nlist_64",
      "language": "swift",
      "code": "struct nlist_64 {\n    union {\n        uint32_t  n_strx;\n    } n_un;\n    uint8_t n_type;\n    uint8_t n_sect;\n    uint16_t n_desc;\n    uint64_t n_value; \n};"
    },
    {
      "timestamp": "17:59",
      "title": "Direct symbols with nm",
      "language": "swift",
      "code": "nm -arch arm64 —defined-only --numeric-sort MagicNumbers"
    },
    {
      "timestamp": "18:30",
      "title": "Demangled direct symbols with nm",
      "language": "swift",
      "code": "nm -arch arm64 —defined-only --numeric-sort MagicNumbers | xcrun swift-demangle"
    },
    {
      "timestamp": "18:43",
      "title": "Demangled direct symbols with the symbols tool",
      "language": "swift",
      "code": "symbols -arch arm64 -onlyNListData MagicNumbers"
    },
    {
      "timestamp": "23:06",
      "title": "Indirect symbols with nm",
      "language": "swift",
      "code": "nm -m —arch arm64 --undefined-only --numeric-sort MagicNumbers"
    },
    {
      "timestamp": "27:16",
      "title": "Examining dSYMs with dwarfdump",
      "language": "swift",
      "code": "dwarfdump -v -debug-info -arch arm64 MagicNumbers.dSYM"
    },
    {
      "timestamp": "29:25",
      "title": "atos symbolication without inlined functions",
      "language": "swift",
      "code": "atos -o MagicNumbers.dSYM/Contents/Resources/DWARF/MagicNumbers -arch arm64 —l 0x10045c000 0x10045fb70"
    },
    {
      "timestamp": "32:29",
      "title": "Examining debugging symbols",
      "language": "swift",
      "code": "dsymutil --dump-debug-map -arch arm64 MagicNumbers"
    },
    {
      "timestamp": "33:59",
      "title": "Examining dSYM UUIDs",
      "language": "swift",
      "code": "symbols -uuid MagicNumbers.dSYM"
    },
    {
      "timestamp": "34:03",
      "title": "Verifying DWARF",
      "language": "swift",
      "code": "dwarfdump —verify MagicNumbers.dSYM"
    },
    {
      "timestamp": "35:09",
      "title": "Verifying entitlements and codesigning",
      "language": "swift",
      "code": "codesign --display -v  --entitlements :- MagicApp.app"
    }
  ],
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2021/10211/3/3450A29E-DC2D-49D5-9D68-5E053CC5EC9D/downloads/wwdc2021-10211_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2021/10211/3/3450A29E-DC2D-49D5-9D68-5E053CC5EC9D/downloads/wwdc2021-10211_sd.mp4?dl=1"
  },
  "relatedVideos": [
    {
      "id": "110370",
      "year": "2022",
      "title": "Debug Swift debugging with LLDB",
      "url": "https://developer.apple.com/videos/play/wwdc2022/110370"
    }
  ],
  "extractedAt": "2025-07-18T09:43:35.961Z"
}