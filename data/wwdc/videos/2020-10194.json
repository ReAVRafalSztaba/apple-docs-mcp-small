{
  "id": "10194",
  "year": "2020",
  "url": "https://developer.apple.com/videos/play/wwdc2020/10194/",
  "title": "Add configuration and intelligence to your widgets",
  "speakers": [],
  "duration": "",
  "topics": [
    "App Services"
  ],
  "hasTranscript": true,
  "hasCode": false,
  "transcript": {
    "fullText": "Hello and welcome to WWDC.\n\nWelcome to \"Add Configuration and Intelligence to Your Widgets.\" My name is Ian, and I'm here with my colleague Kelvin.\n\nIn this talk, we'll show you how to make widgets configurable, and show you how a configurable widget can help the system work in more intelligent ways.\n\nNew in iOS 14 and macOS Big Sur, we have a whole new widget experience. Widgets allow your app to surface new information to people in exciting new ways.\n\nWidgets can live in more places than ever. They can live on pages of the Home Screen, as part of Stacks, on the Today View, and in macOS Notification Center.\n\nPowering those widgets is WidgetKit. WidgetKit allows you to create multiple widgets, each to solve its own unique problem. Each widget can support different sizes and layouts. Let's take a look at an example.\n\nWe've built an example app that lets you view all of the transactions on your credit cards. It lets you view information about your spending and track balances on all of your accounts. The two most common things that I do in the app are check balances and look at recent transactions. It would be really great to see this information right at a glance on the Home Screen, so we built two widgets for our app.\n\nThe first one is called \"Recent Purchases,\" which shows a list of purchases on one of your cards. The other one is called \"Due Date,\" which shows your next payment's due date and how much you owe.\n\nBecause I often want to see information about one card at a time, we added configuration to pick which card to show. I can change which card is shown by tapping on \"Edit Widget\" and then selecting a card.\n\nBecause we made our widget configurable, now people can create multiple different instances of the Due Date widget and show a different card in each.\n\nNow let's look at what we're going to cover today. First, we'll talk about the basics of how to add configuration to your widget. Next, we'll talk about the types of information that you can ask the user to enter, and show how to populate the interface with data from your app.\n\nAfter that, we'll talk about how you can customize the title, description and colors of the backside of your widget. And finally, we'll cover how adding configuration to your widget allows the system to better predict times to display your widget in a stack.\n\nLet's start with the basics. The first piece of the system is the widget extension. Widget extensions contain SwiftUI code that renders the visual appearance of the widget. They also contain some metadata about the widget itself.\n\nBefore you get started, make sure that you have set up a widget extension already using WidgetKit and SwiftUI. If you haven't done that yet, make sure to go watch the \"Meet WidgetKit\" talk.\n\nWhen your widget is configurable, you can specify which options to ask the user on the backside of the widget, and the system will display them for you. These questions are called parameters.\n\nHere's our Recent Purchases widget. It has a \"Card\" parameter and a \"Category\" parameter. The Card parameter allows people to choose a card to display, and the Category parameter lets people filter the list to only include transactions for a specific category, like groceries, if they'd like.\n\nTo define which parameters are shown, we use intents, which is the same system that you can use to add support for Siri and Shortcuts to your app.\n\nAn intent contains an ordered list of parameters. Each parameter that you put on the intent will show up as a row in the widget's configuration UI.\n\nYou declare your intents in Xcode using an Intent Definition File. This file contains all of your intents, their parameters, and indicates which parts of the system they support. By compiling this file into your app, the system will be able to read information about your intents.\n\nOnce you define an intent, Xcode will also generate an intent class for you, containing a property for each parameter. For this widget, we have a ViewRecentPurchasesIntent class, with Card and Category properties.\n\nAn instance of this intent class will be passed into the widget extension at runtime, allowing your widget to know what the user has configured and what to display. Next, let's talk about the types of parameters that you can add to your intent. As I mentioned before, we build the widget configuration UI for you, based on the intent's definition. We support a wide variety of input types, which I'll walk you through now. When you specify \"String\" as the type of your parameter, the configuration UI shows a text field, and it will show a switch for the \"Boolean\" parameter. The configuration UI also supports numbers with a few different input mechanisms. For integers, it supports number fields and steppers, and for decimals, it supports number fields and sliders.\n\nThe configuration UI also has support for contact and location pickers. The \"Person\" type will show as a contact picker, and the \"Location\" type will show as a location picker.\n\nThe configuration UI also supports enumerations. You can make these enumerations static, or dynamically populate them with content from your app. We'll talk about dynamic options in more detail later. The configuration UI supports a number of other types as well, each with their own UI. Parameters can also support multiple values. For example, if your widget shows a list of events from your calendars, you can configure the intent to support selecting multiple calendars. New in iOS 14, Intents now supports fixed-size arrays. This is useful if your widget supports showing a fixed number of items, and lets you prevent the user from adding more than a defined number of items into the array. You can specify the number of items based on the widget size in the intent editor. Now I'm going to walk you through how to add rich configuration to your widget. The first step is identifying what you want to make configurable. Let's use the Recent Purchases widget here as an example. In the Recent Purchases widget, each widget can only show one card, but people may have multiple cards in the app, so it would make sense to make that configurable.\n\nThis allows people to have multiple Recent Purchases widgets on their Home Screen, each showing different cards.\n\nIt also would be useful to be able to filter by category. That way, people could have one widget to show transportation expenses and another widget to show food expenses.\n\nSo, in addition to making the card configurable, we are also going to allow people to configure the category.\n\nNow I'm going to walk you through how we can make the Recent Purchases widget configurable. This is our project, where we already have our widget set up. You can see that the widget currently has a StaticConfiguration.\n\nIn order to make the widget configurable, we need to switch from a StaticConfiguration to an IntentConfiguration. The first step in switching to an IntentConfiguration is defining an intent that you'll use to configure the widget. You can define a custom intent inside of an Intent Definition File.\n\nI already have one here in this project. You'll note that it is checked in to both the app and the widget extension targets.\n\nNow let's create an intent using the plus button in the bottom left.\n\nI'll be calling it ViewRecentPurchases.\n\nNext we're going to check the \"Intent is eligible for widgets\" option.\n\nThis will allow the intent to work as a configuration for a widget. If you want this intent to also support the Shortcuts app, check the \"Intent is user-configurable in the Shortcuts app and Add to Siri\" option. We'll uncheck this option for this demo and just focus on widgets. We're also going to leave the \"Intent is eligible for Siri Suggestions\" checkbox unchecked for now, and my colleague Kelvin will walk you through how to add intelligence to your widget later in this talk.\n\nWe'll also set the category of this intent to \"View\" because the purpose is to view your transactions.\n\nNow, using the plus button in the parameters list, I am going to add a parameter for the card.\n\nThe first step here is naming the parameter. This label will be displayed in the widget configuration UI. I'm going to name this \"Card.\" Next, I need to pick a type.\n\nBecause a credit card represents an object inside of my app, I'm going to create a custom type to represent it. You'll see that I already created a \"Card\" type, which has a name and identifier, so I'll use that here for my type.\n\nThe list of cards will need to be provided by the app, and will change depending on who is signed in, so I will check the \"Options are provided dynamically\" checkbox.\n\nWe'll go into detail later on how to populate this dynamic list.\n\nSince this intent won't support running in Siri, we can uncheck the \"Siri can ask for value when run\" option Next, because we want to allow people to choose the category, we'll add a \"Category\" parameter to the intent.\n\nWe can use an enum for the type of this parameter because there are a fixed set of categories. I already have an enum defined, so I will choose that.\n\nWe'll set the default value for the category to \"All\" so that people will see all of the transactions by default.\n\nAnd we'll also uncheck the \"Siri can ask for value when run\" option for the category.\n\nNow let's talk about dynamic options and search. In many cases, the data that you want to display in the widget configuration can vary by person, and can't be specified up front in the Intent Definition File. For example, the list of cards in our example app varies by person. You can accomplish this by implementing dynamic options.\n\nYou can enable dynamic options for any parameter on an intent by checking the \"Dynamic Options\" checkbox in Xcode. Enabling dynamic options will indicate to the system that it should consult your app to retrieve the possible values that a person can choose from, instead of allowing them to enter any value that they want. Once you enable dynamic options, two things will happen. First, the visual appearance of your parameter will change on the backside of the widget into a button that opens a modal list of options.\n\nSecond, two methods will be generated for you to implement in your app, one to provide a list of possible options, and a default value.\n\nThese methods are part of the intent handler protocol, which Xcode generates for you. You will need to make a class that conforms to this protocol, either in your app or in an Intents extension. This class will be asked by the system to provide possible options while the person is configuring your widget.\n\nIn the example app, the two methods that we need to implement are provideCardOptionsCollection and defaultCard. For provideCardOptionsCollection, we will load the list of cards that the user has set up and then call the completion handler. For defaultCard, we return the primary card that the user has set up.\n\nThe provideCardOptionsCollection method lets you either provide a flat list of cards or a list of sections containing cards.\n\nFor example, we can display a section for each type of card, like credit or debit. If you use sections, your UI will look like this.\n\nNow all of my credit cards show under the \"Credit\" section, and I can see more sections containing other types of cards.\n\nBy default, the search bar at the top will filter the options that you provide. In some cases, your app might have more data than you can easily provide up-front in a list. If that's the case, you can provide search results as the person types. These results can include options outside of the standard options that you provide dynamically.\n\nTo do this, make sure to check the \"Intent handler provides search results as the user types\" checkbox and also provide a prompt.\n\nIf you check the checkbox, the provideCardOptionsCollection method will get a search term parameter.\n\nWhen a person first looks at the list, this method will get called with a nil search term, and then as they start typing, the method will get called again with the updated search term. Now let's do a quick demo of how you can implement dynamic options. Continuing from our last demo, let's go ahead and implement returning the list of cards to the user dynamically. The first step is setting up the intent handler for the ViewRecentPurchases intent. We're going to put our intent handler inside of an Intents extension. I already have an Intents extension set up for our other widget, so I can add my code there.\n\nThe next step is making our intent handler conform to the ViewRecentPurchases intent handling protocol.\n\nYou can see that this protocol has a single required method, which is the provideCardOptionsCollection method. We need to implement this such that it returns a list of cards inside of the app.\n\nFirst, I create custom Card objects from the objects inside of my app. Then I put them into the INObjectCollection, which allows me to add sections if I want.\n\nI don't have any sections in mind here, so I will just create the collection from a list of items, and then call the completion handler with the created collection.\n\nThere's also an optional method to provide a default card.\n\nThe default is used when a widget is dragged onto the Home Screen for the first time, so it's really important to provide a good default.\n\nNow that we've created our intent and implemented our intent handler, we can adopt the IntentConfiguration in our widget.\n\nIt's very similar to the StaticConfiguration that we had before, but it takes an intent type as an argument.\n\nYou'll also need to switch your TimelineProvider to be an IntentTimelineProvider.\n\nIt's very similar to the default TimelineProvider, but the methods have an additional intent argument that you use to determine what to show.\n\nHere, we’ll need to take the card from the intent and use that to determine which purchases to show. Previously, it was just showing the purchases from the default card.\n\nLet's run the code and try to configure the widget.\n\nNotice that when I drag out the widget, it shows me transactions from the default card.\n\nThis is because I implemented the default card method.\n\nNow if I go and flip it around and tap on the \"Card\" button, it shows me a list of cards.\n\nTapping on the \"Category\" option also shows a list of categories.\n\nVoilà.\n\nNow let's talk about a few ways that you can further customize the appearance of your widget configuration UI. You can customize the title and the description by using the SwiftUI modifiers called \"configurationDisplayName\" and \"description\" in your widget extension.\n\nNext is colors. You can style the background and the accent color of the widget configuration UI to match your app's color scheme.\n\nTo do this, you'll need to add named colors to your widget extension's asset catalog. Here we're adding one for the accent color and another one for the background color.\n\nAnd then you'll need to add the names of your colors to your widget extension's build settings for \"Global Accent Color Name\" and \"Widget Background Color Name.\" Another thing you might want to do is hide and show specific parameters based on another parameter. For example, in the Calendar widget, if you turn off the \"Mirror Calendar App\" switch, the \"Calendar\" parameter appears, and you can manually choose which calendar to show.\n\nLet's take a look at the Intent Definition File to see how to specify the relationship between Mirror Calendar App and Calendar.\n\nTo specify that we only want the \"Calendar\" parameter to show up when the \"Mirror Calendar App\" option is off, make the \"Mirror Calendar App\" parameter a parent of the \"Calendar\" parameter.\n\nTo do that, we'll select the \"Calendar\" parameter, then select \"Mirror Calendar App\" as its parent.\n\nThen we'll set it up to show only if the parent has the exact value of \"false\". Now the \"Calendar\" parameter will only show up if the \"Mirror Calendar App\" is turned off. That's it from me. Now over to Kelvin to talk about system intelligence and widgets.\n\nHi, I'm Kelvin, and I work on the Proactive team here at Apple. Next, we're going to talk about system intelligence. Widgets are one of the most exciting new opportunities across iOS, iPadOS and macOS. On iOS 14, not only can you add widgets to the Home Screen, you can stack multiple widgets together and provide access to a variety of widgets in one place by easily swiping through.\n\nEveryone will find a different way to take advantage of this, but it's easy to imagine that you could group multiple widgets together that would be useful as you progress through your day. Now, what's exciting about Stacks is that the system can automatically rotate widgets to the top of the stack to provide useful and timely information.\n\nLet me walk you through the underlying design principles that drive stack intelligence, and how you should implement some new APIs to ensure your app is part of this new Home Screen experience. Let's dig a little deeper into what makes for a good Smart Stack.\n\nStacks should provide timely and glanceable information with obvious value to the user.\n\nYou want your widget to be surfaced when you have timely information relevant to the people using your app, like when you know there is a thunderstorm coming, but not when you're just updating the temperature regularly. Broadly speaking, the system will try to surface widgets based on two reasons. The first is user behavior-based. We want to surface widgets that provide information the user typically looks for at a particular time. For example, if someone frequently launches your weather app to check on the weather, the system can instead surface your widget with that information to provide quicker access to what they're looking for.\n\nThe second is based on relevant information from your app. So, for example, if a thunderstorm is happening, your widget can inform the system that it has a highly relevant update, and the system will consider surfacing your widget to the top of the stack.\n\nNow let's talk about the APIs you can use to provide the information the system needs to surface your widget.\n\nLet's start with user behavior.\n\nSo the system wants to surface your widget when someone is typically looking in your app for information, and in iOS 12, we introduced the concept of Shortcuts and custom intent donations, which provides a way for the system to understand what people do in your app. And using this information, the system provides predictions in Spotlight on what actions they want to perform.\n\nNow, new in iOS 14, these same donations will also inform the system about when would be a good time to surface your widget.\n\nSo now, let's continue from our previous example with the Recent Purchases widget. Here we have already set up an intent for widget configuration. It allows a user to specify the credit card and the category they want to view. Now, to enable system intelligence to rotate to our widget, we have to set this same intent for donation by our host app.\n\nThe idea here is we want to inform the system when a user is checking a particular credit card in our app, and we will do so by donating this intent. We'll describe what happens under the hood in just a bit. So for now, let's dive into some details about how to set it up.\n\nFirst, we need to mark this intent as eligible for Siri Suggestions, and that opens up the bottom section here labeled \"Suggestions.\" And for our example, we want the system to predict when someone will check a particular credit card, and we want it to match any widget with that same card configured. In order to convey that, we need to add a \"Supported Combinations\" with just the Card parameter.\n\nAnd so now that we have set up our custom ViewRecentPurchases intent, we need to have our host app donate it whenever the user views recent purchases in our host app. And to do that, we create an INInteraction object and call the donate function, passing in our intent.\n\nAnd since we've specified a \"Supported Combinations\" as just the Card parameter, even if we provided the Category parameter in our donation, the system will only consider the Card parameter. And that's all you have to do. The system will do the rest. Now let's take a closer look at what the system does with your donations under the hood. So let's say someone views grocery purchases for our AcmeCard regularly at noon, and checks their SoupPay card for restaurant purchases in the evenings. Now, our host app would donate intents like this.\n\nAnd based on these donations, the system would recognize that the user typically checks their AcmeCard at noon. And then on Friday at noon, the system would predict the intent for viewing AcmeCard and would surface our widget, as long as they have configured it to show their AcmeCard regardless of the category.\n\nBut what if instead we added both Card and Category as a supported combination? Let's look at what would happen. Now, since Category is part of the supported combination, you are telling the system that it is an important parameter. Then on Friday at noon, the system would predict the intent for viewing AcmeCard in the \"Groceries\" category, which would only surface widgets where the user has explicitly configured both parameters to show the AcmeCard for the \"Groceries\" category.\n\nSo, in short, \"Supported Combinations\" is the way to communicate to the system which configurable parameter truly represents the information people are looking for.\n\nWe walked through a lot of steps there, so to quickly summarize, first, set up a configuration for your widget with an intent. Second, mark it as eligible for Siri Suggestions to allow the system to predict it.\n\nNext, configure \"Supported Combinations\" for only the parameters that you want the system to predict. And finally, donate the intent when the user views that information in your host app. Now let's talk about the second scenario, where you want the system to surface your widget when you have important, relevant information.\n\nSo, a quick recap. Using WidgetKit, you provide timeline entries that will determine what your widget will look like at various points in time. It works great whether your widget can schedule your entries ahead of time, like this weather example where you can provide forecasts for future views. It also works if your widget needs to react to new information in real time, like our Recent Purchases example, where you can only provide each entry as they occur. So now, let's say we know that people using our app want to be alerted if they got a charge for over $50.\n\nHow can you inform the system that your widget has relevant information for the Acme Books purchase? You can convey that information by supplying a TimelineEntryRelevance object with your TimelineEntry.\n\nA TimelineEntry has effectively three components: a date time stamp that determines when this entry should be rendered, the view that should be rendered, and the relevance of this entry. The relevance is a TimelineEntryRelevance object, which has two fields: a score and a duration.\n\nAnd here's what it looks like in Swift. Let's start with the score. The score is a value indicating how relevant an entry is compared to all entries provided in the past. The range and scale is largely up to you to define, as the system only considers the score in relation to other entries. The only exception being a score of zero or lower will indicate to the system that your widget currently has no relevant information and should not be surfaced. Now, coming back to our example, we want to convey to the system that we have important information when there is a purchase of more than $50. We can simply provide a score of one when that happens to emphasize the importance, and a score of 0.1 for all other purchases. That way, there will be a slight chance the system might surface our widget for the minor purchases, but will try to prioritize for the big purchase. When there is no important information, like when we have no recent purchases at 8:04 a.m., we set a score of zero. And keep in mind, it doesn't matter what scores other widgets provide. Scores are only compared within the scores you provide. Now, on the other hand, let's say we think the amount spent is a good indicator of relevance. We can set the amount spent to be the score, and the system will likewise prioritize surfacing the expensive purchases. Next, let's talk about duration. The duration is a field for situations where you have a well-defined period of time where the relevance score will be fixed. Otherwise, feel free to leave duration as zero, which will mean the relevance score will last until the next TimelineEntryRelevance is received.\n\nHere's an example to highlight how duration can be used. We want to build a basketball widget that shows the progress of a game as it occurs. So, at the beginning of the game, we can create an entry with a score of one and a fixed duration for the length of the game. During the game, we can continue to make TimelineEntry updates without affecting the relevance by just leaving the TimelineEntryRelevance field as nil. Setting the entry as nil is how you can tell the system to ignore this update for relevance purposes. So to wrap up, with Smart Stacks, we have an opportunity to surface your widget on top of a stack. You can make this work for your widgets in two ways. First, by donating intents from your app that match configuration of your widget, and secondly, by providing TimelineEntryRelevance when your widget has important information. Thanks for watching. We can't wait to see what kind of configurable, intelligent widgets you will build.",
    "segments": []
  },
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2020/10194/2/F906ACBE-2D67-4594-B041-E1F11352CF3A/wwdc2020_10194_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2020/10194/2/F906ACBE-2D67-4594-B041-E1F11352CF3A/wwdc2020_10194_sd.mp4?dl=1"
  },
  "relatedVideos": [
    {
      "id": "10231",
      "year": "2021",
      "title": "Donate intents and expand your app’s presence",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10231"
    },
    {
      "id": "10048",
      "year": "2021",
      "title": "Principles of great widgets",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10048"
    },
    {
      "id": "10086",
      "year": "2020",
      "title": "Design for intelligence: Apps, evolved",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10086"
    },
    {
      "id": "10088",
      "year": "2020",
      "title": "Design for intelligence: Discover new opportunities",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10088"
    },
    {
      "id": "10087",
      "year": "2020",
      "title": "Design for intelligence: Make friends with \"The System\"",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10087"
    },
    {
      "id": "10200",
      "year": "2020",
      "title": "Design for intelligence: Meet people where they are",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10200"
    },
    {
      "id": "10028",
      "year": "2020",
      "title": "Meet WidgetKit",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10028"
    },
    {
      "id": "10068",
      "year": "2020",
      "title": "What's new in SiriKit and Shortcuts",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10068"
    },
    {
      "id": "10035",
      "year": "2020",
      "title": "Widgets Code-along, part 2: Alternate timelines",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10035"
    },
    {
      "id": "10036",
      "year": "2020",
      "title": "Widgets Code-along, part 3: Advancing timelines",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10036"
    }
  ],
  "extractedAt": "2025-07-18T09:16:55.602Z"
}