{
  "id": "325",
  "year": "2025",
  "url": "https://developer.apple.com/videos/play/wwdc2025/325/",
  "title": "Discover Apple-Hosted Background Assets",
  "speakers": [],
  "duration": "",
  "topics": [
    "App Services",
    "App Store, Distribution & Marketing",
    "Graphics & Games"
  ],
  "hasTranscript": true,
  "hasCode": true,
  "transcript": {
    "fullText": "Hello, I'm Gabriel. I’m a software engineer on the App Store team. And my name is Jenny. I’m an engineer on the App Processing team. Today, we’re introducing a new way to distribute assets for your app on the App Store with Background Assets. I’ll cover how your app and assets work together on people’s devices. And I will share how you can use Apple hosting for your assets.\n\nIn this session, we will first review the current available asset delivery technologies, including Background Assets. Then dive into what’s new this year, including new Swift and Objective-C APIs to manage your Background Assets, as well as Apple hosting.\n\nWe will show you how to integrate the new features into your app for iOS, iPadOS, macOS, tvOS, and visionOS, and how to do local testing.\n\nIf you would like that Apple host and deliver your assets, we will walk you through how to prepare for beta testing and App Store distribution.\n\nNow, let’s hear from Gabriel for a recap and what’s new in Background Assets.\n\nThanks, Jenny. When people download an app from the App Store, they expect to use it immediately. They may leave or even delete your app if they must wait for other downloads to finish after opening it.\n\nWith Background Assets, we’re making it even easier to deliver a great first launch experience. You can configure how the system downloads your assets on devices and update them without needing to update your main app. For example, you could deliver a tutorial level only to people who newly download a game to get them playing quickly while the rest of the game is downloaded in the background, offer optional downloadable content, also known as DLC, that you unlock with In-App Purchase, or update on device machine learning models with an accelerated submission process to the App Store. Suppose that you’re developing a game with several different levels, including a tutorial. You have four options for delivering the assets for each level: Keeping everything in your main app bundle, URLSession, On-Demand Resources, or Background Assets. There are pros and cons to some of them, so let me go through it.\n\nKeeping everything in your main app bundle forces people to wait for all of the assets to download, even if you only need some of them to start the tutorial level. You could also hit the 4GB size limit on most platforms, and updating just one of your assets would require re-uploading and resubmitting your entire app. On-Demand Resources would let people jump into the tutorial more quickly, because it lets you download some parts of your app bundle separately from TestFlight or the App Store, but you would still need to update your entire app just to update a few asset files. On-Demand Resources is a legacy technology, and it will be deprecated.\n\nIts successor is Background Assets, with which you host your app’s assets on your own server. You can update those assets at any time without updating your whole app. At the core of Background Assets is the downloader extension, which lets you write code to schedule asset downloads before people open your app. This is great when you need full control over download behavior and post-processing. For many of you, though, we know that what matters most is that your app’s assets simply be available and up to date. With the new Managed Background Assets features, the system automatically manages downloads, updates, compression, and more for your asset packs.\n\nIn fact, we’ve written a system-provided download or extension that you can drop into your app with no custom code needed.\n\nPlus, with the new Apple-Hosted Background Assets service for apps on TestFlight and the App Store, you no longer need to host your assets on your own server with the Apple hosting option. You get 200GB of Apple hosting capacity included in your Apple Developer Program membership.\n\nIf you’re still using On-Demand Resources, then we suggest that you start your migration to Background Assets.\n\nWith Managed Background Assets, you create multiple asset packs that each group together some of your asset files, such as the textures, sound effects, and GPU shaders for a tutorial level in a game. The system automatically downloads an asset pack on people’s devices based on its download policy. There are three download policies: Essential, Prefetch, and On-demand.\n\nAn essential download policy means that the system automatically downloads the asset pack and integrates the download into the installation process. The asset pack contributes to the overall download progress that people see in the App Store, in TestFlight, and on the home screen. And once the installation finishes and a person opens your app, the asset pack is ready to use.\n\nA prefetch download policy means that the system starts downloading the asset pack during the installation of the app, but the download could continue in the background after the app’s installation finishes. An on-demand download policy means that the system downloads the asset pack only when you explicitly call an API method to request it.\n\nYou can either host your asset packs yourself or let Apple host them for you. Now, I’ll hand it over to Jenny to cover how Apple servers deliver asset packs and app builds. Sure thing! Each Apple hosted asset pack can be used on one app, across multiple platforms of your choice.\n\nFor the device to download the app binary and any asset pack it uses, you will first need to separately upload both to App Store Connect. You can then submit them for review for external testing in TestFlight and App Store distribution.\n\nOnce uploaded, the asset pack is assigned a version, and it is not tied to any specific app build. How the app and asset pack match up on the device is determined by the state of the asset pack version. Let me explain with some examples.\n\nLet’s say you have three different versions for the same asset pack. Version 1 is live on the App Store, Version 2 is live for external beta on TestFlight, and Version 3 is live for internal beta on TestFlight. Only one version of the asset pack can be live for each context.\n\nAt the same time, you have some app builds on devices that are downloaded from the App Store, or through TestFlight external beta or internal beta.\n\nThe server will select to deliver the live version of your asset pack for all your app builds in that particular context.\n\nThat means app version 1.0 build 1 that is downloaded from the App Store will use asset pack version 1.\n\nApp version 2.0 build 1 that is available for external beta in TestFlight will use asset pack version 2. And app version 2.0 builds 2 and 3 in internal beta will use asset pack version 3.\n\nNow, it is important to understand the behavior when you make updates to the Asset Pack version.\n\nFor example, if you’re happy with asset pack version 2, you can submit it for App Store distribution. It will replace the old version to be live on the App Store.\n\nThis means all versions of your app downloaded from the App Store will automatically be switched over to using asset pack version 2, including older versions that are still installed on people's devices. So, before you update the asset pack, make sure that it will work on older app builds and versions as well. Now, let’s look at an example for app build update. Let’s say you want to submit app version 2.0 build 3 for external beta testing. After approval, if the build is downloaded through external beta, it will use the older asset pack version 2. If you would like it to be paired with the newer asset pack version 3, make sure to submit the asset pack version as well. Now that you’re familiar with the concept of asset packs, Gabriel will walk you through how to create them and use them in your app. Thanks, Jenny. Now, let me show you how to use Managed Background Assets in your app.\n\nTo get started with Managed Background Assets, you’ll create asset packs, adopt the new APIs, and test your app and asset packs locally.\n\nLet me explain how to create an asset pack.\n\nYou can use the new packaging tool for macOS, Linux, and Windows that takes files from your source repository and packages them into a compressed archive for delivery to TestFlight and the App Store. The packaging tool ships with Xcode on macOS and will soon be available to download from the download section of the Apple developer website for Linux and Windows. Let me show you the tool in action.\n\nYou can start by running the template command to generate a manifest template. On macOS, install Xcode and run xcrun ba-package template in Terminal. On Linux or Windows, make the tool available in your shell’s search path and run ba-package template.\n\nThe packaging tool will generate a manifest template. The manifest is a JSON file that you fill out to tell Apple about your asset pack. You can choose a custom ID. This is what you’ll use to identify the asset pack in your app’s code, a download policy, and the set of platforms that the asset pack supports.\n\nFirstly, let's fill in the file selectors. A file selector selects a set of files in your source repository to include in your asset pack. There are two types of file selectors: ones that select individual files, and ones that select entire directories.\n\nLet’s add a file selector for the game’s introductory cutscene video, using a relative path from the root of the source repository.\n\nThis asset pack’s ID is Tutorial because  it contains the asset files for the game’s Tutorial level. Now, let's configure the download policy. Since the tutorial is the first thing that people experience, let’s make the tutorial asset pack available locally before someone can open the game for the first time. So, this is a great situation in which to use an essential download policy.\n\nThis tutorial level is relevant only for people who newly install the game. People who already play the game and are simply updating to a new version shouldn’t need to download the tutorial again.\n\nSo let’s restrict the essential download policy to just the first installation and exclude subsequent updates. This means that only someone who downloads the game on their device for the first time will get the tutorial’s assets.\n\nNow that the manifest is filled out, let’s run the packaging tool again to generate a compressed archive. We’ll set the current directory to the root of the repository and pass in the path to the manifest and the path at which to save the archive. Now that the asset pack is packaged, let’s see how we can use it in the game.\n\nWith just a few lines of code, you can use the new APIs in Background Assets to read the files in your asset packs. We’ll start by adding a downloader extension in Xcode. The downloader extension is how your app schedules asset packs to be downloaded when the main app isn’t running, such as during the installation process.\n\nLet’s add a new target and select the Background Download template.\n\nHere you can choose whether you want to use Apple hosting or your own.\n\nThe template generates Swift code, but you can easily replace it with Objective-C code if you prefer.\n\nNewly this year, the system now provides a fully-featured downloader extension that supports automatic downloads, background updates,and more, which you can drop into your app with no custom code. The snippet that Xcode generates with the Background Download template is already configured to use the system implementation by default. There's no other extension code to write.\n\nIn fact, you can even remove the stub shouldDownload(_:) method entirely if you don’t need to customize the download behavior. This means that you can now add a downloader extension to your app with just a few lines Xcode generated code.\n\nIf you do want to customize the download behavior, then you can provide a custom implementation for shouldDownload(_:). The system calls your shouldDownload(_:) implementation for every new asset pack that, based on the asset pack’s download policy, it plans to download in the background, and you can return a Boolean value to decide whether to proceed with the download. This can be useful if some of your asset packs have specific compatibility requirements. Now that you’ve implemented the downloader extension, let’s see how to use files inside downloaded asset packs in your main app.\n\nThe first step is to call the ensureLocalAvailability(of:) method on the shared AssetPackManager. This method checks whether the asset pack is currently downloaded. If it isn’t, then it starts downloading it and waits for the download to finish.\n\nIn most cases, the downloader extension will have already downloaded the asset pack, so the method will return quickly. In the rare situation in which the asset pack must be newly downloaded, it’s a good idea to provide visible progress information to people using your app.\n\nIn Swift, you can await status updates on the asynchronous sequence that the statusUpdates(forAssetPackWithID:) method returns.\n\nIn Objective-C, you can create an object that conforms to the BAManagedAssetPackDownloadDelegate protocol and attach it to the shared asset pack manager’s delegate property.\n\nIf you need to cancel a download, then you can do so by calling cancel() on any of the progress structures that you receive in the download status updates. Once ensureLocalAvailability(of:) returns without throwing in error, the requested asset pack is ready to use locally.\n\nTo read a file from it, call the contents(at:searchingInAssetPackWithID:options:) method on the shared asset pack manager. The first parameter is a relative path from the root of your source repository, that is, the directory from which you previously ran the packaging tool to create the asset pack, to the file that you want to read. The system automatically merges all of your asset packs into a shared namespace, effectively reconstructing your source repository as if it were copy-pasted from your development machine into people’s devices. This means that you don’t need to worry about keeping track of which asset pack contains a particular file when you want to read that file at runtime. By default, contents(at:searchingInAssetPackWithID:options:) returns a memory mapped data instance, which is suitable even for large asset files that take up a lot of space in memory.\n\nIf you need low-level access to the file descriptor, such as for reading a file into memory procedurally, then you can use the descriptor(for:searchingInAssetPackWithID:) method instead, in which case it’s your responsibility to close the descriptor when you’re done using it. You can also restrict the search to a particular asset pack by providing a non-nil argument for the assetPackID parameter of either method.\n\nThe system tracks which asset packs your app has downloaded and automatically keeps them up to date in the background. It won’t, however, automatically remove your asset packs while your app remains installed, so it’s a good practice to call the remove(assetPackWithID:) method on the shared asset pack manager to free up storage space when you don’t expect to use a particular asset pack anymore. For example, you could remove the Tutorial asset pack when someone finishes playing the tutorial level.\n\nYou can always call ensureLocalAvailability(of:) to re-download the asset pack again should, for example, someone reset their progress in the game and start playing the tutorial again.\n\nKeep in mind that people can see the storage space that your downloaded asset packs take up listed for your app in the storage view in the Settings app on their device.\n\nThe next step is to add both your main app and your downloader extension to the same app group. The system uses the app group to facilitate coordination between your main app and your extension.\n\nThen add the BAAppGroupID key to your main app’s Info.plist with your app group ID as string value.\n\nAlso, add the BAHasManagedAssetPacks key with true or yes as its Boolean value.\n\nIf you’re using Apple hosting, then add the BAUsesAppleHosting key with true or yes as its Boolean value. If you’re not using Apple hosting, then refer to the related documentation in the Resources section for this session to learn more about the other required Info.plist keys, including BAManifestURL. Now that the app and the extension are configured, it's time to test.\n\nWe created a new Background Assets mock server for macOS, Linux, and Windows to test asset pack downloads before you submit your app to TestFlight or the App Store. Like the packaging tool, the mock server ships with Xcode on macOS and will soon be available to download from the Downloads section of the Apple Developer website for Linux and Windows.\n\nBackground Assets uses HTTPS for all downloads, so you first need to issue an SSL certificate. To do that, you’ll create a root certificate authority. Then you’ll install that certificate authority on your test devices. After that, you'll use the certificate authority to issue an SSL certificate, and finally, you’ll start the mock server and point it to that SSL certificate. For more details, refer to the related documentation in the Resources section for this session. Once you’ve issued your SSL certificate, you can run ba-serve to start the mock server, pass in the respective paths to the Asset Pack archives that you want to serve, and set the host to which to bind.\n\nThe host can be an IP address, a host name, or a domain name. On macOS, the tool will prompt you to choose an identity, that is, a pair of a certificate and a private key from your keychain. On Linux or Windows, you’ll need to pass in the certificate and its private key on the command line. Pass the help flag to learn about additional options, including an option to set a custom port number, and coming soon on macOS, the ability to skip the identity prompt. On iOS, iPadOS and visionOS test devices, and coming soon on tvOS test devices, go to Development Overrides in Developer Settings to enter your mock server’s base URL, including its host and port. On macOS test devices, run xcrun ba-serve url-override to enter the same information.\n\nWhen you build and run your app from Xcode, it’ll download its asset packs from your mock server. Now, I’ll hand it back to Jenny to talk about beta testing and distributing your asset packs. - Jenny? - Thanks Gabriel. Now that you have the new app binary and asset packs ready, let me take you through how to prepare them for beta testing on TestFlight and distribution on the App Store.\n\nIf you’re using Apple hosting, you will upload both your app binary and asset packs to App Store Connect separately, optionally test with TestFlight, and finally distribute on the App Store.\n\nLet’s take a deeper look at how this process works for asset packs. There are several ways to upload an asset pack.\n\nFor a drag and drop UI experience, you can use the Transporter app for macOS.\n\nFor full control and transparency, you can use the App Store Connect REST APIs to build your own automation.\n\nFor a simplified command line interface, the cross platform iTMSTransporter provides useful commands and makes requests for you to the App Store Connect APIs. You can check out the documentation for all of these tools. Here, I will walk you through using Transporter and the App Store Connect API. With the Transporter app, simply drag and drop your Tutorial.aar archive into the Transporter window.\n\nAdd it to the app of your choice, then click Deliver. It will become a new version of the Tutorial asset pack.\n\nYou will be able to see the state of your asset pack upload right in the Transporter app.\n\nIf you would like full visibility of the upload process, you can use the App Store Connect API. You will need to follow three steps: create asset pack record, create version record for the asset pack, then upload the archive to the asset pack version.\n\nFirst, to create the asset pack record, you can make a POST request to the backgroundAssets resource.\n\nIn the request body, put in the name of the asset pack as the assetPackIdentifier and add your app’s Apple ID in the relationships section. The response of this call will return a UUID to your asset pack, which you can use in later API calls.\n\nThen you will create a new version for your asset pack by making a POST request to the backgroundAssetVersions resource.\n\nIn the relationships section, use the ID of the asset pack provided to you by the previous API response. This operation automatically increases the version number based on existing versions. Here we will have version 1. You will also get an ID in the response to uniquely identify version 1 of the Tutorial asset pack.\n\nWhen the asset pack version is successfully created, you can use the backgroundAssetUploadFiles resource to make an upload reservation for your Tutorial.aar archive file. This step is to other upload operations like App Store screenshots.\n\nHere you would need the asset type, file name, file size, and MD5 checksum.\n\nAlso include the relationship to the background asset version ID. The response of this call includes an ID for your upload file, and details about the upload instructions.\n\nWhen you successfully upload your archive, make a PATCH call to the backgroundAssetUploadFiles with your Upload File ID, and your asset pack will start processing.\n\nTo view the asset pack’s progress, you can always get the most comprehensive information about your available asset packs in App Store Connect or using the App Store Connect APIs.\n\nOn App Store Connect, you can find the asset pack processing status under the TestFlight tab. Once the upload is successfully processed, the status will become Ready for Internal Testing. This means your new version is ready to be used in your app builds that are live for internal testing in TestFlight. You will receive an email informing that your new asset pack version is ready. You can also set up a webhook to get this notification.\n\nFeel free to check out the WWDC25 session “Automate your development process with the App Store Connect API” to find out more about the webhook features this year.\n\nHowever, during processing, if there is an issue discovered with your asset pack archive file, the version state will become Failed and you will be notified as well. You can fix the issue accordingly, and upload the asset pack again as a new version.\n\nUsing App Store Connect APIs, there are many resources you can make GET requests to, to see a list of all asset packs for your app, versions for each asset pack, and their respective states. You can follow the progress of your upload with the backgroundAssetVersions resource.\n\nWhen your asset pack is processed, an Internal Beta Releases resource will be created. It will show you that the asset pack version is READY_FOR_TESTING.\n\nAfter you successfully upload both your app binary and asset pack, you can start beta testing in TestFlight.\n\nOn App Store Connect, you can see that currently Tutorial version 1 is ready for internal testing. If you’d like to test your app build and asset pack version with a wider audience, you can separately submit them for external testing.\n\nTo submit an asset pack, click on the specific version and select Submit for External Testing. When the version is approved, it will see the state change to Ready for External Testing and you will receive a notification.\n\nWith App Store Connect APIs, you can also submit the asset pack version using the betaBackgroundAssetReviewSubmissions resource.\n\nYou can follow the state of the review with the external beta releases resource. It will show you when the asset pack version is ready for external testing.\n\nAfter testing, when you’re ready to make your asset pack version available on the App Store, you can submit it to App Review for App Store distribution.\n\nYou can head to the distribution tab on App Store Connect and view asset packs. Now, you can submit one asset pack version by itself or alongside other asset packs, an app version, and perhaps other review items together. If you submit an asset pack version and an app version together, the App Review team will use your selected asset pack version to review your app.\n\nTo add an asset pack for review, click on Select Asset Pack, choose the version, and add for review.\n\nWhen the submission is approved, you will see that the asset pack version is Ready for Distribution.\n\nUsing the App Store Connect API, you can also submit for review using the reviewSubmissions resource.\n\nDuring the review, you can see the review states on the App Store releases resource. When it reaches ready for distribution, that means the people using your app will be able to download the new assets from the App Store.\n\nWow, we covered quite a lot of topics today. We talked about asset packs, how to create one and use it in your app, and how to upload and submit for Apple hosting.\n\nWe hope that you find this session helpful to get started with the new Managed Background Assets.\n\nNow it's your turn. Try using the packaging tool to create your first asset pack. Then, if your app still uses On-Demand Resources, evaluate how you can migrate to Background Assets. Take a look at the documentation and adopt the new Background Assets APIs in your app. Finally, we want your feedback. Please let us know what works for you and what doesn’t using Feedback Assistant.\n\nYou can also check out everything else that’s new this year in App Store Connect by watching the “What’s new in App Store Connect” session. Plus, learn more about existing Background Assets features, including some helpful tips for local testing, with the “What’s new  in Background Assets” session from WWDC23.\n\n- Thanks for joining us. - And we look forward to your feedback.",
    "segments": []
  },
  "codeExamples": [
    {
      "timestamp": "8:26",
      "title": "Fill out the manifest",
      "language": "swift",
      "code": "{\n\t\"assetPackID\": \"[Asset-Pack ID]\",\n\t\"downloadPolicy\": {\n\t\t\"essential\": { // Possible keys: “essential”, “prefetch”, or “onDemand”\n\t\t\t// Essential and prefetch download policies require a list of installation event types. For an on-demand download policy, the value for the “onDemand” key must be an empty object.\n\t\t\t\"installationEventTypes\": [\n\t\t\t\t// Remove undesired elements from this array.\n\t\t\t\t\"firstInstallation\",\n\t\t\t\t\"subsequentUpdate\"\n\t\t\t]\n\t\t}\n\t},\n\t\"fileSelectors\": [\n\t\t// You can add as many file and/or directory selectors as you want.\n\t\t{\n\t\t\t\"file\": \"[Path to File]\"\n\t\t},\n\t\t{\n\t\t\t\"directory\": \"[Path to Directory]\"\n\t\t}\n\t],\n\t\"platforms\": [\n\t\t// Remove undesired elements from this array.\n\t\t\"iOS\",\n\t\t\"macOS\",\n\t\t\"tvOS\",\n\t\t\"visionOS\"\n\t]\n}"
    },
    {
      "timestamp": "10:44",
      "title": "Add a downloader extension",
      "language": "swift",
      "code": "import BackgroundAssets\nimport ExtensionFoundation\nimport StoreKit\n\n@main\nstruct DownloaderExtension: StoreDownloaderExtension {\n\t\n\tfunc shouldDownload(_ assetPack: AssetPack) -> Bool {\n\t\treturn true\n\t}\n\t\n}"
    },
    {
      "timestamp": "11:39",
      "title": "Download an asset pack",
      "language": "swift",
      "code": "let assetPack = try await AssetPackManager.shared.assetPack(withID: \"Tutorial\")\n\n// Await status updates for progress information\nlet statusUpdates = AssetPackManager.shared.statusUpdates(forAssetPackWithID: \"Tutorial\")\nTask {\n\tfor await statusUpdate in statusUpdates {\n\t\t// …\n  }\n}\n\n// Download the asset pack\ntry await AssetPackManager.shared.ensureLocalAvailability(of: assetPack)"
    },
    {
      "timestamp": "12:22",
      "title": "Receive download status updates in Objective-C",
      "language": "swift",
      "code": "#import <BackgroundAssets/BackgroundAssets.h>\n\n@interface ManagedAssetPackDownloadDelegate : NSObject <BAManagedAssetPackDownloadDelegate>\n\n@end\n\n@implementation ManagedAssetPackDownloadDelegate\n\n- (void)downloadOfAssetPackBegan:(BAAssetPack *)assetPack { /* … */ }\n\n- (void)downloadOfAssetPackPaused:(BAAssetPack *)assetPack { /* … */ }\n\n- (void)downloadOfAssetPackFinished:(BAAssetPack *)assetPack { /* … */ }\n\n- (void)downloadOfAssetPack:(BAAssetPack *)assetPack hasProgress:(NSProgress *)progress { /* … */ }\n\n- (void)downloadOfAssetPack:(BAAssetPack *)assetPack failedWithError:(NSError *)error { /* … */ }\n\n@end"
    },
    {
      "timestamp": "12:29",
      "title": "Attach the delegate in Objective-C",
      "language": "swift",
      "code": "static void attachDelegate(ManagedAssetPackDownloadDelegate *delegate) {\n\t[[BAAssetPackManager sharedManager] setDelegate:delegate];\n}"
    },
    {
      "timestamp": "12:33",
      "title": "Cancel an asset-pack download",
      "language": "swift",
      "code": "let statusUpdates = AssetPackManager.shared.statusUpdates(forAssetPackWithID: \"Tutorial\")\nfor await statusUpdate in statusUpdates {\n\tif case .downloading(_, let progress) = statusUpdate {\n\t\tprogress.cancel()\n\t}\n}"
    },
    {
      "timestamp": "12:41",
      "title": "Use an asset pack",
      "language": "swift",
      "code": "// Read a file into memory\nlet videoData = try AssetPackManager.shared.contents(at: \"Videos/Introduction.m4v\")\n\n// Open a file descriptor\nlet videoDescriptor = try AssetPackManager.shared.descriptor(for: \"Videos/Introduction.m4v\")\ndefer {\n\tdo {\n\t\ttry videoDescriptor.close()\n\t} catch {\n\t\t// …\n\t}\n}"
    },
    {
      "timestamp": "13:56",
      "title": "Remove an asset pack",
      "language": "swift",
      "code": "// Remove the asset pack\ntry await AssetPackManager.shared.remove(assetPackWithID: \"Tutorial\")\n\n// Redownload the asset pack\nlet assetPack = try await AssetPackManager.shared.assetPack(withID: \"Tutorial\")\ntry await AssetPackManager.shared.ensureLocalAvailability(of: assetPack)"
    },
    {
      "timestamp": "14:53",
      "title": "Info.plist",
      "language": "swift",
      "code": "<key>BAAppGroupID</key>\n<string>group.com.naturelab.thecoast</string>\n<key>BAHasManagedAssetPacks</key>\n<true/>\n<key>BAUsesAppleHosting</key>\n<true/>"
    }
  ],
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "Configuring your Background Assets project",
        "url": "https://developer.apple.com/documentation/BackgroundAssets/configuring-background-assets"
      },
      {
        "title": "Downloading asset packs hosted by Apple",
        "url": "https://developer.apple.com/documentation/BackgroundAssets/downloading-asset-packs-hosted-by-apple"
      },
      {
        "title": "Testing your asset packs locally",
        "url": "https://developer.apple.com/documentation/BackgroundAssets/testing-asset-packs-locally"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2025/325/6/cda561c7-42e2-4bcb-a7a2-e52259a23c5d/downloads/wwdc2025-325_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2025/325/6/cda561c7-42e2-4bcb-a7a2-e52259a23c5d/downloads/wwdc2025-325_sd.mp4?dl=1"
  },
  "relatedVideos": [
    {
      "id": "324",
      "year": "2025",
      "title": "Automate your development process with the App Store Connect API",
      "url": "https://developer.apple.com/videos/play/wwdc2025/324"
    },
    {
      "id": "328",
      "year": "2025",
      "title": "What’s new in App Store Connect",
      "url": "https://developer.apple.com/videos/play/wwdc2025/328"
    },
    {
      "id": "10108",
      "year": "2023",
      "title": "What’s new in Background Assets",
      "url": "https://developer.apple.com/videos/play/wwdc2023/10108"
    }
  ],
  "extractedAt": "2025-07-18T09:10:37.120Z"
}