{
  "id": "10169",
  "year": "2024",
  "url": "https://developer.apple.com/videos/play/wwdc2024/10169/",
  "title": "Migrate your app to Swift 6",
  "speakers": [],
  "duration": "",
  "topics": [
    "Developer Tools"
  ],
  "hasTranscript": true,
  "hasCode": true,
  "transcript": {
    "fullText": "Hi, I'm Ben from the Swift team, and in this video, I’m going to walk you through enabling the Swift 6 language mode in an existing application. We’ll see how Swift 6 helps protect you against possible race conditions, and look at some techniques for introducing this change gradually into your app, as well as how to deal with interactions with frameworks that aren’t yet aware of Swift’s concurrency guarantees. I'm going to be using a simple app that tracks coffee consumption throughout the day, as well as a complication to show your current caffeine level on a watch face. When we first introduced Swift concurrency at WWDC 2021, I walked you through how to adopt Swift’s new concurrency model in this app. In that talk, you see how a seemingly clean app architecture sometimes hides the hidden complexity of concurrency. If you look at the views and models, everything is well organized. But delving into how concurrency is managed shows a different picture. The original app had 3 concurrent queues on which code could be executing. Work in the UI, and on the model, was done on the main queue. The app also had a dispatch queue for doing work in the background. And finally, certain callbacks into completion handlers, like those returning results from HealthKit, were done on arbitrary queues. So while the types were organized neatly, the way concurrency was organized throughout the app was not such a clear story.\n\nWhich queue was executing code, and why, weaved through the types in a way that was not clear in various places.\n\nBy adopting Swift concurrency, we went from this ad-hoc concurrency architecture. To something that looked like this. The UI views and models were set to run on what’s called the main actor, while background operations were performed on dedicated actors. The actors communicated between each other using thread-safe value types, using Swift’s async/await feature. When we were done, the concurrency architecture was as clear and easy to describe as the type architecture. But there was one wrinkle. When doing this refactoring to improve the architecture, there was still a lot of responsibility on me, the programmer, to avoid data races. I followed all the guidelines, and used value types to communicate between my actors, but I didn’t have to. I could have taken a reference type, like a class, and passed it, for example, from one actor to another. Reference types allow shared mutable state to be passed around and when you do that, you can break the mutual exclusion the actors provide by allowing them to both access shared state simultaneously. So, if I sent an instance of a class from one actor to another, it’s still possible to get data races that could cause my program to crash, or worse, to corrupt user data. This brings us to is the benefit of Swift 6.\n\nThe Swift 6 language mode introduces full enforcement of data isolation. The compiler will prevent this kind of accidental sharing of state between tasks and actors, allowing you to carry out refactoring, or add new functionality to your app, without worrying that you’re introducing new concurrency bugs.\n\nThe Swift 6 language mode is opting for both existing and new projects. Adopting it can significantly improve the quality of your app by catching mistakes in concurrent code at compile time. It can be especially useful if you are experiencing hard-to-reproduce crashes, and want to go through and methodically eliminate the risk of data races. And if you're actively working on integrating more concurrency to improve responsiveness and performance, adopting Swift 6 mode can ensure that those changes don't risk introducing new data races.\n\nIf you maintain a public Swift package, we encourage you to adopt Swift 6 as soon as possible to help your users who want to migrate their code bases, too. They will benefit from building on top of dependencies that have also adopted Swift 6. Everyone can follow along on the adoption of Swift 6 in popular packages on swiftpackageindex.com. Today, we’re going to see how this works in practice. We’re going to take our CoffeeTracker application, and enable Swift’s data isolation. We’ll do this step-by-step, and look at some of the guidance the compiler gives us, about where we need to make changes to allow Swift to guarantee that CoffeeTracker is free of any data races. Now, I don’t believe that my app actually contains any data races today. And chances are, the same is going to be true of your code, too. You might have already shaken out most of the data races in your existing code through years of refinement, bug reports, using the main thread checker, thread sanitizer, and so on. The real value of data race safety is protecting against bugs in new code that you write, either adding new features, or refactoring existing code to take better advantage of concurrency. Data race safety allows you to leverage concurrency in your app without fear of introducing new data races that you'll later have to hunt down or put in a speculative fix for, because you can't reproduce a crash. Since we last saw it, our coffee tracking app has really taken off, and we’ve expanded the team to start adding new features.\n\nAs part of that we’ve factored some of the app into a new framework, CoffeeKit, and some of the code now lives in there. The team is keen to start adding new features to the app, but before we do that, we’re going to update it to Swift 6 so we know we’re not going to be introducing new concurrency bugs when we do that. Now, I’ve just downloaded Xcode 16 and opened it up. This means I have the new Swift 6 compiler and the latest SDK for watchOS 11, let’s try and build the app.\n\nAnd it builds just fine. No need for any updates. But that’s not because our app was free of any possibly data races. It’s just that we haven’t enabled the Swift 6 language mode yet. Just like with previous releases, Swift 6 has a source compatibility guarantee. Aside from very minor changes, your app should always build with the new compiler.\n\nNow that we know our app builds with the latest Xcode, we want to take the next step of enabling Swift 6 mode, which brings full data-isolation enforcement. Now, in preparation for this, you could go through and try to do MainActor and Sendable audits before enabling any of the compiler diagnostics. But this is missing out on the benefits that the new Swift compiler brings you. The compiler diagnostics will guide you towards the places that need fixing. Think of it like a pair programmer that's pointing out potential bugs in your code. This helps add some structure to the migration process. We’re going to follow a step-by-step process where we migrate each one of the targets in our code. With each target we’re going to follow these steps: First, we’ll enable complete concurrency checking. This is a per-module setting that leaves your project in Swift 5 mode, but enables warnings for all the code that would fail with Swift 6’s enforced data isolation. We’re going to go through, resolving all of these warnings for that target.\n\nOnce that is done, then we enable Swift 6 mode. This locks in all of our changes, and prevents any future refactorings from regressing to an unsafe state. We then move onto the next target and repeat the process. Finally, once that is enabled, we might want to go back and do some whole-app refactoring, perhaps to undo some unsafe opt outs by altering the architecture, or perform some refactoring you spotted that would make the code nicer. One bit of advice about refactoring: try and resist the temptation to blend together both significant refactoring, and enabling data race safety. Try to do one at a time. If you try to do both at once, you’ll probably find it too much change at once, and have to backtrack.\n\nIn this talk, we’re going to focus only on the step of enabling Swift 6 in an app that we already refactored previously to use Swift concurrency. So we start with enabling complete checking. What does complete checking enable? If you’ve already been using Swift Concurrency in your app, you’ve probably seen warnings or errors from the Swift compiler about concurrency issues that came up as you adopted Swift’s concurrency features. For example, here we’re working on adding a new delegate, that’s going to receive a callback we’re adding for CoffeeKit to tell me when my caffeine levels are worryingly low. This delegate is going to publish a value back to my SwiftUI view, so I want it to be isolated to the Main Actor. So I can add an @MainActor to the top, requiring all its methods and property accesses to be made on the main thread. When I do this, though, I get an error lower down in the code, on the implementation of the protocol.\n\nIt’s telling me that a “Main actor-isolated instance method 'caffeineLevel(at:)' cannot be used to satisfy nonisolated protocol requirement”. This CaffeineThresholdDelegate protocol now makes no guarantees about how it’s going to be called. It’s inside CoffeeKit and that hasn’t been updated to Swift 6 yet. But here I’m conforming my Recaffeinater type to it, and I just_constrained it to the main actor. Its methods are going to run on the main actor, so they can’t just conform to a protocol that isn’t always guaranteed to be called on the main actor. We’ll come back to this issue and resolve it shortly. But this is an example of an error that the swift compiler generates because you opted a type into checking that it was being called on the main actor. If you watched the previous talk, adopting Swift concurrency in Coffee Tracker, you will have seen these issues coming up as concurrency was being adopted in different places in the app.\n\nEnabling strict checking in a target’s build settings opts your entire module into being checked for possible race conditions. Let’s enable that now, and see what happens. Data isolation in Swift is enabled on a per-target basis, and in my app, I have two key targets, the WatchKit extension, where my UI layer lives, and CoffeeKit, a framework where the business logic for tracking the caffeine and saving it to HealthKit lives.\n\nI’m going to start by enabling complete checking on the watch extension. There are two reasons for this. First, it’s often the simpler place to enable concurrency checking. Much of the UI layer will run on the main thread, and will be using APIs, like SwiftUI or UIKit, that are themselves guaranteed to perform operations on the main thread. The other reason is, when enabling strict concurrency you’re often going to be working with other modules that haven’t yet been updated for Swift concurrency. Maybe you’re using a C library that will never be updated. Or maybe it’s a framework or package module that will get updated to Swift 6, just hasn’t been yet. And that, of course, includes our own CoffeeKit framework. We’ll see why going top down like this helps once we get started. So, as a first step, let’s go to our extension, and go to its settings. And we’re going to search for the Swift concurrency checking setting and we’re going to set it to Complete checking.\n\nOnce we do this, the compiler is going to start emitting warnings about code it can’t confirm is concurrency safe. These are just going to be warnings, our project will still build and run. So let’s try building.\n\nAnd, we see a few more warnings, in addition to the one we introduced earlier. Let’s take a look at them.\n\nNow, the first issue we can see is one of the most common issues to deal with in Swift 6, referring to this “logger” variable.\n\nWe see a logger instance declared as a global variable. Global variables are a source of shared mutable state, every bit of code in your program, no matter what thread it runs on, is able to read and write to this same variable. So this can be a really easy source of data races, and we need to make it safe. We have a few options as to how. In fact if we expand the issue, we see the compiler is recommending some.\n\nFirst option is the easiest, we just make it read only. Logger is a Sendable type, and that means that if it’s declared as a let variable, it can’t cause data races when used from multiple threads. So switching this var to a let. And rebuilding.\n\nMakes that issue go away. Now, this is the right fix, but there were other options here.\n\nSuppose I don’t want it to be immutable, let’s say I want to update the value later. So I want to keep it as a var not a let.\n\nAnother option is to tie this global variable to a global actor. Here, I’m in my UI layer, so maybe all my logging is going to happen on the main actor. So I can annotate this global variable with @MainActor, and yes, all my logging use is from the main actor so that also eliminates the warnings.\n\nFinally, sometimes I have some other external mechanism protecting this variable, that the compiler can’t enforce. Perhaps I’m guarding all access using a dispatch queue. In that case, I can use the nonisolated(unsafe) keyword.\n\nLike other uses of the word “unsafe” in Swift, this puts the burden on you to ensure safety for this variable. This should be a last resort, it’s best to use Swift’s compile time guarantees instead. But the compiler can’t know about everything, so nonisolated(unsafe) is available as an option for you in those cases. This might be an example of something where I want to come back later and refactor this code, maybe move this variable into an actor so the compiler can verify it’s being used safely. But for now, I could mark is as nonisolated(unsafe) and move on to the next warning. This is not one of those cases, so I’m going to go back to declaring this variable as a let, that’s the best option. Now you might wonder about this initializer here, that initializes the global. When does that get run? Isn’t that important to know to understand thread safety? Global variables in Swift are initialized lazily. The value is initialized on first use, the first time CoffeeTracker logs something. This is a really important difference when compared to C and Objective-C. In those languages, global variables are initialized on startup. And this can be really bad for launch times. Swift’s lazy initialization avoids these problems, allowing your app to get to a useable state faster. But lazy initialization also can introduce races: what if two threads try to log for the first time with this global variable simultaneously? Could they create two loggers? Well don’t worry — in Swift, global variables are guaranteed to be created atomically. If two threads tried to access the Logger simultaneously for the first time, only one would initialize it, while the other one blocked waiting. OK, that’s resolved that issue, let’s look at the next ones.\n\nHere we have some code accessing the shared instance of WKApplication. This global instance method is an example of one that’s isolated to the main actor.\n\nThe first note here is pointing out that calls to actor-isolated state are implicitly asynchronous, that is, if this were an async function, you could use await to access this global variable on the main actor. This function isn’t asynchronous, so we’d have to mark it async, or start a new task. But the compiler is offering us another fix, we can just put this function, on the main actor.\n\nSince this is a free function, not a method on our view, it’s not defaulting to be on the main actor. Let’s apply the fixit, and now this method is isolated to the main actor, and if we try and build, it succeeds.\n\nTo see why this worked, let’s have a quick look at the callers.\n\nWe can see it’s called two times, both from methods that I know are on the main actor. If this function was being called anywhere not on the main actor, I would have got a compiler error telling me so, and I could go look at that caller and see what context it was calling from. One is a SwiftUI view. And the other is in the implementation of WKApplicationDelegate. Let’s go look at that.\n\nIf we option-click WKApplicationDelegate, we can see it’s a protocol that’s tied to the main actor. This is a guarantee that it will only be called on the main actor, either by the WatchKit framework, or once you enable Swift 6 mode, by your code.\n\nMany delegates, and other protocols like SwiftUI views, that are designed to operate only on the main actor, have been annotated like this, especially in the latest SDKs that come with Xcode 16. Most importantly, this includes the SwiftUI View protocol. You will probably find if you previously enabled strict concurrency checking, you had to add more main actor annotations than are necessary with the new SDKs, and that you might be able to remove some of those annotations. Now, let’s talk a bit about delegate callbacks and concurrency. You probably already know that whenever you receive a callback, from a delegate or a completion handler, you always have to first understand what the concurrency guarantees are on that callback. Some callbacks have a guarantee, they might say in their documentation that all callbacks will always be on the main thread. A lot of UI frameworks give this guarantee, and it’s one of the reasons we aren’t getting that many warnings in our work on this view layer of our watch extension, when we’re marking things as main actor. On the other hand, some delegates do the opposite, they make no guarantees on how they’re called back, saying it will be on some arbitrary thread or queue. This makes a lot of sense for callbacks that are more likely to be coming into the back end of an app. The callbacks received by CoffeeTracker from HealthKit are more like this. In those cases, the user needs to redispatch onto the right queue or actor or do their work in a thread safe way. The trouble with this approach, where each delegate has its own rules that are captured only in documentation, is that this puts a lot of burden on you, the user, to do the right thing. You need to think about where you will be when you’re called back, and where you need to be to do the next part of your logic. And if you forget to check, or forget to redispatch to the right place, you can easily get a data race. What’s worse, let’s say that a callback is already in place and working, and it happened to always be on the main queue but that wasn’t always guaranteed. Then later, some changes happen in that framework, and now it’s coming in on a different queue. But your UI layer was relying on it being on the main queue. What we’re missing here is local reasoning — guarantees that when I’m working in my UI layer, I can't easily be broken by changes happening to the code elsewhere in my app, like them changing the queue they do work on.\n\nSwift concurrency tackles this problem, by making these guarantees, or lack of guarantees, explicit. If a callback doesn’t specify how it’s called back, it’s considered non-isolated, and it can’t access data that requires a certain isolation. On the other hand, if a callback does provide an isolation guarantee, say that it will always be called back on the main actor, then it can annotate the delegate protocol or callback as always being on the main actor, and the receiver of the callback can rely on that guarantee. With that said, let’s go back to that first warning we saw, where our delegate type on the main actor couldn’t conform to a nonisolated protocol. We have a couple of options here, which the compiler is offering. The first one is to declare the method nonisolated. That means that despite this being a method on a main actor isolated type, this specific method will not be isolated to the main actor. This is the route to go for for callbacks that intentionally make no promises about where they call you back. Of course, this being a view, I probably immediately want to turn around and do some work on the main actor. If I don’t do that, I’ll get a new error when compiling this code, because I’m accessing properties on the view that are protected by the main actor.\n\nI could fix this by starting a task on the main actor.\n\nIn this case though, I know this callback is supposed to be on the main actor, I know it’s coming from my model type inside CoffeeKit that is itself running on the main actor.\n\nOne option, if I maintain the whole codebase, is just to go fix that right now. I can jump to definition and here I see the protocol inside CoffeeKit. I could annotate it with @MainActor here, to guarantee it’s going to get called on the main actor. But sometimes you don’t maintain the whole codebase like this. Maybe another team maintains CoffeeKit, or it’s a package or framework you rely on maintained by someone else. Let’s assume this were the case here, and go back to our delegate implementation.\n\nNow, I know that this method is getting called on the main actor, I just checked the code, or maybe I read it in some documentation for this delegate.\n\nWhen you know for certain that a call will be on a particular actor, there is a method you can use to tell the compiler this, it’s called assumeIsolated. So instead of the code starting a task, I can write MainActor.assumeIsolated. This doesn’t start a new task to async onto the main actor. It just tells Swift that this code is already running on the main actor.\n\nNote that it’s still perfectly possible for some part of the code to call this function from not the main actor. This is the same as with Swift functions today that assume they’re being called from the main thread. A good way to protect against this is to add an assertion inside the function that you are indeed on the main actor and that’s what assumeIsolated does. If this function is ever not called from the main actor, it will trap and your program will stop running. Trapping isn’t something you want, but it’s better than a race condition that could corrupt user's data.\n\nNow this pattern of conforming to a delegate protocol that assumes its called on the main actor, is common enough that there’s a shorthand for it. So let me undo my changes here, and instead, on the protocol conformance, I write @preconcurrency.\n\nThat does everything I wrote out manually, it assumes it’s being called on the actor this view is isolated to, and it’ll trap if it isn’t.\n\nNow that we’ve eliminated all our concurrency warnings, we’re ready to enable Swift 6 in this target. So we go to settings. And search this time for Swift Language Mode.\n\nAnd we set that to Swift 6.\n\nCompile, and it builds without any errors and warnings. I’ve now locked in full data isolation checking in my extension, and any future changes I make here will have full data isolation checking from the compiler, ensuring I don’t accidentally introduce data races. OK,now that the extension is in Swift 6 mode, let’s turn our attention to the CoffeeKit target. Now that we’re working on this target, let’s go and add that @MainActor annotation to our delegate protocol. So let’s find it. Add the main actor annotation, rebuild, and we get a new warning.\n\nThe warning is back in the extension, and it’s on that @preconcurrency attribute we just added.\n\nNow that the compiler can see that this protocol is guaranteed to be on the main actor, the compiler is warning that that pre concurrency attribute is no longer needed. So we can remove it.\n\nOK. with that issue resolved, we can follow the same routine as before, enabling complete concurrency checking. We go to the project settings, and enable it for the CoffeeKit target.\n\nAnd we build.\n\nNow, this time we see more warnings - 11 of them. That’s quite a few warnings for a fairly simple project.\n\nThis is going to be a common experience. You enable complete concurrency checking in your project, and your project generates hundreds or even thousands of warnings. And when that happens, you might worry what you’ve signed up for. It’s important at this point not to panic. It’s common for a large number of warnings to all stem from a few issues. And many of these issues are often quick to fix.\n\nSo, when first cleaning up concurrency warnings, a flurry of simple changes, putting a method onto the main actor, or changing a global to be immutable, can then cut these warnings down very quickly. It’s a good strategy when you first turn on strict checking to go looking for these quick wins and act on them, reducing the warnings with the simplest fixes at first. It’s also good to look out for issues, that are at the root of a very large number of issues. Sometimes a single line change can resolve hundreds of knock-on issues. If you’ve tried out complete checking mode with the previous versions of Xcode, it’s also worth trying with the latest Xcode beta. The newer SDKs include more annotations to help with migration. For example, all SwiftUI views are now tied to the main actor, which means you no longer need to add MainActor annotations to your view types yourself. In fact, you might find you can remove some of those annotations as they’re already are being inferred.\n\nOnce that’s done, you may find yourself with a much smaller number of warnings that are harder to tackle. The other thing to remember is you don’t have to address all these issues in one sitting. If you have to ship a release, or go work on some more pressing change, you can go back into settings and turn strict checking back off. All the changes you made to reduce those warnings will be valid improvements to the code base that you can keep and check in, even if you then go back to minimal checking for a while. You can return to that setting later when you’re ready, and tackle them then. In our case, once we start looking at the warnings, we see a pattern we’ve seen before. Several of these global variables are marked as vars, but I think these are all constants, or don’t need to be mutable, like the logger we saw before. We can resolve all of these fairly quickly. By the way this is a great time to try out your multi-line edit skills.\n\nSo I just highlight the var, then cmd-option-E selects all of them, change them to lets.\n\nBuild.\n\nAnd that eliminates these warnings.\n\nNow, I don’t want to give you the impression I’m making this look easier than it is. This is just a sample project, in a real project, there would be more warnings. But our experience, putting real full-scale projects is that this is a common experience, lots of easy wins, and then a few harder issues to tackle. Let’s take a look at the last errors. They are being caused by us passing around arrays of drinks between different actors. For example, this first one is saying that sending self.currentDrinks to this save method may cause data races. Note that save is a method on another actor. CoffeeData is on the main actor, it needs to be because it’s a SwiftUI ObservableObject.\n\nBut save is on another actor, it’s on this CoffeeDataStore actor that does saving and loading from disk in the background. And if we go back to the warning, you can see that we’re sending to save the same array of drinks we’re keeping in the model as isolated to the main actor.\n\nIf Drink were a reference type, we’d be setting up a potential data race where both the main actor and the storing actor could have access to shared mutable state simultaneously. To address this, let’s take a look at Drink. If we go to the definition, we can see that it’s a struct, with a few immutable properties, all of which are value types. Based on this, it clearly can be made Sendable, and then it would be perfectly fine to store the drinks in one actor, and then send that same array off to another actor.\n\nNow, if this had been an internal type, Swift would just automatically consider this type Sendable for you. But this is a public type, we share it outside CoffeeKit with our CoffeTracker extension.\n\nSwift doesn’t infer sendability for public types automatically for you. It doesn’t do this because marking a type sendable is a guarantee to your clients. This type contains no mutable state today, but maybe I want to change that in future, I don’t want to lock in sendability prematurely. For this reason, Swift requires you to explicitly add Sendable conformances on public types.\n\nNow in this case, I’m happy to do that. Incidentally, this is an example of a single line change I can make that eliminates multiple warnings at once: three different places that were needing the Drink type to be Sendable. In a large project, it might not be three, it could be dozens of warnings in multiple projects. So, let’s go ahead and mark this type Sendable.\n\nWe can recompile.\n\nAnd we see that there’s another type here that isn’t sendable.\n\nNow, it happens this is just an enum, so I can go and mark it sendable, too. But what if it wasn’t, what if it was an Objective-C type, maybe one that could never be sendable because it stores mutable state in a reference type. At this point you might need to make some choices about safety. One option is to reason about that type, and decide, even though it is a mutable reference type, it’s safe because it was a fresh copy, maybe generated by NSCopying. You might decide that even though it’s not sendable, you could protect that class, maybe make the variable private say, and store it in your sendable type anyway. To do that, you could again use the nonisolated(unsafe) keyword.\n\nIf you do that, then the Drink type is now compiling with the Sendable annotation. Now, I know that isn’t necessary, so instead, I’m going to undo that, and instead go to DrinkType, and mark it as Sendable, too.\n\nNow that we’ve eliminated all our concurrency warnings in CoffeeKit, we’re ready to enable Swift 6 mode in this target. So again we go to settings.\n\nAnd search this time for Swift Language Mode.\n\nAnd we set that to Swift 6.\n\nCompile.\n\nAnd it builds. At this point the whole of our CoffeeTracker app is protected by Swift concurrency.\n\nFinally, now that we’re protected, let’s look at adding a new feature to CoffeeTracker. Our users want to start tracking their location when they have their coffee, so that they can mine that data for key insights into their caffeine habits. So let’s look at adding CoreLocation into our app. So, let’s go to the addDrink method in CoffeeKit. And just before we add our drink, we’re going to use CoreLocation to fetch the user’s current location. CoreLocation has an async sequence that streams current location, that fits very well with Swift concurrency, and we can use it here to loop over the location results until we have the right level of accuracy, at which point we can assign the location to our caffeine sample. You’d probably want to add a timeout to this code, which you could do with Swift’s structured concurrency and cancellation. There’s just one issue with this approach.\n\nWe’d have to raise CoffeeTracker’s minimum deployment target. And we’re not quite ready for that, we still have some users who don’t want to update to watchOS 10, but do really want to track where they’re drinking their coffee. So instead, we’re going to need to use the older CoreLocation APIs based on delegate callbacks. These predate Swift concurrency, so they’ll be a little trickier to use. The really nice thing about the approach we see here is that this code looks like regular synchronous code. We ask for our location, loop over the incoming stream of location updates, until we get one that’s accurate enough, all within this function where we’re adding a new drink to our array. The delegate API, by contrast, will require us to store away some state, wait for the delegate method to fire, and then from there, continue with saving our drink value with a location. So it’s worth trying to raise your deployment target to take advantage of these new APIs.\n\nBut let’s say we don’t want to do that. So instead, let’s remove this new code, and we’re going to go down to the bottom of this file, and create a CoreLocation delegate object.\n\nSo here I have the basic implementation of a delegate class that can receive location updates from CoreLocation. This part of CoreLocation predates Swift concurrency. So I have to do more work to make sure I stick to the rules. Unlike all the other callbacks we’ve seen in this talk, this CLLocation delegate is a bit different. It does not have a static guarantee of what thread it will be called back on.\n\nUp until now, we’ve talked about delegates always called on the main thread, or delegates called on an arbitrary thread. If you look at the documentation for CoreLocationManager, you’ll see that the guarantee it gives is that the thread this delegate is called on is determined by the thread on which you created the CLManager. That’s a dynamic property that Swift cannot automatically enforce for you without some help.\n\nIn our case, we’re using this information from the main actor, in our model type. So, the simplest path would be to ensure this delegate is going to be on the main thread, too. It’s simple to get back into a mode where Swift will help us to enforce that. We put this type entirely on the main actor.\n\nThat means the location manager will be created on the main thread, here in the initializer. And so the delegate will also come in on the main actor.\n\nOf course, once we do that, we get the familiar error from the compiler telling us this delegate callback isn’t isolated to the main actor. We’ve already seen the pattern for how to deal with this.\n\nWe mark the delegate as nonisolated.\n\nAnd then wrap the code that must run on the main actor in a MainActor.assumeIsolated call.\n\nAnd my build has succeeded. We’ve now sourcing current location in our app, still building in Swift 6. This was a quick tour of some of the techniques for migrating your app to the Swift 6 language mode. There are many scenarios we haven’t covered today, but we have more resources available for you. You can start by watching the previous session, which looked at using Swift's concurrency features to modernize an existing app. Much of the path for migrating this code to Swift 6 was made easier by some of the refactoring covered in that talk. Based on lessons from previous migrations, the Swift 6 Language Mode is designed for incremental migration across the Swift ecosystem. So data races can be eliminated one code change at a time. We've only scratched the surface of techniques for bridging between static and dynamic data race safety as we take on this transition as a community. You can find a guide with all of these strategies and more at Swift.org/migration. We hope you find these resources useful as you work on your own code. Thanks for watching!",
    "segments": []
  },
  "codeExamples": [
    {
      "timestamp": "9:08",
      "title": "Recaffeinater and CaffeineThresholdDelegate",
      "language": "swift",
      "code": "//Define Recaffeinator class\nclass Recaffeinater: ObservableObject {\n    @Published var recaffeinate: Bool = false\n    var minimumCaffeine: Double = 0.0\n}\n\n//Add protocol to notify if caffeine level is dangerously low\nextension Recaffeinater: CaffeineThresholdDelegate {\n    public func caffeineLevel(at level: Double) {\n        if level < minimumCaffeine {\n            // TODO: alert user to drink more coffee!\n        }\n    }\n}"
    },
    {
      "timestamp": "9:26",
      "title": "Add @MainActor to isolate the Recaffeinator",
      "language": "swift",
      "code": "//Isolate the Recaffeinater class to the main actor\n@MainActor\nclass Recaffeinater: ObservableObject {\n    @Published var recaffeinate: Bool = false\n    var minimumCaffeine: Double = 0.0\n}"
    },
    {
      "timestamp": "9:38",
      "title": "Warning in the protocol implementation",
      "language": "swift",
      "code": "//warning: Main actor-isolated instance method 'caffeineLevel(at:)' cannot be used to satisfy nonisolated protocol requirement\npublic func caffeineLevel(at level: Double) {\n      if level < minimumCaffeine {\n          // TODO: alert user to drink more coffee!\n      }\n}"
    },
    {
      "timestamp": "9:59",
      "title": "Understanding why the warning is there",
      "language": "swift",
      "code": "//This class is guaranteed on the main actor...\n@MainActor\nclass Recaffeinater: ObservableObject {\n    @Published var recaffeinate: Bool = false\n    var minimumCaffeine: Double = 0.0\n}\n\n//...but this protocol is not\nextension Recaffeinater: CaffeineThresholdDelegate {\n    public func caffeineLevel(at level: Double) {\n        if level < minimumCaffeine {\n            // TODO: alert user to drink more coffee!\n        }\n    }\n}"
    },
    {
      "timestamp": "12:59",
      "title": "A warning on the logger variable",
      "language": "swift",
      "code": "//var 'logger' is not concurrency-safe because it is non-isolated global shared mutable state; this is an error in the Swift 6 language mode\nvar logger = Logger(\n    subsystem:\n        \"com.example.apple-samplecode.Coffee-Tracker.watchkitapp.watchkitextension.ContentView\",\n    category: \"Root View\")"
    },
    {
      "timestamp": "13:38",
      "title": "Option 1: Convert 'logger' to a 'let' constant",
      "language": "swift",
      "code": "//Option 1: Convert 'logger' to a 'let' constant to make 'Sendable' shared state immutable\nlet logger = Logger(\n    subsystem:\n        \"com.example.apple-samplecode.Coffee-Tracker.watchkitapp.watchkitextension.ContentView\",\n    category: \"Root View\")"
    },
    {
      "timestamp": "14:20",
      "title": "Option 2: Isolate 'logger' it to the main actor",
      "language": "swift",
      "code": "//Option 2: Annotate 'logger' with '@MainActor' if property should only be accessed from the main actor\n@MainActor var logger = Logger(\n    subsystem:\n        \"com.example.apple-samplecode.Coffee-Tracker.watchkitapp.watchkitextension.ContentView\",\n    category: \"Root View\")"
    },
    {
      "timestamp": "14:58",
      "title": "Option 3: Mark it nonisolated(unsafe)",
      "language": "swift",
      "code": "//Option 3: Disable concurrency-safety checks if accesses are protected by an external synchronization mechanism\nnonisolated(unsafe) var logger = Logger(\n    subsystem:\n        \"com.example.apple-samplecode.Coffee-Tracker.watchkitapp.watchkitextension.ContentView\",\n    category: \"Root View\")"
    },
    {
      "timestamp": "17:03",
      "title": "scheduleBackgroundRefreshTasks() has two warnings",
      "language": "swift",
      "code": "func scheduleBackgroundRefreshTasks() {\n\n    scheduleLogger.debug(\"Scheduling a background task.\")\n\n    // Get the shared extension object.\n    let watchExtension = WKApplication.shared() //warning: Call to main actor-isolated class method 'shared()' in a synchronous nonisolated context\n\n    // If there is a complication on the watch face, the app should get at least four\n    // updates an hour. So calculate a target date 15 minutes in the future.\n    let targetDate = Date().addingTimeInterval(15.0 * 60.0)\n\n    // Schedule the background refresh task.\n    watchExtension.scheduleBackgroundRefresh(withPreferredDate: targetDate, userInfo: nil) { //warning: Call to main actor-isolated instance method 'scheduleBackgroundRefresh(withPreferredDate:userInfo:scheduledCompletion:)' in a synchronous nonisolated context\n        error in\n\n        // Check for errors.\n        if let error {\n            scheduleLogger.error(\n                \"An error occurred while scheduling a background refresh task: \\(error.localizedDescription)\"\n            )\n            return\n        }\n\n        scheduleLogger.debug(\"Task scheduled!\")\n    }\n}"
    },
    {
      "timestamp": "17:57",
      "title": "Annotate function with @MainActor",
      "language": "swift",
      "code": "@MainActor func scheduleBackgroundRefreshTasks() {\n\n    scheduleLogger.debug(\"Scheduling a background task.\")\n\n    // Get the shared extension object.\n    let watchExtension = WKApplication.shared()\n\n    // If there is a complication on the watch face, the app should get at least four\n    // updates an hour. So calculate a target date 15 minutes in the future.\n    let targetDate = Date().addingTimeInterval(15.0 * 60.0)\n\n    // Schedule the background refresh task.\n    watchExtension.scheduleBackgroundRefresh(withPreferredDate: targetDate, userInfo: nil) {\n        error in\n\n        // Check for errors.\n        if let error {\n            scheduleLogger.error(\n                \"An error occurred while scheduling a background refresh task: \\(error.localizedDescription)\"\n            )\n            return\n        }\n\n        scheduleLogger.debug(\"Task scheduled!\")\n    }\n}"
    },
    {
      "timestamp": "22:15",
      "title": "Revisiting the Recaffeinater",
      "language": "swift",
      "code": "//This class is guaranteed on the main actor...\n@MainActor\nclass Recaffeinater: ObservableObject {\n    @Published var recaffeinate: Bool = false\n    var minimumCaffeine: Double = 0.0\n}\n\n//...but this protocol is not\n//warning: Main actor-isolated instance method 'caffeineLevel(at:)' cannot be used to satisfy nonisolated protocol requirement\nextension Recaffeinater: CaffeineThresholdDelegate {\n    public func caffeineLevel(at level: Double) {\n        if level < minimumCaffeine {\n            // TODO: alert user to drink more coffee!\n        }\n    }\n}"
    },
    {
      "timestamp": "22:26",
      "title": "Option 1: Mark function as nonisolated",
      "language": "swift",
      "code": "//error: Main actor-isolated property 'minimumCaffeine' can not be referenced from a non-isolated context\nnonisolated public func caffeineLevel(at level: Double) {\n    if level < minimumCaffeine {\n        // TODO: alert user to drink more coffee!\n    }\n}"
    },
    {
      "timestamp": "23:07",
      "title": "Option 1b: Wrap functionality in a Task",
      "language": "swift",
      "code": "nonisolated public func caffeineLevel(at level: Double) {\n    Task { @MainActor in\n      if level < minimumCaffeine {\n        // TODO: alert user to drink more coffee!\n    \t}\n    }\n}"
    },
    {
      "timestamp": "23:34",
      "title": "Option 1c: Explore options to update the protocol",
      "language": "swift",
      "code": "public protocol CaffeineThresholdDelegate: AnyObject {\n    func caffeineLevel(at level: Double)\n}"
    },
    {
      "timestamp": "24:15",
      "title": "Option 1d: Instead of wrapping it in a Task, use `MainActor.assumeisolated`",
      "language": "swift",
      "code": "nonisolated public func caffeineLevel(at level: Double) {\n    MainActor.assumeIsolated {\n        if level < minimumCaffeine {\n            // TODO: alert user to drink more coffee!\n        }\n    }\n}"
    },
    {
      "timestamp": "25:21",
      "title": "`@preconcurrency` as a shorthand for assumeIsolated",
      "language": "swift",
      "code": "extension Recaffeinater: @preconcurrency CaffeineThresholdDelegate {\n    public func caffeineLevel(at level: Double) {\n        if level < minimumCaffeine {\n            // TODO: alert user to drink more coffee!\n        }\n    }\n}"
    },
    {
      "timestamp": "26:42",
      "title": "Add `@MainActor` to the delegate protocol in CoffeeKit",
      "language": "swift",
      "code": "@MainActor\npublic protocol CaffeineThresholdDelegate: AnyObject {\n    func caffeineLevel(at level: Double)\n}"
    },
    {
      "timestamp": "26:50",
      "title": "A new warning",
      "language": "swift",
      "code": "//warning: @preconcurrency attribute on conformance to 'CaffeineThresholdDelegate' has no effect\nextension Recaffeinater: @preconcurrency CaffeineThresholdDelegate {\n    public func caffeineLevel(at level: Double) {\n        if level < minimumCaffeine {\n            // TODO: alert user to drink more coffee!\n        }\n    }\n}"
    },
    {
      "timestamp": "27:09",
      "title": "Remove @preconcurrency",
      "language": "swift",
      "code": "extension Recaffeinater: CaffeineThresholdDelegate {\n    public func caffeineLevel(at level: Double) {\n        if level < minimumCaffeine {\n            // TODO: alert user to drink more coffee!\n        }\n    }\n}"
    },
    {
      "timestamp": "29:56",
      "title": "Global variables in CoffeeKit are marked as `var`",
      "language": "swift",
      "code": "//warning: Var 'hkLogger' is not concurrency-safe because it is non-isolated global shared mutable state\nprivate var hkLogger = Logger(\n    subsystem:\n        \"com.example.apple-samplecode.Coffee-Tracker.watchkitapp.watchkitextension.HealthKitController\",\n    category: \"HealthKit\")\n\n// The key used to save and load anchor objects from user defaults.\n//warning: Var 'anchorKey' is not concurrency-safe because it is non-isolated global shared mutable state\nprivate var anchorKey = \"anchorKey\"\n\n// The HealthKit store.\n// warning: Var 'store' is not concurrency-safe because it is non-isolated global shared mutable state\nprivate var store = HKHealthStore()\n// warning: Var 'isAvailable' is not concurrency-safe because it is non-isolated global shared mutable state\nprivate var isAvailable = HKHealthStore.isHealthDataAvailable()\n\n// Caffeine types, used to read and write caffeine samples.\n// warning: Var 'caffeineType' is not concurrency-safe because it is non-isolated global shared mutable state\nprivate var caffeineType = HKObjectType.quantityType(forIdentifier: .dietaryCaffeine)!\n// warning: Var 'types' is not concurrency-safe because it is non-isolated global shared mutable state\nprivate var types: Set<HKSampleType> = [caffeineType]\n\n// Milligram units.\n// warning: Var 'miligrams' is not concurrency-safe because it is non-isolated global shared mutable state\ninternal var miligrams = HKUnit.gramUnit(with: .milli)"
    },
    {
      "timestamp": "30:19",
      "title": "Change all global variables to `let`",
      "language": "swift",
      "code": "private let hkLogger = Logger(\n    subsystem:\n        \"com.example.apple-samplecode.Coffee-Tracker.watchkitapp.watchkitextension.HealthKitController\",\n    category: \"HealthKit\")\n\n// The key used to save and load anchor objects from user defaults.\nprivate let anchorKey = \"anchorKey\"\n\n// The HealthKit store.\nprivate let store = HKHealthStore()\nprivate let isAvailable = HKHealthStore.isHealthDataAvailable()\n\n// Caffeine types, used to read and write caffeine samples.\nprivate let caffeineType = HKObjectType.quantityType(forIdentifier: .dietaryCaffeine)!\nprivate let types: Set<HKSampleType> = [caffeineType]\n\n// Milligram units.\ninternal let miligrams = HKUnit.gramUnit(with: .milli)"
    },
    {
      "timestamp": "30:38",
      "title": "Warning 1: Sending arrays in `drinksUpdated()`",
      "language": "swift",
      "code": "// warning: Sending 'self.currentDrinks' risks causing data races\n// Sending main actor-isolated 'self.currentDrinks' to actor-isolated instance method 'save' risks causing data races between actor-isolated and main actor-isolated uses\nawait store.save(currentDrinks)"
    },
    {
      "timestamp": "32:04",
      "title": "Looking at Drink struct",
      "language": "swift",
      "code": "// The record of a single drink.\npublic struct Drink: Hashable, Codable {\n\n    // The amount of caffeine in the drink.\n    public let mgCaffeine: Double\n\n    // The date when the drink was consumed.\n    public let date: Date\n\n    // A globally unique identifier for the drink.\n    public let uuid: UUID\n\n    public let type: DrinkType?\n\n    public var latitude, longitude: Double?\n\n    // The drink initializer.\n    public init(type: DrinkType, onDate date: Date, uuid: UUID = UUID()) {\n        self.mgCaffeine = type.mgCaffeinePerServing\n        self.date = date\n        self.uuid = uuid\n        self.type = type\n    }\n\n    internal init(from sample: HKQuantitySample) {\n        self.mgCaffeine = sample.quantity.doubleValue(for: miligrams)\n        self.date = sample.startDate\n        self.uuid = sample.uuid\n        self.type = nil\n    }\n\n    // Calculate the amount of caffeine remaining at the provided time,\n    // based on a 5-hour half life.\n    public func caffeineRemaining(at targetDate: Date) -> Double {\n        // Calculate the number of half-life time periods (5-hour increments)\n        let intervals = targetDate.timeIntervalSince(date) / (60.0 * 60.0 * 5.0)\n        return mgCaffeine * pow(0.5, intervals)\n    }\n}"
    },
    {
      "timestamp": "33:29",
      "title": "Mark `Drink` struct as Sendable",
      "language": "swift",
      "code": "// The record of a single drink.\npublic struct Drink: Hashable, Codable, Sendable {\n  //...\n}"
    },
    {
      "timestamp": "33:35",
      "title": "Another type that isn't Sendable",
      "language": "swift",
      "code": "// warning: Stored property 'type' of 'Sendable'-conforming struct 'Drink' has non-sendable type 'DrinkType?'\npublic let type: DrinkType?"
    },
    {
      "timestamp": "34:28",
      "title": "Using nonisolated(unsafe)",
      "language": "swift",
      "code": "nonisolated(unsafe)\npublic let type: DrinkType?"
    },
    {
      "timestamp": "34:45",
      "title": "Undo that change",
      "language": "swift",
      "code": "public let type: DrinkType?"
    },
    {
      "timestamp": "35:04",
      "title": "Change DrinkType to be Sendable",
      "language": "swift",
      "code": "// Define the types of drinks supported by Coffee Tracker.\npublic enum DrinkType: Int, CaseIterable, Identifiable, Codable, Sendable {\n  //...\n}"
    },
    {
      "timestamp": "36:35",
      "title": "CoreLocation using AsyncSequence",
      "language": "swift",
      "code": "//Create a new drink to add to the array.\nvar drink = Drink(type: type, onDate: date)\n\ndo {\n  //error: 'CLLocationUpdate' is only available in watchOS 10.0 or newer\n  for try await update in CLLocationUpdate.liveUpdates() {\n    guard let coord = update.location else {\n      logger.info( \"Update received but no location, \\(update.location)\")\n      break\n    }\n    drink.latitude = coord.coordinate.latitude\n    drink.longitude = coord.coordinate.longitude\n  } catch {\n    \n  }"
    },
    {
      "timestamp": "38:10",
      "title": "Create a CoffeeLocationDelegate",
      "language": "swift",
      "code": "class CoffeeLocationDelegate: NSObject, CLLocationManagerDelegate {\n  var location: CLLocation?\n  var manager: CLLocationManager!\n  \n  var latitude: CLLocationDegrees? { location?.coordinate.latitude } \n  var longitude: CLLocationDegrees? { location?.coordinate.longitude }\n\n  override init () {\n    super.init()\n    manager = CLLocationManager()\n    manager.delegate = self\n    manager.startUpdatingLocation()\n  }\n  \n  func locationManager (\n    _ manager: CLLocationManager, \n    didUpdateLocations locations: [CLLocation]\n  ) {\n      self.location = locations. last\n  }\n}"
    },
    {
      "timestamp": "39:32",
      "title": "Put the CoffeeLocationDelegate on the main actor",
      "language": "swift",
      "code": "@MainActor\nclass CoffeeLocationDelegate: NSObject, CLLocationManagerDelegate {\n  var location: CLLocation?\n  var manager: CLLocationManager!\n  \n  var latitude: CLLocationDegrees? { location?.coordinate.latitude } \n  var longitude: CLLocationDegrees? { location?.coordinate.longitude }\n\n  override init () {\n    super.init()\n    // This CLLocationManager will be initialized on the main thread\n    manager = CLLocationManager()\n    manager.delegate = self\n    manager.startUpdatingLocation()\n  }\n  \n  // error: Main actor-isolated instance method 'locationManager_:didUpdateLocations:)' cannot be used to satisfy nonisolated protocol requirement\n  func locationManager (\n    _ manager: CLLocationManager, \n    didUpdateLocations locations: [CLLocation]\n  ) {\n      self.location = locations. last\n  }\n}"
    },
    {
      "timestamp": "40:06",
      "title": "Update the locationManager function",
      "language": "swift",
      "code": "nonisolated func locationManager (\n  _ manager: CLLocationManager, \n  didUpdateLocations locations: [CLLocation]\n) {\n    MainActor.assumeIsolated { self.location = locations. last }\n}"
    }
  ],
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "Forum: Programming Languages",
        "url": "https://developer.apple.com/forums/topics/programming-languages-topic?cid=vf-a-0010"
      },
      {
        "title": "Swift Migration Guide",
        "url": "https://www.swift.org/migration/documentation/migrationguide/"
      },
      {
        "title": "Updating an app to use strict concurrency",
        "url": "https://developer.apple.com/documentation/Swift/updating-an-app-to-use-strict-concurrency"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2024/10169/6/4E4B2CB2-ABE3-49B7-AA2B-D97C6BF13B49/downloads/wwdc2024-10169_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2024/10169/6/4E4B2CB2-ABE3-49B7-AA2B-D97C6BF13B49/downloads/wwdc2024-10169_sd.mp4?dl=1"
  },
  "relatedVideos": [
    {
      "id": "10194",
      "year": "2021",
      "title": "Swift concurrency: Update a sample app",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10194"
    }
  ],
  "extractedAt": "2025-07-18T09:39:48.743Z"
}