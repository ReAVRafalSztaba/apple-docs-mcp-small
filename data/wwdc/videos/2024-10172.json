{
  "id": "10172",
  "year": "2024",
  "url": "https://developer.apple.com/videos/play/wwdc2024/10172/",
  "title": "Break into the RealityKit debugger",
  "speakers": [],
  "duration": "",
  "topics": [
    "Developer Tools",
    "Graphics & Games"
  ],
  "hasTranscript": true,
  "hasCode": true,
  "transcript": {
    "fullText": "Hey, I’m Jeremiah! I make developer tools that help you make awesome spatial apps and games. Today, I want to talk about some of the common bugs that might creep into your RealityKit apps. And in the process, I’ll introduce you to the RealityKit debugger - a new tool that helps you catch them. We’ll begin with a quick tour of the RealityKit Debugger, which we will then use to inspect an app and track down some bugs.\n\nWe’ll traverse entity hierarchies, in search of unexpected transformations; address bad behaviors in our systems, by exposing the mistakes in our components; we’ll find missing content, when we overcome some rendering pitfalls; and finally, I’ll share some tips & tricks for adapting the RealityKit Debugger to the uniqueness of your app.\n\nAre you ready? Then let’s begin! With RealityKit you can build jaw-dropping 3D apps, and deploy them to iOS, macOS and visionOS. Like the Botanist sample you might have seen with those cute robots tending to plants. But rushing around all day, carrying those big backpacks... That’s hard work! And sometimes... Even a robot needs a spot to just kick back and chill. A space to meet friends, enjoy premium oils, have a dance, the robot of course, and generally just let off some steam. So, for this session, we’ll be extending the BOTanist sample with a chill out mode. I’ve been working on a prototype that transforms the garden into a club. But I’m not quite ready to open the doors, as there’s still a bunch of bugs running amok. Let’s use the RealityKit debugger to track them down.\n\nThe RealityKit Debugger takes a 3D snapshot of your running app, and loads it in Xcode for you to explore. From the debug area, on the bottom of your screen, click the “Capture Entity Hierarchy” button to begin.\n\nWhen the snapshot completes, captured RealityKit scenes are listed in the debug navigator on the left.\n\nSelecting a scene, displays its entity hierarchy in an adjacent outline view.\n\nIt also reconstructs the content in a 3D viewport.\n\nSelecting an entity in the hierarchy or the viewport, displays its properties, and those of its components, in an inspector on the right.\n\nThere’s also an inspector to show statistics about the currently selected hierarchy. The RealityKit Debugger fits into your existing Xcode workflow, and exposes new insights that make your 3D development experience more productive, and enjoyable. Now, with our new tool in hand, let’s go and fix up this club.\n\nThe code patch for transforming the sample is pretty big.\n\nSo, if you want to follow along, download the ClubView Swift file, drag it into your Xcode project, and include it in your target. We then need to make two small changes.\n\nFirst, we define a new volumetric scene for the club. And add this to the body of the BOTanistApp.\n\nSecond, we need a button to open the club. I added it to the body of the RobotView, next to the existing button to “Start Planting”. We can now build and run our app to the visionOS simulator.\n\nOnce the app launches, it will open on the Robot View. Rather than create a robot, we click the disco ball, to sneak into the club.\n\nWe can use the camera controls to move in closer.\n\nI’ve modified many of the existing assets in the scene, like transforming planters into teleporters. I’ve also generated some new entities from scratch, like the disco ball. That’s currently looking a little wonky. Let’s inspect our scene and find out why.\n\nIn Xcode, launch the RealityKit Debugger, using the button in the debug area.\n\nBefore we dive in, let’s take a moment to consider, how Transformation hierarchies work. When you place content in a 3D scene, you set a position, orientation and scale.\n\nOne of the common bugs you might encounter, is having that content not appear, where you set it.\n\nThis usually happens because, the final placement of an entity is actually a combination of its own transformations and those of all of its ancestors. This often leads to an entity exhibiting a transform that you only wanted applied to a single entity. I suspect, this is what is happening with our Disco Ball. Let’s confirm that using the RealityKit Debugger.\n\nIn the debug navigator, expand the scene wrapper and select the RealityKit content. This will open that scene in the Debugger.\n\nAt this point, we can hide the navigators and debug area to give us some more space to work with.\n\nIn the viewport, double click on the Disco Ball to select and center it.\n\nThe main viewport shows us entities, as they appear in our scene, with the transformations from their ancestors applied. Selecting an entity in the viewport, also selects it in the Entity Hierarchy, and the entity inspector. Our currently selected entity is named Outline. This entity displays the lines on the disco ball. In the Entity Inspector, there is a smaller secondary viewport. This viewport, previews the ModelComponent of the entity without any transformations applied. The Outline entity is undistorted in the preview, so the problem is not caused by its mesh. Also, the Transform component for this entity, visible below the preview window, has uniform scale values of 1. So the entity is not distorting itself. The problem is likely inherited from its ancestors. Lets traverse the hierarchy to find the rogue transformation.\n\nIn the entity hierarchy click on the parent, the Background entity. In the inspector, both the preview viewport and the Transform component, show that this entity is also not producing the distortion. In the hierarchy, let’s click on its parent, the Support entity.\n\nIn the inspector, notice the Support entity has a large scale value along the Y axis of its Transform component. The fact that we’re scaling this entity to achieve a desired shape is not wrong. The mistake here, is that we’re unintentionally, applying this scaling to all of its descendants.\n\nMaking the Support and the “Background” siblings, rather than parent and child, will fix the problem.\n\nThey will still look connected in the scene but the transform of the support will no longer affect the ball. Let’s re-run our app, enter the club, and check out the result.\n\nUsing the RealityKit Debugger to traverse our scene hierarchy, we were able to find the rogue transformation that was squishing our entity. And fix it by changing its parent. Now we can have a ball. The transformed club is starting to look the part. And now it’s time to bring some of these objects to life. RealityKit uses an Entity Component System, ECS approach to object and behavior management. We characterize entities by assigning them various components, that can hold data. We then make systems that perform updates on entities that have specific components. If an entity’s components are misconfigured or missing, then the behavior of the system is unpredictable. Let’s head back to the club, so I can show you an example.\n\nI’ve transformed all the planters in the club into teleporters. The Teleportation System should have started spawning robots but nobody is showing up. Let's break into the debugger to work out why.\n\nLet me first explain how the Teleportation System works.\n\nThe system stores its data in a Control Center Component. Every update, our system decreases a countdown value. When the countdown value reaches 0, it finds all entities in the scene with a TeleporterComponent. And picks a random one. It then spawns a robot at that position. The counter is reset, and the process repeats until the club is at capacity. Let’s switch over to the Debugger, and inspect these components.\n\nMy first suspicion is that I’ve forgotten to add Teleporter Components to the Teleporter Entities. This would cause us to never find a teleporter and so have nowhere to spawn from. With the RealityKit Debugger this is easy to confirm. In the entity hierarchy, expand the Bot Club and the Teleportation Center, and double-click the first Teleporter.\n\nIn the Entity inspector, notice that there is actually a Teleporter Component. Let’s check the other two teleporters to be sure.\n\nThey also have their Teleporter components. So, maybe the problem is the Control Center. In the hierarchy, select the parent entity, the Teleportation Center.\n\nLet’s examine the properties of the control center component, what sticks out to me, is the countdown value. Notice that it matches the initial value. The RealityKit debugger captures the app state at the moment you hit pause, so this value should have changed if our system was working. For some reason, the control center component is not being updated. Let’s inspect the code and work out why.\n\nIn each update, I decrease the countdown value in the control center component. I then... Ah, I was going to say I saved the updated component back to the entity, but looks like I forgot that step. Let’s add the missing step and re-run the app. This is a common mistake. Modified components need to be assigned back to their entity. Let’s switch over to the simulator and find out if that solved it.\n\nWith the RealityKit debugger, we tracked down and fixed a badly behaving system. We can now return to the club, and wait for a visitor.\n\nI really hope we get some customers soon. The rent on this place? Astronomical! Hey! Our first guest just phased in.\n\nWe now have robots teleporting in, but there’a a problem! There are supposed to be bottles of oil on the counter, but they aren’t in sight. I thought I restocked them. If we don’t find them soon, these bots will stop dancing, and this place is going to grind to a halt. I suspect they’ve been hidden by the renderer. Let me explain! 3D renderers like RealityKit achieve their performance in part, by being selective of what they spend time rendering. For example, something might be far away or maybe it’s too close, occluded by other content, or have its opacity set too low. It might be looking for an ARKit anchor, or even missing its assets entirely. In all these cases, and many others, our content will not be rendered. And working out why, is often a process of elimination.\n\nUsing Reality Compose Pro to prepare, test and package our assets, can help to avoid these issues. But if you still end up losing content, then the RealityKit debugger can help you find it. Let’s switch over to it now, and try to solve the case of the missing bottles.\n\nDouble-click the counter in the viewport, and adjust your camera to get a nice close up.\n\nYeah, that looks good. On the counter, there should be nine green bottles of the finest oil. But there’s currently only one, and even that is not rendering correctly. Lets work out why. In the entity hierarchy, expand the Counter and BottleGroup, and select the first bottle.\n\nAn entity’s selection highlight is visible even when the entity itself is occluded by other entities, In this case, it reveals that this bottle is there, but it is under the counter. This is confirmed by the inspector, where the bottle’s Transform component, has a negative value in the Y direction. This is an easy fix that we’ll make later. For now, let’s move on and investigate the next problem.\n\nPick bottle 2 in the hierarchy.\n\nNotice that there is no selection highlight in view. If we double-click the entity in the hierarchy, it will focus the camera on it.\n\nOh, it’s really far out. So far in fact, that it exceeds our scene’s bounds, as indicated by the yellow box. Because of this, it will be clipped by the renderer, and never shown. Like the first bottle, the solution here, will be to correct the translation.\n\nLet’s continue. In the hierarchy, double-click the third bottle to select and focus it.\n\nWow! The bottle is so big, that we were actually inside it. The triangles that make up a mesh, are usually only visible on one side. So from inside the mesh, it is often not visible at all. Reducing the scale of this object will fix our problem. We’re quite far from the counter now, so in the hierarchy, let’s double-click on bottle number 4, to fly back in.\n\nNotice, that in the hierarchy, alongside bottle 4, there is an icon. This lets us know that the entity is not active. Entities that are not active will not be rendered. Inspecting its components can help us discover what's wrong.\n\nUnlike the previous bottles, this one has an OutOfStock component. I use this component to tag out of stock items, and hide them. So, this not being rendered is actually the intended behavior.\n\nLet’s continue on to bottle 5.\n\nThe inspector for this bottle, reveals another unexpected component. An Anchoring component. This is actually some legacy code from an early prototype where I wanted to add dinner service at the club. Looks like I forgot to remove the component, when I removed the feature. The presence of an Anchoring component without a matching ARKit anchor in the scene, stops the entity from being rendered.\n\nLet’s move on to bottle 6.\n\nIn the viewport, there is no selection outline, just an axis. This means there is no model component on the entity, which we can also confirm in the inspector. Maybe it failed to load, or maybe we attached it to the wrong entity. We can’t tell which from here, so we’d need to check our code later. But we know what the problems is and where to focus.\n\nMoving on to Bottle 7.\n\nThis is not visible in the main viewport, nor the preview viewport - this means, it is likely a ModelComponent issue. The selection shape in the main viewport looks accurate. This leads me to suspect that the mesh is ok, and the issue is with the material. Let’s expand and inspect the properties of the material in the ModelComponent This material is setup to be semi-transparent, but also has an opacity threshold of 1.\n\nMy misconfiguration is effectively telling the engine that any parts of the model with an opacity less than 1 should not be rendered, but to also set all parts of the model to have an opacity less than one. The result is that the whole bottle is invisible.\n\nThe next bottle, number 8, is actually visible. Well, part of it.\n\nIn the inspector, I don’t notice anything obviously wrong. For situations like this, the RealityKit debugger gives us some additional displays that help us spot problems we might otherwise miss.\n\nIn the preview viewport, use the far right dropdown to change the rendering mode. Lets select the first option to visualize Normals.\n\nThis colors the object using the normal value at each point. The normal value indicates the direction a surface faces, and is used in lighting and rendering calculations. This might seem intimidating at first, but if we switch between this and a known good bottle like Bottle 1, we can observe that something is, a mess in our mesh.\n\nErrors like this are usually found in imported assets and need to be fixed in a 3D content creation tool.\n\nOk, one more to go. Select bottle 9. Oh, there is no bottle 9. I probably forgot to add it to the scene. I can confirm this by using the filter bar at the bottom of the hierarchy view, and showing only entities whose name contains BT.\n\nAs expected, it’s not in the scene.\n\nWe sped through a lot of issues here, so I’ll quickly recap. The first few bottles we couldn’t see because their transforms caused them to be occluded, clipped or inside out. One bottle was hidden because we disabled it, while another bottle was hidden because it was missing its anchor. We had a bottle with a broken mesh, one missing its mesh, and one was being made invisible by a misconfigured material. And one we just forgot to add to the scene. My bottle creation code included a lot of errors due to copy and pasting.\n\nSo I’m going to replace it with a single creation loop. Positioning and setting up 3D assets directly in code is challenging, so I would recommend preparing scene layout in Reality Composer Pro whenever possible.\n\nLet’s re-run the app and enter the club.\n\nUsing the various tools in the debugger, we were able to find our missing bottles. Our counter is now fully stocked with oil. And we can move smoothly on.\n\nFrom rogue transformations, through to misconfigured components, and rendering gotchas, we’ve already covered many of the common problems you might encounter when building your own apps. But many parts of an app are unique. And as they grow in complexity, so too do the challenges in debugging them. However, you can leverage the flexibility of ECS, to customize the RealityKit Debugger experience. Let me show you how. This is our Dance System. It works through a collection of invisible attractor entities, that are positioned around the dance floor. When a Newcomer teleports into the club, it is targeted by a vacant attractor. And each update it is driven closer in. Once our friend reaches an attractor, the motivator kicks in and they begin to dance.\n\nBut you may have noticed that something is up. A Robot teleports in, but they just stand there, not moving towards our attractors. Let's build some RealityKit debug-ability into this system.\n\nFirst, we’ll add basic model entities to the scene to visualize the invisible attractors. We’ll give each a custom component to store the values we want to present in the inspector, such as the attractor state. And we’ll group these under a single invisible entity, so none of this shows up during play. We’ll also give this parent entity a custom component, to display information about the system as a whole.\n\nThis is a simplified version of the code, with the full version already included in the ClubView swift file. It seems like a lot, but it’s just using standard RealityKit. Entities, components and systems. The only odd thing you might notice is that I’ve placed all this inside a debug compilation block. This ensures that the code will be complied out of the released app, and means I don’t need to worry about the performance implications. With our new debug system in place, let’s now run the app, wait for a robot to appear, and break into the debugger.\n\nIn the hierarchy, find and select the \" Dance System entity\".\n\nNotice that the properties of our debug component appear in the inspector. The RealityKit debugger can display most of the types you’ll regularly use in your apps. You can utilize this in straightforward ways such as displaying counters or more creative ways such as display a swift chart by saving it as a UIImage property. This new debug component helps us spot the problem in our dance system. All of our attractors are in the attracting state, which shouldn’t be possible. Another way we can observe this, is with our visualizations. In the entity hierarchy, secondary-click the \" Dance System entity\" to open the context menu and toggle visibility.\n\nOur visualization shows us the state of each attractor. And indeed, they are all orange, which is the color we used to indicate the attracting state. A robot is only meant to be targeted by a single attractor. When a robot teleports in, we tag it with a Newcomer component, and remove that tag when it is targeted by an attractor. Let’s select one of our debug visualizations to inspect its debug component.\n\nWe set up this component to store a reference to the target robot, which the RealityKit debugger converts into a link. Let’s click on it to find our target.\n\nInspecting the Robot’s components reveals the problem. It still has its newcomer component, which should have been removed when it was first targeted. Since it wasn’t, every attractor finds this same robot, and attempts to attract it, and the robot, overwhelmed by choice, is frozen. With the problem identified, we can now head to the code to fix it.\n\nIn the dance system when the target is set, I should be removing the Newcomer component, but I’m not. Let’s add the code to do that. Then re-run our app.\n\nThis type of bug is easy to fix, but can be tricky to track down, especially as we increase the complexity of our systems and the scale of the app. But by leveraging those same systems to build visualizations, and using custom components to add inspectors, we can ensure that our developer experience is just as enjoyable as the experiences we build for our players, and our robots. With that, let’s finally open up our club and enjoy our success.\n\nWith the help of the RealityKit debugger, we were able to track down and fix issues in our entity hierarchies and components. And Leveraging the flexibility of ECS, we added visualizations and custom inspectors. So that we could better debug the unique parts of our app.\n\nWe’ve covered a lot in this session! So now, like our robot friends, I’m off to go and chill.",
    "segments": []
  },
  "codeExamples": [
    {
      "timestamp": "2:45",
      "title": "ClubView",
      "language": "swift",
      "code": "/*\nAbstract:\nThe full club patch. SwiftUI view, state, extensions and helpers.\n*/\n\nimport SwiftUI\nimport RealityKit\nimport OSLog\nimport BOTanistAssets\nimport Combine\nimport Charts\n\nstruct ClubView: View {\n    @State var state = ClubViewState()\n    \n    var body: some View {\n        ZStack {\n            RealityView { content in\n                state.loadEnvironment()\n                \n                state.rootEntity.scale = SIMD3<Float>(repeating: 0.5)\n                \n                content.add(state.rootEntity)\n            } update: { updateContent in\n                if !state.doorSupervisor.doorsOpen {\n                    state.transformIntoClub(content: updateContent)\n                }\n            }\n        }\n    }\n}\n\n@Observable\n@MainActor\nfinal public class ClubViewState: Sendable {\n    let rootEntity = Entity()\n    \n    private var loadedEnvironmentRoot: Entity?\n    private var robotRevolutionController: Entity?\n    private var host: Entity?\n    \n    private(set) var doorSupervisor: DoorSupervisor {\n        get {\n            rootEntity.components[DoorSupervisor.self]!\n        } set {\n            rootEntity.components[DoorSupervisor.self] = newValue\n        }\n    }\n    \n    init() {\n        RevolvingSystem.registerSystem()\n        HoverSystem.registerSystem()\n        TeleportationSystem.registerSystem()\n        DanceMotivationSystem.registerSystem()\n        \n        rootEntity.name = \"The B0T Club\"\n        rootEntity.components[DoorSupervisor.self] = DoorSupervisor(capacity: 9)\n    }\n    \n    /// Load the existing garden assets\n    func loadEnvironment() {\n        guard loadedEnvironmentRoot == nil else {\n            return\n        }\n        \n        if let environment = try? Entity.load(named: \"scenes/volume\", in: BOTanistAssetsBundle) {\n            environment.name = \"Environment\"\n            self.loadedEnvironmentRoot = environment\n            \n            rootEntity.addChild(environment)\n        }\n    }\n    \n    /// Renovate the loaded environment to build our club\n    func transformIntoClub(content: RealityViewContent) {\n        guard !doorSupervisor.doorsOpen else {\n            return\n        }\n        \n        // Build a teleportation center and use it to spawn robots\n        addTeleportationCenterToTheClub()\n        \n        // Haphazardly clean up the space by hiding anything un-club-like\n        hideStuffInTheEnvironment()\n        \n        // Polish that floor and add some spin\n        addRevolvingDanceFloorToTheClub()\n        \n        // Keep the robots moving in an orderly fashion\n        addRobotRevolutionControllerToTheClub()\n        \n        // Install some attractors to entice robots to the dance floor\n        addDanceFloorAttractors()\n        \n        // Set the mood\n        addSpotlightsToTheClub()\n        \n        // Stock up on oil to keep the moves smooth\n        addCounterToTheClub()\n        \n        // And add a huge Disco Ball, because...\n        addDiscoBallToTheClub()\n        \n        // Let the party begin\n        openDoors()\n    }\n    \n    /// Construct a Teleportation Center and add it to the Club's root entity\n    private func addTeleportationCenterToTheClub() {\n        let teleportationCenter = Entity()\n        teleportationCenter.name = \"Teleportation Center\"\n        rootEntity.addChild(teleportationCenter)\n        \n        // Liven up the planters to look more like teleporters\n        let positions: [SIMD3<Float>] = [[0.128, 0, 0.14], [-0.255, 0, 0.23], [0.05, 0, -0.17]]\n        let colors: [(UIColor, UIColor)] = [(.green, .yellow), (.magenta, .purple), (.cyan, .blue)]\n        for index in 0...2 {\n            if let teleporter = rejigPlanter(identifier: String(index + 1), position: positions[index], colors: colors[index]) {\n                teleportationCenter.addChild(teleporter)\n            }\n        }\n        \n        // Create a Control Center and provide a closure to handle robot spawning\n        let teleportationControlCenter = ControlCenterComponent(\n            initialValue: 10,\n            interval: 5,\n            rootEntity: rootEntity) { teleporter in\n                self.spawnRobot(from: teleporter)\n                self.countVisitor()\n                \n                // Have the host say hello\n                if let hostCharacter = self.host?.components[AutomatonControl.self]?.character {\n                    hostCharacter.transitionToAndPlayAnimation(.idle)\n                    hostCharacter.transitionToAndPlayAnimation(.wave)\n                }\n        }\n        \n        // Assign the new control center component to the teleportation center entity\n        teleportationCenter.components[ControlCenterComponent.self] = teleportationControlCenter\n    }\n    \n    /// Transforms the visuals of the planters to look more teleporter-y\n    private func rejigPlanter(identifier: String, position: SIMD3<Float>, colors: (UIColor, UIColor)) -> Entity? {\n        if let rim = rootEntity.findEntity(named: \"heroPlanter_rim_\\(identifier)\"),\n           let dirt = rootEntity.findEntity(named: \"dirt_hero_\\(identifier)\"),\n           let rimModelComponent = rim.components[ModelComponent.self],\n           var dirtModelComponent = dirt.components[ModelComponent.self] {\n            // Apply the luminous material from the rims to the dirt (trust me it will look cool).\n            dirtModelComponent.materials = rimModelComponent.materials\n            dirt.components[OpacityComponent.self] = OpacityComponent(opacity: 0.7)\n            dirt.components[ModelComponent.self] = dirtModelComponent\n        }\n        \n        // Make a teleporter container entity\n        let teleporter = Entity()\n        teleporter.name = \"Teleporter-T\\(identifier)\"\n        teleporter.position = position\n        teleporter.components[TeleporterComponent.self] = TeleporterComponent()\n        \n        // Add a particle emitter\n        let radius: Float = 0.035\n        var particleEmitter = ParticleEmitterComponent.Presets.teleporter\n        particleEmitter.emitterShapeSize = .init(repeating: radius)\n        particleEmitter.mainEmitter.color = .constant(.random(a: colors.0, b: colors.1))\n        \n        let particleEntity = Entity()\n        particleEntity.orientation = .init(angle: -.pi / 2, axis: [1, 0, 0])\n        particleEntity.components[ParticleEmitterComponent.self] = particleEmitter\n        particleEntity.name = \"Photons\"\n        particleEntity.scale = .init(repeating: 1)\n        teleporter.addChild(particleEntity)\n        \n#if DEBUG\n        // Add a debug marker in case we want to visually inspect this in the RealityKit Debugger\n        teleporter.addDebugMarker(radius: radius, color: colors.0)\n#endif\n        \n        return teleporter\n    }\n    \n    /// adds a random robot to the club root, positioned at the provided point\n    private func spawnRobot(from spawnPoint: Entity) {\n        guard let robotCharacter = randomRobot() else {\n            logger.error(\"Robot creation malfunction 🤖💥\")\n            return\n        }\n        \n        let guest = Entity()\n        \n        guest.addChild(robotCharacter.characterParent)\n        guest.position = spawnPoint.position(relativeTo: rootEntity)\n        guest.components[Newcomer.self] = Newcomer()\n        guest.components[AutomatonControl.self] = AutomatonControl(character: robotCharacter)\n        \n        rootEntity.addChild(guest)\n        \n        // Play a little flashy burst on the particle emitter\n        if let particles = spawnPoint.findEntity(named: \"Photons\") {\n            var component = particles.components[ParticleEmitterComponent.self]\n            component?.burst()\n            particles.components[ParticleEmitterComponent.self] = component\n        }\n    }\n    \n    /// misuses AppState as a robot factory - don't try this at home, or do, but don't ship it!\n    private func randomRobot() -> RobotCharacter? {\n        let robotMaker = AppState()\n        \n        // Use offsets from the loaded animation rig, with some random parts\n        guard let skeleton = robotMaker.robotData.meshes[.body]?.findEntity(named: \"rig_grp\") as? ModelEntity else {\n            logger.error(\"Failed to find a robot animation rig... all dancing in cancelled ❌🕺\")\n            return nil\n        }\n        \n        robotMaker.randomizeSelectedRobot()\n        \n        guard let head = robotMaker.robotData.meshes[.head]?.clone(recursive: true),\n              let body = robotMaker.robotData.meshes[.body]?.clone(recursive: true),\n              let backpack = robotMaker.robotData.meshes[.backpack]?.clone(recursive: true) else {\n            fatalError()\n        }\n        \n        let robotCharacter = RobotCharacter(\n            head: head,\n            body: body,\n            backpack: backpack,\n            appState: robotMaker,\n            headOffset: skeleton.pins[\"head\"]?.position,\n            backpackOffset: skeleton.pins[\"backpack\"]?.position\n        )\n        \n        // Pick a random robot name from the sequence\n        robotCharacter.characterParent.name = RobotNames.next\n        \n        // Remove the character controller and animation state, as we'll manually control these\n        robotCharacter.characterParent.components[CharacterControllerComponent.self] = nil\n        AnimationState.handlers.removeAll()\n        \n        // The robots are here to chill, so actually, let's put their backpacks in the cloakroom\n        backpack.removeFromParent()\n        \n        // Say Hi\n        robotCharacter.transitionToAndPlayAnimation(.wave)\n        \n        return robotCharacter\n    }\n    \n    /// Update capacity when we have a visitor\n    private func countVisitor() {\n        var management = self.doorSupervisor\n        management.visitorCount += 1\n        self.doorSupervisor = management\n    }\n    \n    /// Find and hide a bunch of stuff in the loaded environment\n    private func hideStuffInTheEnvironment() {\n        // We used the RealityKit Debugger to identify the names of things we want to hide in the club\n        [\"setDressing\", \"MovementBoundaries\", \"planter_side\", \"planter_Hero\", \"planter_Hero_1\", \"planter_Hero_2\", \"PlantLightGroup\",\n         \"PlantLightGroup_1\", \"PlantLightGroup_2\", \"SidePlanterLights\", \"pipe_2\", \"pipe_3\", \"dirt_coffeeBerry_1\", \"dirt_coffeeBerry_2\",\n         \"dirt_coffeeBerry_3\", \"dirt_side\"].forEach { name in\n            if let entity = rootEntity.findEntity(named: name) {\n                entity.removeFromParent()\n            }\n        }\n    }\n    \n    /// Repurpose some existing bits in the environment to create a makeshift revolving dance floor - if it looks like dirt, that's because it is\n    private func addRevolvingDanceFloorToTheClub() {\n        guard let dirtFloor = loadedEnvironmentRoot?.findEntity(named: \"dirt_end\") else {\n            return\n        }\n        \n        // Add a revolving container entity\n        let revolvingDanceFloor = Entity()\n        revolvingDanceFloor.name = \"Revolving Dance Floor\"\n        revolvingDanceFloor.scale = [1, 1, 1]\n        revolvingDanceFloor.position = [0, 0.181, 0]\n        revolvingDanceFloor.components[RevolvingComponent.self] = RevolvingComponent(relativeTo: rootEntity)\n        \n        // Polish up the dirt floor\n        let geometry = dirtFloor.clone(recursive: false)\n        geometry.name = \"Dirt Floor\"\n        geometry.transform = .identity\n        geometry.position = [0, 0, 0]\n        geometry.scale = dirtFloor.scale(relativeTo: rootEntity)\n        \n        let polish = geometry.clone(recursive: false)\n        polish.name = \"Polish Layer\"\n        polish.position = [0, 0.0004, 0]\n        \n        if var modelComponent = geometry.components[ModelComponent.self] {\n            var polishedFloorMaterial = PhysicallyBasedMaterial()\n            \n            polishedFloorMaterial.baseColor = .init(tint: .gray)\n            polishedFloorMaterial.roughness = .init(floatLiteral: 0.2)\n            polishedFloorMaterial.metallic = .init(floatLiteral: 0.8)\n            polishedFloorMaterial.blending = .transparent(opacity: .init(floatLiteral: 0.5))\n            polishedFloorMaterial.clearcoat = .init(floatLiteral: 0.4)\n            \n            modelComponent.materials = [polishedFloorMaterial]\n            \n            polish.components[ModelComponent.self] = modelComponent\n        }\n        \n        // Add it to the revolving container\n        revolvingDanceFloor.addChild(geometry)\n        revolvingDanceFloor.addChild(polish)\n        \n        rootEntity.addChild(revolvingDanceFloor)\n    }\n    \n    /// Creates a revolving container entity to keep robots moving in sync with the dance floor\n    private func addRobotRevolutionControllerToTheClub() {\n        let robotRevolutionController = Entity()\n        robotRevolutionController.name = \"Robot Revolution Controller\"\n        robotRevolutionController.components[RevolvingComponent.self] = RevolvingComponent(relativeTo: rootEntity)\n        \n        rootEntity.addChild(robotRevolutionController)\n        \n        self.robotRevolutionController = robotRevolutionController\n    }\n    \n    /// Add invisible attractors to the dance floor to position and control robots\n    private func addDanceFloorAttractors() {\n        guard let robotRevolutionController else {\n            logger.error(\"The Robot Revolution Controller is missing 😱\")\n            return\n        }\n        \n        // Add a few dance spots on the outside of the club that we know don't obstruct the furniture\n        let staticAttractors = Entity()\n        staticAttractors.name = \"Static Attractors\"\n        \n        let placementRadius: Float = 0.25\n        let outerRadius = placementRadius * 0.8\n        addDanceFloorAttractor(to: staticAttractors, angle: Angle2D(degrees: 10), placementRadius: outerRadius, name: \"Static-A1\", variation: 0)\n        addDanceFloorAttractor(to: staticAttractors, angle: Angle2D(degrees: 90), placementRadius: outerRadius, name: \"Static-A2\", variation: 0)\n        addDanceFloorAttractor(to: staticAttractors, angle: Angle2D(degrees: 130), placementRadius: outerRadius, name: \"Static-A3\", variation: 0)\n        addDanceFloorAttractor(to: staticAttractors, angle: Angle2D(degrees: 240), placementRadius: outerRadius, name: \"Static-A4\", variation: 0)\n        addDanceFloorAttractor(to: staticAttractors, angle: Angle2D(degrees: 325), placementRadius: outerRadius, name: \"Static-A5\", variation: 0)\n        \n        rootEntity.addChild(staticAttractors)\n        \n        // The remaining center attractors are on the revolving dance floor and can be more randomly positioned\n        let innerRingCapacity = doorSupervisor.capacity - 5\n        \n        let revolvingAttractors = Entity()\n        revolvingAttractors.name = \"Revolving Attractors\"\n        \n        addDanceFloorAttractors(to: revolvingAttractors, count: innerRingCapacity, placementRadius: placementRadius * 0.3, namePrefix: \"Revolving\")\n        \n        robotRevolutionController.addChild(revolvingAttractors)\n        \n#if DEBUG\n        // Add some debug visualizations\n        let debugRoot = Entity()\n        debugRoot.name = \"[Debug] Dance System\"\n        debugRoot.isEnabled = false\n        debugRoot.components[DanceSystemDebugComponent.self] = DanceSystemDebugComponent()\n        \n        rootEntity.addChild(debugRoot)\n        \n        let allAttractors = Array(staticAttractors.children) + Array(revolvingAttractors.children)\n        \n        // Create a new visualization for each attractor\n        allAttractors.forEach { attractor in\n            if let visualization = Entity.makeDebugMarker(height: 0.08, radius: 0.03, enabled: true) {\n                guard let attractorComponent = attractor.components[AttractorComponent.self] else {\n                    return\n                }\n                \n                let debugComponent = AttractorDebugComponent(state: attractorComponent.state, attractor: attractor)\n                \n                visualization.position = [0, 0.04, 0]\n                visualization.components[AttractorDebugComponent.self] = debugComponent\n                debugRoot.addChild(visualization)\n            }\n        }\n#endif\n    }\n    \n    /// Add multiple dance floor attractors along the circumference of a circle with the specified placementRadius\n    private func addDanceFloorAttractors(to danceFloor: Entity, count: Int, placementRadius: Float, namePrefix: String, variation: Float = 0.005) {\n        let angleIncrements = 360 / count\n        \n        for offset in 0..<count {\n            let angle = Angle2D(degrees: Double(angleIncrements * offset))\n            let name = \"\\(namePrefix)-A\\(offset + 1)\"\n            addDanceFloorAttractor(to: danceFloor, angle: angle, placementRadius: placementRadius, name: name, variation: variation)\n        }\n    }\n    \n    /// Adds a single dance floor attractor at a point on the circumference of a circle with the specified placementRadius\n    private func addDanceFloorAttractor(to danceFloor: Entity, angle: Angle2D, placementRadius: Float, name: String, variation: Float = 0.005) {\n        let attractor = Entity()\n        attractor.name = name\n        attractor.components[AttractorComponent.self] = AttractorComponent(club: rootEntity)\n        attractor.position = pointOnCircumference(angle: angle, radius: placementRadius, variation: variation)\n        danceFloor.addChild(attractor)\n    }\n    \n    /// Adds some revolving spot lights to the club\n    private func addSpotlightsToTheClub() {\n        let placementRadius: Float = 0.5\n        let lightsWrapper = Entity()\n        lightsWrapper.name = \"Light Rig\"\n        \n        let magentaLight = SpotLight()\n        magentaLight.light.color = .magenta\n        magentaLight.light.intensity = 500\n        var lightPosition = pointOnCircumference(angle: Angle2D(degrees: 0), radius: placementRadius, y: 0.5)\n        magentaLight.look(at: .zero, from: lightPosition, relativeTo: rootEntity)\n        lightsWrapper.addChild(magentaLight)\n        \n        let greenLight = magentaLight.clone(recursive: true)\n        greenLight.light.color = .green\n        lightPosition = pointOnCircumference(angle: Angle2D(degrees: 120), radius: placementRadius, y: 0.5)\n        greenLight.look(at: .zero, from: lightPosition, relativeTo: rootEntity)\n        lightsWrapper.addChild(greenLight)\n        \n        let cyanLight = magentaLight.clone(recursive: true)\n        cyanLight.light.color = .cyan\n        lightPosition = pointOnCircumference(angle: Angle2D(degrees: 240), radius: placementRadius, y: 0.5)\n        cyanLight.look(at: .zero, from: lightPosition, relativeTo: rootEntity)\n        lightsWrapper.addChild(cyanLight)\n        \n        lightsWrapper.components[RevolvingComponent.self] = RevolvingComponent(speed: -0.2, relativeTo: rootEntity)\n        \n        rootEntity.addChild(lightsWrapper)\n    }\n    \n    /// Repurpose some planters to make a counter and stocks with a premium aged oil, and a friendly host\n    private func addCounterToTheClub() {\n        guard let planter = rootEntity.findEntity(named: \"planter_big\"),\n              let dirt = rootEntity.findEntity(named: \"dirt_big\") else {\n            logger.error(\"Making the counter failed... too much dancing may now cause rust 🤖\")\n            return\n        }\n        \n        // Group into a container entity\n        let counter = Entity()\n        counter.name = \"Counter\"\n        counter.position = [0.333, 0.05, -0.09]\n        rootEntity.addChild(counter)\n        \n        // Repurpose existing assets\n        let counterGeometry = Entity()\n        counterGeometry.name = \"Counter Geometry\"\n        counterGeometry.addChild(planter, preservingWorldTransform: true)\n        counterGeometry.addChild(dirt, preservingWorldTransform: true)\n        counterGeometry.scale = [2, 6, 2]\n        counterGeometry.position = [-0.3335, -0.15, 0.09]\n        counter.addChild(counterGeometry)\n        \n        var counterTopMaterial = PhysicallyBasedMaterial()\n        counterTopMaterial.baseColor = .init(tint: .white)\n        counterTopMaterial.roughness = .init(floatLiteral: 0)\n        counterTopMaterial.metallic = .init(floatLiteral: 1)\n        \n        dirt.components[ModelComponent.self]?.materials = [counterTopMaterial]\n        dirt.position += [0, 0.001, 0]\n        \n        // Add a fancy hover rail\n        if let rim = rootEntity.findEntity(named: \"bottom_rim_1\") {\n            let hoverRailing = rim.clone(recursive: true)\n            hoverRailing.name = \"Hover Railing\"\n            hoverRailing.position = [0, 0.1, 0]\n            hoverRailing.scale = rim.scale(relativeTo: rootEntity) * 0.5\n            hoverRailing.components[HoverComponent.self] = HoverComponent(from: hoverRailing.position, to: hoverRailing.position + [0, -0.03, 0])\n            counter.addChild(hoverRailing)\n        }\n        \n        // Add some bottles to the counter\n        let bottles = stockBottles(placementRadius: 0.045)\n        counter.addChild(bottles)\n        \n        // Hide any out of stock items\n        for bottle in bottles.children {\n            bottle.isEnabled = bottle.components[OutOfStockComponent.self] == nil\n        }\n        \n        // Add a friendly host\n        addHostToTheCounter(counter)\n    }\n    \n    /// Adds 9 green bottles of the finest aged oil to the counter (assuming we have them in stock)\n    private func stockBottles(placementRadius: Float) -> Entity {\n        let bottleRadius: Float = 0.003\n        let bottleHeight: Float = 0.022\n        let angleIncrement: Float = -12\n        let outOfStockBrands: Set = [3]\n        \n        // Make a wrapper entity\n        let bottleGroup = Entity()\n        bottleGroup.name = \"Bottle Group\"\n        bottleGroup.position = [0, 0.04, 0]\n        bottleGroup.orientation = .init(angle: 180 * (.pi / 180), axis: [0, 1, 0])\n        \n        // Make a nice green material\n        var bottleMaterial = PhysicallyBasedMaterial()\n        bottleMaterial.baseColor = .init(tint: .green)\n        bottleMaterial.blending = .transparent(opacity: .init(floatLiteral: 0.5))\n        \n        // A simple cylinder mesh\n        let bottleMesh = MeshResource.generateCylinder(height: bottleHeight, radius: bottleRadius)\n        \n        // Error 1: Content occluded\n        let bottle1 = Entity()\n        bottle1.name = \"BT1\"\n        bottle1.position = pointOnCircumference(angle: .zero, radius: placementRadius, y: -0.03)\n        bottle1.components[ModelComponent.self] = ModelComponent(mesh: bottleMesh, materials: [bottleMaterial])\n        bottleGroup.addChild(bottle1)\n        \n        // Error 2: Content clipped\n        let bottle2 = Entity()\n        bottle2.name = \"BT2\"\n        bottle2.position = pointOnCircumference(angle: Angle2D(degrees: angleIncrement), radius: 1.6, y: bottleHeight / 2)\n        bottle2.components[ModelComponent.self] = ModelComponent(mesh: bottleMesh, materials: [bottleMaterial])\n        bottleGroup.addChild(bottle2)\n        \n        // Error 3: Content inside out\n        let bottle3 = Entity()\n        bottle3.name = \"BT3\"\n        bottle3.position = pointOnCircumference(angle: Angle2D(degrees: 2 * angleIncrement), radius: placementRadius, y: bottleHeight / 2)\n        bottle3.scale = .init(repeating: 650)\n        bottle3.components[ModelComponent.self] = ModelComponent(mesh: bottleMesh, materials: [bottleMaterial])\n        bottleGroup.addChild(bottle3)\n        \n        // Error 4: Content not enabled\n        let bottle4 = Entity()\n        bottle4.name = \"BT4\"\n        bottle4.position = pointOnCircumference(angle: Angle2D(degrees: 3 * angleIncrement), radius: placementRadius, y: bottleHeight / 2)\n        bottle4.components[ModelComponent.self] = ModelComponent(mesh: bottleMesh, materials: [bottleMaterial])\n        bottle4.components[OutOfStockComponent.self] = OutOfStockComponent()\n        bottleGroup.addChild(bottle4)\n        \n        // Error 5: Content not anchored\n        let bottle5 = Entity()\n        bottle5.name = \"BT5\"\n        bottle5.position = pointOnCircumference(angle: Angle2D(degrees: 4 * angleIncrement), radius: placementRadius, y: bottleHeight / 2)\n        bottle5.components[AnchoringComponent.self] = AnchoringComponent(.plane(.horizontal, classification: .table, minimumBounds: .zero))\n        bottle5.components[ModelComponent.self] = ModelComponent(mesh: bottleMesh, materials: [bottleMaterial])\n        bottleGroup.addChild(bottle5)\n        \n        // Error 6: Content missing a mesh\n        let bottle6 = Entity()\n        bottle6.name = \"BT6\"\n        bottle6.position = pointOnCircumference(angle: Angle2D(degrees: 5 * angleIncrement), radius: placementRadius, y: bottleHeight / 2)\n        bottle5.components[ModelComponent.self] = ModelComponent(mesh: bottleMesh, materials: [bottleMaterial])\n        bottleGroup.addChild(bottle6)\n        \n        // Error 7: Content's material misconfigured\n        let bottle7 = Entity()\n        bottle7.name = \"BT7\"\n        bottle7.position = pointOnCircumference(angle: Angle2D(degrees: 6 * angleIncrement), radius: placementRadius, y: bottleHeight / 2)\n        \n        var simplifiedBottleMaterial = UnlitMaterial(color: .green.withAlphaComponent(0.5))\n        simplifiedBottleMaterial.opacityThreshold = 1\n        \n        bottle7.components[ModelComponent.self] = ModelComponent(mesh: bottleMesh, materials: [simplifiedBottleMaterial])\n        bottleGroup.addChild(bottle7)\n        \n        // Error 8: Content has a broken mesh\n        let alternativeMesh = MeshResource.generateAbnormalCylinder(height: bottleHeight, radius: bottleRadius)\n        let bottle8 = Entity()\n        bottle8.name = \"BT8\"\n        bottle8.position = pointOnCircumference(angle: Angle2D(degrees: 7 * angleIncrement), radius: placementRadius, y: bottleHeight / 2)\n        bottle8.scale = [bottle8.scale.x, bottle8.scale.y, -bottle8.scale.z]\n        bottleMaterial.opacityThreshold = 0\n        bottle8.components[ModelComponent.self] = ModelComponent(mesh: alternativeMesh, materials: [bottleMaterial])\n        bottleGroup.addChild(bottle8)\n        \n        // Error 9: Content not added to the scene hierarchy\n        let bottle9 = Entity()\n        bottle9.name = \"BT9\"\n        bottle9.position = pointOnCircumference(angle: Angle2D(degrees: 8 * angleIncrement), radius: placementRadius, y: bottleHeight / 2)\n        bottle9.components[ModelComponent.self] = ModelComponent(mesh: bottleMesh, materials: [bottleMaterial])\n        bottleGroup.addChild(bottle8)\n        \n        // FIXME: Bottles are missing from the counter\n        \n        return bottleGroup\n    }\n    \n    /// Add a host robot to the counter\n    private func addHostToTheCounter(_ counter: Entity) {\n        // Make a clone of our hero BOTanist\n        let robotMaker = AppState()\n        \n        guard let skeleton = robotMaker.robotData.meshes[.body]?.findEntity(named: \"rig_grp\") as? ModelEntity else {\n            fatalError()\n        }\n        \n        // But use the hover body to best complement the counter\n        robotMaker.setMesh(part: .body, name: \"body3\")\n        \n        guard let head = robotMaker.robotData.meshes[.head]?.clone(recursive: true),\n              let body = robotMaker.robotData.meshes[.body]?.clone(recursive: true),\n              let backpack = robotMaker.robotData.meshes[.backpack]?.clone(recursive: true) else {\n            fatalError()\n        }\n        \n        let robotCharacter = RobotCharacter(\n            head: head,\n            body: body,\n            backpack: backpack,\n            appState: robotMaker,\n            headOffset: skeleton.pins[\"head\"]?.position,\n            backpackOffset: skeleton.pins[\"backpack\"]?.position\n        )\n        \n        // Remove the character controller and animation state, as we'll manually control these\n        AnimationState.handlers.removeAll()\n        robotCharacter.characterParent.components[CharacterControllerComponent.self] = nil\n        \n        // Take off that heavy backpack\n        backpack.removeFromParent()\n        \n        // Setup our host using the character and add it to the counter\n        let host = Entity()\n        host.name = \"Host\"\n        host.orientation = .init(angle: 300 * (.pi / 180), axis: [0, 1, 0])\n        host.position = [0, 0.005, 0]\n        host.components[AutomatonControl.self] = AutomatonControl(character: robotCharacter)\n        host.addChild(robotCharacter.characterParent)\n        counter.addChild(host)\n        \n        // Have them say Hi\n        robotCharacter.transitionToAndPlayAnimation(.wave)\n        \n        // Save a reference so they can wave later when other bots enter\n        self.host = host\n    }\n    \n    /// Generates a disco ball looking entity, makes it revolve and hover, and adds it to the club\n    private func addDiscoBallToTheClub() {\n        // Add the top level revolving, hovering disco ball entity\n        let discoBall = Entity()\n        discoBall.name = \"Disco Ball\"\n        discoBall.position = [-0.305, 0.17, 0.02]\n        discoBall.components[RevolvingComponent.self] = RevolvingComponent(speed: -0.02, relativeTo: rootEntity)\n        discoBall.components[HoverComponent.self] = HoverComponent(from: discoBall.position, to: discoBall.position + [0, 0.02, 0])\n        \n        rootEntity.addChild(discoBall)\n        \n        // Add a support beam to hold the disco ball\n        var supportMaterial = PhysicallyBasedMaterial()\n        supportMaterial.baseColor = .init(tint: .lightGray)\n        supportMaterial.roughness = .init(floatLiteral: 0.8)\n        supportMaterial.metallic = .init(floatLiteral: 0.8)\n        \n        let support = ModelEntity(mesh: .generateCylinder(height: 0.01, radius: 0.01), materials: [supportMaterial])\n        support.scale = [0.2, 1.8, 0.2]\n        support.position = [0, 0.05, 0]\n        support.name = \"Support\"\n        \n        discoBall.addChild(support)\n        \n        // Add the shiny ball that is the base of our disco ball\n        var backgroundMaterial = PhysicallyBasedMaterial()\n        backgroundMaterial.baseColor = .init(tint: .lightGray)\n        backgroundMaterial.roughness = .init(floatLiteral: 0)\n        backgroundMaterial.metallic = .init(floatLiteral: 1)\n        \n        let background = ModelEntity(mesh: .generateSphere(radius: 0.05), materials: [backgroundMaterial])\n        background.name = \"Background\"\n        \n        // FIXME: Unintentionally inheriting an ancestor's transformation\n        support.addChild(background)\n        \n        // Add some detailed lines on top of the background\n        var lineMaterial = PhysicallyBasedMaterial()\n        lineMaterial.baseColor = .init(tint: .lightGray)\n        lineMaterial.sheen = .init(tint: .lightGray)\n        lineMaterial.emissiveColor = .init(color: .lightGray)\n        lineMaterial.emissiveIntensity = 1\n        lineMaterial.triangleFillMode = .lines\n        \n        let ballOutline = ModelEntity(mesh: .generateSphere(radius: 0.0505), materials: [lineMaterial])\n        ballOutline.name = \"Outline\"\n        \n        background.addChild(ballOutline)\n    }\n    \n    /// Marks the club as ready\n    private func openDoors() {\n        var management = self.doorSupervisor\n        management.doorsOpen = true\n        self.doorSupervisor = management\n    }\n    \n    /// finds a point along the edge of a circle on an XZ-plane, given a radius and y value. Optionally applies some variance.\n    private func pointOnCircumference(angle: Angle2D, radius: Float, variation: Float = 0, y: Float = 0) -> SIMD3<Float> {\n        .init(\n            x: (Float(cos(angle)) * radius) + .random(in: -variation...variation),\n            y: y,\n            z: (Float(sin(angle)) * radius) + .random(in: -variation...variation)\n        )\n    }\n}\n\n// MARK: Club Management\n\n/// Manages club capacity and ready state\nstruct DoorSupervisor: Component {\n    let capacity: Int\n    var doorsOpen = false\n    var visitorCount = 0\n    \n    var hasCapacity: Bool {\n        visitorCount < capacity\n    }\n}\n\n/// Tag to indicate if a retail item is in stock\nstruct OutOfStockComponent: Component {}\n\n// MARK: Revolution Control\n\n/// Works with the RevolvingSystem to apply a continuous rotation to an entity\nstruct RevolvingComponent: Component {\n    var speed: Float\n    var angle: Float\n    var axis: SIMD3<Float>\n    var relativeTo: Entity?\n    \n    init(speed: Float = 0.05, initialAngle: Float = 0, axis: SIMD3<Float> = [0, 1, 0], relativeTo: Entity? = nil) {\n        self.speed = speed\n        self.angle = initialAngle\n        self.axis = axis\n        self.relativeTo = relativeTo\n    }\n}\n\n/// Works with the RevolvingComponent to apply a continuous rotation to an entity\n@MainActor\nclass RevolvingSystem: System {\n    private static let query = EntityQuery(where: .has(RevolvingComponent.self))\n    \n    required init(scene: RealityKit.Scene) {}\n    \n    func update(context: SceneUpdateContext) {\n        for entity in context.entities(matching: Self.query, updatingSystemWhen: .rendering) {\n            if var revolvingComponent = entity.components[RevolvingComponent.self] {\n                let relativeTo = revolvingComponent.relativeTo\n                \n                revolvingComponent.angle += .pi * Float(context.deltaTime) * revolvingComponent.speed\n                entity.setOrientation(.init(angle: revolvingComponent.angle, axis: revolvingComponent.axis), relativeTo: relativeTo)\n                \n                entity.components[RevolvingComponent.self] = revolvingComponent\n            }\n        }\n    }\n}\n\n// MARK: Hover Control\n\n/// Works with the HoverSystem to apply a continuous levitation like bounce to an entity\nstruct HoverComponent: Component {\n    var speed: Float\n    var angle: Float\n    var from: SIMD3<Float>\n    var to: SIMD3<Float>\n    \n    init(speed: Float = 0.06, angle: Float = 0, from: SIMD3<Float>, to: SIMD3<Float>) {\n        self.speed = speed\n        self.angle = angle\n        self.from = from\n        self.to = to\n    }\n}\n\n/// Works with the HoverComponent to apply a continuous levitation like bounce to an entity\n@MainActor\nclass HoverSystem: System {\n    private static let query = EntityQuery(where: .has(HoverComponent.self))\n    \n    required init(scene: RealityKit.Scene) {}\n    \n    func update(context: SceneUpdateContext) {\n        for entity in context.entities(matching: Self.query, updatingSystemWhen: .rendering) {\n            if var hoverComponent = entity.components[HoverComponent.self] {\n                \n                hoverComponent.angle += .pi * Float(context.deltaTime) * hoverComponent.speed\n                \n                let range = hoverComponent.to - hoverComponent.from\n                let proportion = (sin(hoverComponent.angle) + 1) / 2\n                \n                entity.position = hoverComponent.from + (proportion * range)\n                \n                entity.components[HoverComponent.self] = hoverComponent\n            }\n        }\n    }\n}\n\n// MARK: Robot Parts\n\n/// A wrapper around a Robot Character that is actually used as an Automaton\nstruct AutomatonControl: Component {\n    var character: RobotCharacter\n}\n\nextension RobotCharacter {\n    /// manually control the animation transition of a single robot instance\n    func transitionToAndPlayAnimation(_ animationState: AnimationState) {\n        if self.animationState.transition(to: animationState) {\n            playAnimation(animationState)\n        }\n    }\n}\n\n/// A collection of shuffled robot names for our Automatons\n@MainActor\nenum RobotNames {\n    static var count: Int = 0\n    static var next: String {\n        count += 1\n        \n        return \"Robo-v\\(count)\"\n    }\n}\n\n// MARK: Teleportation\n\n/// Works with the TeleportationSystem to control spawning across all teleporters\nstruct ControlCenterComponent: Component {\n    typealias SpawnHandler = (Entity) -> Void\n    \n    var initialValue: TimeInterval\n    var interval: TimeInterval\n    var countdown: TimeInterval\n    var rootEntity: Entity\n    var _spawnHandler: SpawnHandler\n    \n    init(initialValue: TimeInterval, interval: TimeInterval, rootEntity: Entity, spawnHandler: @escaping SpawnHandler) {\n        self.initialValue = initialValue\n        self.interval = interval\n        self.countdown = initialValue\n        self.rootEntity = rootEntity\n        self._spawnHandler = spawnHandler\n    }\n}\n\n/// Represents a single Teleporter in the TeleportationSystem\nstruct TeleporterComponent: Component {}\n\n/// Works with the ControlCenterComponent to control spawning across all teleporters\n@MainActor\nclass TeleportationSystem: System {\n    private static let controlCenterQuery = EntityQuery(where: .has(ControlCenterComponent.self))\n    private static let teleporterQuery = EntityQuery(where: .has(TeleporterComponent.self))\n    private static let robotQuery = EntityQuery(where: .has(AutomatonControl.self))\n    \n    required init(scene: RealityKit.Scene) {}\n    \n    func update(context: SceneUpdateContext) {\n        for entity in context.entities(matching: Self.controlCenterQuery, updatingSystemWhen: .rendering) {\n            update(controlCenter: entity, context: context)\n        }\n    }\n    \n    private func safeToUse(teleporter: Entity, context: SceneUpdateContext) -> Bool {\n        let someBotIsStandingToClose = context.entities(matching: Self.robotQuery, updatingSystemWhen: .rendering)\n            .contains { entity in\n                distance(entity.position(relativeTo: nil), teleporter.position(relativeTo: nil)) < 0.02\n            }\n        \n        return  !someBotIsStandingToClose\n    }\n    \n    private func update(controlCenter controlCenterEntity: Entity, context: SceneUpdateContext) {\n        guard var controlCenter = controlCenterEntity.components[ControlCenterComponent.self],\n              let clubManager = controlCenter.rootEntity.components[DoorSupervisor.self],\n              clubManager.hasCapacity else {\n            return\n        }\n        \n        // 1. Decrease countdown, and activate if it reaches zero\n        controlCenter.countdown -= context.deltaTime\n        if controlCenter.countdown <= 0 {\n            \n            // 2. Find all the active teleporters and pick a random one\n            if let teleporter = context.entities(matching: Self.teleporterQuery, updatingSystemWhen: .rendering).shuffled().first {\n                \n                // 3. If no other robots are in the way, pass it to the designated spawn method\n                if safeToUse(teleporter: teleporter, context: context) {\n                    controlCenter._spawnHandler(teleporter)\n                }\n            }\n            \n            // 4. Set the delay till the next spawn event\n            controlCenter.countdown = controlCenter.interval\n        }\n        \n        // FIXME: Control Center is not being updated\n    }\n}\n\nextension ParticleEmitterComponent.Presets {\n    /// Makes a particle emitter component that looks like a teleporter\n    fileprivate static var teleporter: ParticleEmitterComponent {\n        var particleEmitter = ParticleEmitterComponent.Presets.rain\n        \n        particleEmitter.birthLocation = .surface\n        particleEmitter.emitterShape = .torus\n        particleEmitter.particlesInheritTransform = false\n        particleEmitter.fieldSimulationSpace = .global\n        particleEmitter.speed = 0.07\n        particleEmitter.speedVariation = 0.03\n        particleEmitter.radialAmount = 360\n        particleEmitter.torusInnerRadius = 0.001\n        particleEmitter.emissionDirection = [0, 1, 0]\n        particleEmitter.spawnedEmitter = nil\n        particleEmitter.burstCount = 5000\n        particleEmitter.mainEmitter.opacityCurve = .linearFadeOut\n        particleEmitter.mainEmitter.birthRate = 50\n        particleEmitter.mainEmitter.birthRateVariation = 10\n        particleEmitter.mainEmitter.lifeSpan = 0.5\n        particleEmitter.mainEmitter.lifeSpanVariation = 0.01\n        particleEmitter.mainEmitter.size = 0.001\n        particleEmitter.mainEmitter.sizeVariation = 0.0005\n        particleEmitter.mainEmitter.sizeMultiplierAtEndOfLifespan = 0.01\n        particleEmitter.mainEmitter.stretchFactor = 10\n        particleEmitter.mainEmitter.noiseStrength = 0\n        particleEmitter.mainEmitter.spreadingAngle = 0\n        particleEmitter.mainEmitter.angle = 0\n        \n        particleEmitter.spawnedEmitter = nil\n        \n        return particleEmitter\n    }\n}\n\n// MARK: Dancing\n\n/// Represents a single Attractor in the DanceMotivationSystem\nstruct AttractorComponent: Component {\n    enum State {\n        case vacant\n        case attracting\n        case motivating\n    }\n    \n    private(set) var state: State = .vacant\n    \n    var target: Entity?\n    var walkSpeed: Float = 0.1\n    var interval: TimeInterval = 5\n    var countdown: TimeInterval = 5\n    var club: Entity?\n    \n    var isVacant: Bool {\n        if case .vacant = state {\n            return true\n        }\n        return false\n    }\n    \n    mutating func setTarget(_ target: Entity) {\n        self.target = target\n        self.state = .attracting\n    }\n    \n    mutating func targetReached() {\n        self.state = .motivating\n    }\n}\n\n/// Represents a single Robot in the DanceMotivationSystem\nstruct Newcomer: Component {}\n\n/// Works with the DanceMotivationSystem to provide additional Debug information to the RealityKit Debugger\nstruct DanceSystemDebugComponent: Component {\n    var states: UIImage? = nil\n    var vacant: Int = 0\n    var attracting: Int = 0\n    var motivating: Int = 0\n}\n\n/// Provides additional Debug information about a single Attractor in the DanceMotivationSystem to the RealityKit Debugger\nstruct AttractorDebugComponent: Component {\n    var state: AttractorComponent.State\n    var attractor: Entity\n    var robot: Entity?\n}\n\n/// Manages the states of dance floor attractors, the movement of robots and the relationships between them\n@MainActor\nclass DanceMotivationSystem: System {\n    private static let attractorQuery = EntityQuery(where: .has(AttractorComponent.self))\n    private static let targetQuery = EntityQuery(where: .has(Newcomer.self))\n    private static let clubbersQuery = EntityQuery(where: .has(AutomatonControl.self))\n    private static let debugRootQuery = EntityQuery(where: .has(DanceSystemDebugComponent.self))\n    private static let debugVisualizationsQuery = EntityQuery(where: .has(AttractorDebugComponent.self))\n    \n    required init(scene: RealityKit.Scene) {}\n    \n    func update(context: SceneUpdateContext) {\n        \n        // 1. Check for newcomers at the club who could be enticed to come and dance\n        for visitor in context.entities(matching: Self.targetQuery, updatingSystemWhen: .rendering) {\n            \n            // 2. Randomly pick an attractor\n            guard let attractor = context.entities(matching: Self.attractorQuery, updatingSystemWhen: .rendering)\n                .filter({ $0.components[AttractorComponent.self]?.isVacant ?? false })\n                .randomElement() else {\n                return\n            }\n            \n            // 3. Start attracting the visitor\n            var attractorComponent = attractor.components[AttractorComponent.self]!\n            attractorComponent.setTarget(visitor)\n            attractor.components[AttractorComponent.self] = attractorComponent\n            \n            // FIXME: Stop attractors competing over the same bot\n        }\n        \n        // Let the attractors do their thing and attract visitors to come and dance\n        for attractor in context.entities(matching: Self.attractorQuery, updatingSystemWhen: .rendering) {\n            guard var attractorComponent = attractor.components[AttractorComponent.self] else {\n                continue\n            }\n            \n            switch attractorComponent.state {\n            case .attracting:\n                if let updatedAttractorComponent = attractRobot(attractor: attractor, deltaTime: Float(context.deltaTime)) {\n                    attractorComponent = updatedAttractorComponent\n                }\n                \n            case .motivating:\n                if let updatedAttractorComponent = motivateRobot(attractor: attractor, context: context) {\n                    attractorComponent = updatedAttractorComponent\n                }\n                \n            default:\n                break\n            }\n            \n            // save changes\n            attractor.components[AttractorComponent.self] = attractorComponent\n        }\n        \n#if DEBUG\n        updateDebugInfo(context: context)\n#endif\n    }\n    \n    private func attractRobot(attractor: Entity, deltaTime: Float) -> AttractorComponent? {\n        guard var attractorComponent = attractor.components[AttractorComponent.self],\n              case .attracting = attractorComponent.state,\n              let target = attractorComponent.target,\n              let robotCharacter = target.components[AutomatonControl.self]?.character else {\n            return nil\n        }\n        \n        // robots wave when they first arrive, make sure that is completed first before moving\n        var transitionAnimationTo: AnimationState?\n        switch robotCharacter.animationState {\n        case .wave: transitionAnimationTo = .idle\n        case .idle: transitionAnimationTo = .walkLoop\n        case .walkLoop: transitionAnimationTo = nil\n        default: return attractorComponent\n        }\n        \n        if let transitionAnimationTo {\n            if robotCharacter.animationState.transition(to: transitionAnimationTo) {\n                robotCharacter.playAnimation(robotCharacter.animationState)\n            }\n        }\n        \n        // Convert the robot and target positions into the same coordinate system\n        let targetPosition = target.position(relativeTo: attractorComponent.club)\n        var danceSpotPosition = attractor.position(relativeTo: attractorComponent.club)\n        danceSpotPosition.y = targetPosition.y\n        \n        let movementVector = danceSpotPosition - targetPosition\n        let normalizedMovement = movementVector / length(movementVector)\n        let move = normalizedMovement * deltaTime * attractorComponent.walkSpeed\n        \n        target.setPosition(targetPosition + move, relativeTo: attractorComponent.club)\n        \n        robotCharacter.characterModel.look(at: robotCharacter.characterModel.position - normalizedMovement,\n                                           from: robotCharacter.characterModel.position, relativeTo: robotCharacter.characterParent)\n        \n        // If the target is more or less in position then attach to the dance spot and change state to motivating\n        if distance(danceSpotPosition, target.position(relativeTo: attractorComponent.club)) < 0.005 {\n            attractor.addChild(target, preservingWorldTransform: true)\n            \n            // Start Dancing\n            robotCharacter.transitionToAndPlayAnimation(.celebrate)\n            \n            // Update attractor state\n            attractorComponent.targetReached()\n        }\n        \n        return attractorComponent\n    }\n    \n    private func motivateRobot(attractor: Entity, context: SceneUpdateContext) -> AttractorComponent? {\n        guard var attractorComponent = attractor.components[AttractorComponent.self],\n              case .motivating = attractorComponent.state,\n              let target = attractorComponent.target,\n              let robotCharacter = target.components[AutomatonControl.self]?.character else {\n            return nil\n        }\n        \n        attractorComponent.countdown -= context.deltaTime\n        \n        if attractorComponent.countdown <= 0 {\n            // Turn to face a random fellow clubber\n            if let friend = Array(context.entities(matching: Self.clubbersQuery, updatingSystemWhen: .rendering)).randomElement() {\n                let friendsPosition = friend.position(relativeTo: robotCharacter.characterParent)\n                \n                robotCharacter.characterModel.look(at: friendsPosition,\n                                                   from: robotCharacter.characterModel.position, relativeTo: robotCharacter.characterParent)\n                \n                // TODO: remove me\n                print(\"🔥 friendsPosition \\(friendsPosition) targetPosition \\(robotCharacter.characterModel.position)\")\n            }\n            \n            attractorComponent.countdown = attractorComponent.interval\n        }\n        \n        return attractorComponent\n    }\n    \n#if DEBUG\n    let vacantColor = UnlitMaterial.BaseColor(tint: .yellow.withAlphaComponent(0.5))\n    let attractingColor = UnlitMaterial.BaseColor(tint: .orange.withAlphaComponent(0.5))\n    let motivatingColor = UnlitMaterial.BaseColor(tint: .red.withAlphaComponent(0.5))\n    \n    private func updateDebugInfo(context: SceneUpdateContext) {\n        var vacantCount: Int = 0\n        var attractingCount: Int = 0\n        var motivatingCount: Int = 0\n        \n        context.entities(matching: Self.debugVisualizationsQuery, updatingSystemWhen: .rendering).forEach { visualization in\n            guard let visualizationComponent = visualization.components[AttractorDebugComponent.self],\n                  let attractorComponent = visualizationComponent.attractor.components[AttractorComponent.self] else {\n                return\n            }\n            \n            updateVisualizationEntity(visualization, relativeTo: attractorComponent.club)\n            \n            switch attractorComponent.state {\n            case .vacant: vacantCount += 1\n            case .attracting: attractingCount += 1\n            case .motivating: motivatingCount += 1\n            }\n        }\n        \n        context.entities(matching: Self.debugRootQuery, updatingSystemWhen: .rendering).forEach { debugRoot in\n            if var debugComponent = debugRoot.components[DanceSystemDebugComponent.self] {\n                debugComponent.vacant = vacantCount\n                debugComponent.attracting = attractingCount\n                debugComponent.motivating = motivatingCount\n                debugComponent.states = makeChart(vacantCount: vacantCount, attractingCount: attractingCount, motivatingCount: motivatingCount)\n                debugRoot.components[DanceSystemDebugComponent.self] = debugComponent\n            }\n        }\n    }\n    \n    private func updateVisualizationEntity(_ visualization: Entity, relativeTo root: Entity?) {\n        guard var visualizationComponent = visualization.components[AttractorDebugComponent.self],\n              let attractorComponent = visualizationComponent.attractor.components[AttractorComponent.self] else {\n            return\n        }\n        \n        // Update the position\n        var position = visualizationComponent.attractor.position(relativeTo: root)\n        position.y = visualization.position.y\n        visualization.setPosition(position, relativeTo: root)\n        \n        // Update the state\n        visualizationComponent.state = attractorComponent.state\n        visualization.name = \"[Debug] \\(visualizationComponent.attractor.name) (\\(attractorComponent.state))\"\n        \n        // Update the base material color to signify the attractor state\n        if var modelComponent = visualization.components[ModelComponent.self],\n           var material = modelComponent.materials.first as? UnlitMaterial {\n            \n            switch attractorComponent.state {\n            case .vacant: material.color = vacantColor\n            case .attracting: material.color = attractingColor\n            case .motivating: material.color = motivatingColor\n            }\n            \n            modelComponent.materials = [material]\n            visualization.components[ModelComponent.self] = modelComponent\n        }\n        \n        // Update the target\n        visualizationComponent.robot = attractorComponent.target\n        visualization.components[AttractorDebugComponent.self] = visualizationComponent\n    }\n    \n    private func makeChart(vacantCount: Int, attractingCount: Int, motivatingCount: Int) -> UIImage? {\n        ImageRenderer(content: chartView(vacantCount: vacantCount, attractingCount: attractingCount, motivatingCount: motivatingCount)).uiImage\n    }\n    \n    private func chartView(vacantCount: Int, attractingCount: Int, motivatingCount: Int) -> some View {\n        Chart(\n            [\n                (name: \"Vacant\", count: vacantCount),\n                (name: \"Attracting\", count: attractingCount),\n                (name: \"Motivating\", count: motivatingCount)\n            ], id: \\.name) { name, count in\n                SectorMark(\n                    angle: .value(\"Value\", count),\n                    angularInset: 1.5\n                )\n                .cornerRadius(5)\n                .foregroundStyle(by: .value(\"Name\", name))\n        }\n        .chartLegend(.hidden)\n        .chartForegroundStyleScale([\"Vacant\": .yellow, \"Attracting\": .orange, \"Motivating\": .red])\n        .frame(width: 1024, height: 1024)\n    }\n    \n#endif\n}\n\n// MARK: Debug Helpers\n\nextension Entity {\n    /// creates an semi-transparent entity that can be useful in debug invisible entities in the RealityKit Debugger\n    static func makeDebugMarker(name: String? = nil, height: Float, radius: Float, color: UIColor = .white, enabled: Bool = false) -> Entity? {\n#if DEBUG\n        var debugMaterial = UnlitMaterial()\n        debugMaterial.color = .init(tint: color)\n        debugMaterial.blending = .transparent(opacity: 0.7)\n        \n        let marker = ModelEntity(mesh: .generateCylinder(height: height, radius: radius), materials: [debugMaterial])\n        if let name {\n            marker.name = name\n        }\n        marker.isEnabled = enabled\n        \n        return marker\n#else\n        return nil\n#endif\n    }\n    \n    /// adds an semi-transparent child entity that can be useful in debug invisible entities in the RealityKit Debugger\n    @discardableResult\n    func addDebugMarker(name: String? = nil, height: Float? = nil, radius: Float? = nil, color: UIColor = .white, enabled: Bool = false) -> Entity? {\n#if DEBUG\n        var markerRadius: Float\n        if radius != nil {\n            markerRadius = radius!\n        } else {\n            // If no provided radius then calculate from the visual bounds\n            let extents = visualBounds(relativeTo: nil).extents\n            let boundingXZRadius = max(extents.x, extents.z) / 2\n            \n            if boundingXZRadius.isNormal {\n                markerRadius = boundingXZRadius\n            } else {\n                // If no visual bounds then use a default radius of 1cm\n                markerRadius = 0.01 * scale(relativeTo: nil).max()\n            }\n        }\n        \n        // If no provided height then use a default value of 10cm\n        let markerHeight = height ?? 0.1 * scale(relativeTo: nil).max()\n        \n        let name = name ?? \"[Debug] \\(self.name)\"\n        if let marker = Entity.makeDebugMarker(name: name, height: markerHeight, radius: markerRadius, color: color, enabled: enabled) {\n            marker.position = [0, markerHeight / 2, 0]\n            addChild(marker)\n            \n            return marker\n        }\n#endif\n        return nil\n    }\n}\n\n// MARK: Demo Helpers\n\nextension MeshResource {\n    /// Generates an cylinder with all the normals facing downwards. Probably has no uses other than demo'ing a broken mesh.\n    static func generateAbnormalCylinder(height: Float, radius: Float) -> MeshResource {\n        let meshResource = MeshResource.generateCylinder(height: height, radius: radius)\n        var contents = meshResource.contents\n        let models = contents.models.map { model in\n            var model = model\n            let parts = model.parts.map { part in\n                var part = part\n                part.normals = part.normals.map { normals in\n                    let transformedNormals: [SIMD3<Float>] = normals.map { _ in\n                        [0, -1, 0]\n                    }\n                    \n                    return MeshBuffer(transformedNormals)\n                }\n                \n                return part\n            }\n            model.parts = MeshPartCollection(parts)\n            \n            return model\n        }\n        contents.models = MeshModelCollection(models)\n        try? meshResource.replace(with: contents)\n        \n        return meshResource\n    }\n}"
    },
    {
      "timestamp": "3:02",
      "title": "Add a volumetric club scene",
      "language": "swift",
      "code": "WindowGroup(id: \"RobotClub\") {\n    GeometryReader3D { geometry in\n        ClubView()\n            .volumeBaseplateVisibility(.visible)\n            .environment(appState)\n            .scaleEffect(geometry.size.width / initialVolumeSize.width)\n    }\n    .onAppear {\n        dismissWindow(id: \"RobotCreation\")\n    }\n}\n.windowStyle(.volumetric)\n.defaultWorldScaling(.dynamic)\n.defaultSize(initialVolumeSize)"
    },
    {
      "timestamp": "3:09",
      "title": "Add a button to open the club",
      "language": "swift",
      "code": "VStack {\n    Button(\"🪩\") {\n        openWindow(id: \"RobotClub\")\n    }\n    .padding()\n\n    Spacer()\n}\n.padding([.trailing, .top])"
    },
    {
      "timestamp": "6:50",
      "title": "FIX: Unintentionally inheriting an ancestor's transformation",
      "language": "swift",
      "code": "discoBall.addChild(background)"
    },
    {
      "timestamp": "10:18",
      "title": "FIX: Control Center is not being updated",
      "language": "swift",
      "code": "// 5. Save updated component back to the entity\ncontrolCenterEntity.components[ControlCenterComponent.self] = controlCenter"
    },
    {
      "timestamp": "18:15",
      "title": "FIX: Stocking bottles",
      "language": "swift",
      "code": "private func stockBottles(placementRadius: Float) -> Entity {\n    let bottleRadius: Float = 0.003\n    let bottleHeight: Float = 0.022\n    let angleIncrement: Float = -12\n    let outOfStockBrands: Set = [3]\n    \n    // Make a wrapper entity\n    let bottleGroup = Entity()\n    bottleGroup.name = \"Bottle Group\"\n    bottleGroup.position = [0, 0.04, 0]\n    bottleGroup.orientation = .init(angle: 180 * (.pi / 180), axis: [0, 1, 0])\n    \n    // Make a nice green material\n    var bottleMaterial = PhysicallyBasedMaterial()\n    bottleMaterial.baseColor = .init(tint: .green)\n    bottleMaterial.blending = .transparent(opacity: .init(floatLiteral: 0.5))\n    \n    for i in 0..<9 {\n        let angle = Angle2D(degrees: angleIncrement * Float(i))\n        let bottleMesh = MeshResource.generateCylinder(height: bottleHeight, radius: bottleRadius)\n        let bottle = ModelEntity(mesh: bottleMesh, materials: [bottleMaterial])\n        bottle.name = \"BT\\(i)\"\n        bottle.position = pointOnCircumference(angle: angle, radius: placementRadius, y: bottleHeight / 2)\n        if outOfStockBrands.contains(i) {\n            bottle.components[OutOfStockComponent.self] = OutOfStockComponent()\n        }\n        \n        bottleGroup.addChild(bottle)\n    }\n    \n    return bottleGroup\n}"
    },
    {
      "timestamp": "22:48",
      "title": "FIX: Attractors",
      "language": "swift",
      "code": "// 4. Untag them as a Newcomer\nvisitor.components[Newcomer.self] = nil"
    }
  ],
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "Forum: Developer Tools & Services",
        "url": "https://developer.apple.com/forums/topics/developer-tools-and-services?cid=vf-a-0010"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2024/10172/4/F5FD7DC0-A6BA-481C-B21E-AE269E0B8A1E/downloads/wwdc2024-10172_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2024/10172/4/F5FD7DC0-A6BA-481C-B21E-AE269E0B8A1E/downloads/wwdc2024-10172_sd.mp4?dl=1"
  },
  "relatedVideos": [
    {
      "id": "10103",
      "year": "2024",
      "title": "Discover RealityKit APIs for iOS, macOS, and visionOS",
      "url": "https://developer.apple.com/videos/play/wwdc2024/10103"
    }
  ],
  "extractedAt": "2025-07-18T09:40:19.856Z"
}