{
  "id": "10144",
  "year": "2024",
  "url": "https://developer.apple.com/videos/play/wwdc2024/10144/",
  "title": "What’s new in SwiftUI",
  "speakers": [],
  "duration": "",
  "topics": [
    "Essentials"
  ],
  "hasTranscript": true,
  "hasCode": true,
  "transcript": {
    "fullText": "Hi, and thanks for tuning in! I’m Sommer! And I’m Sam! We’re both engineers on the SwiftUI team. And we’re excited to tell you all about what’s new in SwiftUI.\n\nTo help with our karaoke habit, Sam and I have been working on an app to plan our regular team karaoke parties.\n\nOur app harnesses so many improvements to SwiftUI, and we're excited to share those improvements with you! Starting with plenty of great features to make your apps feel brand new. Tools to refine your apps so they feel at home on every platform. Widespread improvements to the foundational building blocks of the framework. And a whole suite of new tools for crafting immersive experiences. Whew! That’s a lot to cover, so let’s dive right in. You can really freshen up your apps with SwiftUI, from a new tab view, to beautiful mesh gradients, and snappy controls! Sam and I wrote a karaoke event planner app. It’s primarily a side bar driven app, and in iOS 18.0, the sidebar has become a lot more flexible. With just the touch of a button, our main-view changes to a tab bar representation for showing more of that beautiful UI. The tab bar now floats above the content! People can even customize the experience completely to their liking, reordering the items and hiding infrequently used options.\n\nIt was easy to rewrite my main view to use the new tabview.\n\nNow, TabView has a new type-safe syntax in SwiftUI to make it easier to catch common errors at build time. And, as your content grows, it’s simple to make your tab view more flexible. By just applying the new .sidebarAdaptable tab view style, karaoke planners can now switch between the tab bar and sidebar view.\n\nThe sidebar looks great when you have a lot of content, like all these song lists, and it even has customization behavior like reordering and removing tabs, which is completely programmatically controllable. The refreshed side bar also looks great on tvOS, and you can style the tab view to appear as a sidebar or as a segmented control in the toolbar on macOS! Sheet presentation sizing is now unified and simplified across platforms. You can use the .presentationSizing modifier to create perfectly-sized sheets with .form or .page, or even use custom sizing. SwiftUI supports a new zoom navigation transition too, and I can use it to make expanding info on a party look gorgeous.\n\nFor more on the new TabView check out \"Improve your tab and sidebar experience on iPad\". And to dive deeper into new animations watch \"Enhance your UI animations and transitions\".\n\nYou can now create your own custom resizable controls such as buttons and toggles that live in control center or the lock screen and can even be activated by the action button. Controls are a new kind of Widget that that are easy to build with App Intents! With just a few lines of code, I can create a ControlWidgetButton to get the WWDC karaoke party started at a moment’s notice! To learn how to use the new and powerful controls API to customize your configurable buttons and toggles, check out: \"Access your app's controls across the system.\" Sam and I have been working hard to grow our karaoke party attendance. I think an exponential function seems like very reasonable goal.\n\nFunction plotting in Swift charts makes it easy for me draw beautiful graphs, like this LinePlot.\n\nI’ll go ahead and graph the actual attendance too.\n\nOof, not quite there yet.\n\nTo dig deeper into the improvements in Swift Charts, catch \"Swift Charts: Vectorized and function plots\".\n\nAs a data nerd, I also like to keep track of how much the attendees are singing at the parties.\n\nUsing TableColumnForEach, I can now have a dynamic number of table columns for however many parties Sam and I have! To boost our attendance numbers, I think we should send out some colorful party invites! SwiftUI has added first class support for colorful mesh gradients. By interpolating between the points on a grid of colors, you can create a beautiful lattice! This sounds like the perfect way make our karaoke invites as snazzy as our parties! Now that the Karaoke Planner App is looking fresh, Sam and I want to have a little extra fun by customizing our lyrics! So, we’ve also built a document-based app for editing the words to our favorite songs. I crafted this launch screen to express my app’s individuality and highlight its features using the new Document Launch Scene type.\n\nI created a big bold title, customized the background and added some fun accessory views to really make my launch experience pop! To learn more about all you can do with document based apps, like custom document icons and templates watch “Evolve your document launch experience” I’m going to put a finishing touch on my launch screen now, using a symbol effect on my music notes! Wow, my symbols really do wiggle wiggle.\n\nApps can now adopt three new animation presets for SF Symbols. The wiggle effect oscillates a symbol in any direction or angle to draw attention.\n\nThe breathe effect smoothly scales a symbol up and down to indicate ongoing activity. And the rotate effect spins some parts of a symbol around a designated anchor point.\n\nSome of the existing presets have also been enhanced with new features. For example, the default Replace animation now prefers a new MagicReplace behavior. With MagicReplace, symbols smoothly animate badges and slashes.\n\nThese are just a few of the enhancements in SF Symbols 6. To learn more watch “What’s new in SF Symbols”.\n\nSwiftUI brings great improvements to making your apps feel at home on any of Apple’s platforms. With improved windowing, more control over input and lots of glanceable content, your apps can take advantage of whatever platform they’re on. You can now tailor the style and behavior of windows on macOS.\n\nIn my lyric editor app on macOS, I have a window that shows a single line preview. I used the new plain window style to remove the default window chrome. And gave it a floating window level so it shows on top of any other windows. I used the defaultWindowPlacement API to place it at the top of the screen, so it doesn't cover-up the rest of my lyrics; I took into account the size of the display, and the size of the content, to place it in the perfect spot.\n\nI also added a WindowDragGesture to the content view of the preview so I can adjust its position on screen by dragging it around.\n\nThere are new scene types too, like utility window! To learn more about ways to customize the style and behavior of your windows, watch “Tailor macOS windows with SwiftUI!”.\n\nThis multi-window lyrics editor app works great on visionOS too! Recently my fellow karaoke pal Andrew showed me how he’s using this new push window action in the Botanist app to help him keep his most important content focused! pushWindow can be used to open a window and hide the originating window. I definitely want to do the same thing in my Lyrics editor, so I’ll use the pushWindow environment action to focus on my lyric preview. Learn more in the video: \"Work with windows in SwiftUI\". SwiftUI gives you many new tools for taking advantage of the unique input methods each platform offers.\n\nIn visionOS, you can make views react when people look at them, place a finger near them, or move the pointer over them, all while preserving people’s privacy.\n\nWithin the new closure-based hoverEffect modifier, I can control how the view looks as it transitions between the active and IN-active states To learn how you can also coordinate multiple effects, control the timing of an effect, and respond to accessibility settings, check out “Create custom hover effects in visionOS.” Great iPadOS, macOS, and visionOS apps provide great keyboard support.\n\nIn the main menu on macOS, I have an item to open my preview window.\n\nI've added the new modifierKeyAlternate modifier, and on press of the option key I can reveal a secondary item to preview in full-screen.\n\nFor low level control, any view can respond to modifier key press state changes. I updated the lyric editor to use onModifierKeysChanged. So when I hold down option, I can see and adjust an extra alignment guide for where the bouncing ball lands on the lyrics.\n\nPointer interaction is another important form of input across many devices.\n\nThe pointerStyle API lets you customize the appearance and visibility of the system pointer. Since I made my lyrics resizable, I’ll apply an appropriate frameResize pointer style on each resize anchor.\n\nNew in iPadOS 17.5, SwiftUI has support for features of Apple Pencil and Apple Pencil Pro like double-tap and squeeze.\n\nWith .onPencilSqueeze, I can gather information from the gesture and see what action is preferred. In this case, I’m going to show my lyrics doodle palette under the pencil’s hover location so I can mark up lyrics with fun drawings. To learn more about all the new Apple Pencil APIs, head over to \"Squeeze the most out of Apple Pencil\". Widgets offer glanceable information and key interactions with your apps. And now that Live Activities have also come to watchOS, your iOS based live activities will automatically show up on Apple Watch, without any work on your part! Sam and I already have this live activity to review song lyrics on the go, and I can see it showing up automatically on my Apple Watch! To make it look really amazing, I can use the new small .supplementalActivityFamily to tailor the content for watchOS, showing more lyrics at once. Nice! And to allow our singers to advance the lyrics using double tap, I can apply the .handGestureShortcut modifier.\n\nI also want to be sure that I always know when I’m up next at a karaoke event, so I added a widget to my Planner app using the new reference date format style to show a countdown to Karaoke o’ clock! Text now has additional formats for the display of live times and dates that work great in widgets and live activities! These formats include date references, date offsets and timers. Each format is deeply customizable down to its components, and can even adapt to the size of its container.\n\nWidgets are smarter now too. Specify relevant contexts so the system can more intelligently surface them in places like smart stacks. With this, my countdown widget can show up automatically at a specified time, or when a singer gets close to a planned karaoke venue! Hey Sommer, How’s the lyrics editor coming along? I’ve been thinking up lyrics for my next solo, \"Cupertino Dreamin\", and I’ve gotta get it written down before I forget! It’s going great! I just used it to write some lyrics for “Smells Like Scene Spirit”, it’s gonna rock. Nice, we can try to slot that in towards the end of the setlist. That reminds me: the setlist! Is it gonna be ready for the WWDC karaoke party? You bet Sommer. The theme for the songs is all of SwiftUI’s great new Framework foundations. SwiftUI has added all sorts of new API that make working with the framework feel easier than ever, Including improvements to the core components of SwiftUI, new ways to use foundational APIs, and ease of use enhancements.\n\nYou can now create your own custom container views. A new API on ForEach, subviewOf, lets you to iterate over the subviews of a given view, like in this example where I'm wrapping each subview in its own card view. You can use this to make custom containers that have the same capabilities as SwiftUI’s built in containers like list and picker, including mixing static, and dynamic content supporting sections, and adding container specific modifiers. To learn more about custom containers and the SwiftUI fundamentals behind them, be sure to check out \"Demystify SwiftUI Containers\". New ease of use improvements make working with SwiftUI easier than ever. Instead of having to write out a full conformance to EnvironmentKey, and an extension on environment values, you can now just write a simple property with the new Entry macro. Best of all, it doesn’t just work with environment values. The entry macro can also be used with FocusValues, Transaction, and the new ContainerValues as well.\n\nYou can now attach additional information to SwiftUI's built in accessibility labels. That means you can add additional accessibility information to a control, without overriding the framework provided label. Be sure to check out \"Catch up on accessibility in SwiftUI\" to learn about all of SwiftUI’s amazing new accessibility features, such as conditional modifier support, and app intent based accessibilityActions.\n\nXcode previews has a new dynamic linking architecture that allows you to switch between a preview, and build-and-run without needing to re-build your project, increasing your iteration speed.\n\nAnd it’s now easier to set up Previews too. You can now use State directly in previews using the Previewable macro, eliminating the boilerplate of wrapping your preview content in a view.\n\nThere are now new ways to work with text and manage selection. SwiftUI now offers programatic access to, and control of text selection within text editing controls! The contents of my selection binding update to match the selected text of the lyric fields.\n\nNow I can read properties of the selection, such as the selected ranges. I can use this to show suggested rhymes for selected words in the inspector.\n\nWith .searchFocused, you can programmatically drive the focus state of a search field, meaning you can check if a search field is focused on, and programmatically move focus to and from the search field.\n\nYou can now add text suggestions to any text field. I'll use this to provide suggestions for how to finish a line. The suggestions appear as a drop down menu, and when I pick an option my textfield updates with the selected completion.\n\nSwiftUI also has new graphics capabilities.\n\nYou can now beautifully mix colors together. A new mix modifier on color blends it with another Color by a given amount. We’ve also extended the custom shader feature with the ability to precompile shaders before their first use, so you can avoid frame drops caused by lazy shader compilation.\n\nThere are a bunch of new APIs to give you fine grained control of your scroll views. You can now have deeper level of integration with the state of a ScrollView with .onScrollGeometryChange, which lets you performantly react to changes in things like content offsets, content size and more. Like with this \"back to invitation\" button, which appears when I scroll past the top of the scroll view's contents.\n\nYou can now detect when a view’s visibility has changed due to scrolling! Letting you create great experiences centered around content moving on or off screen, like this auto-playing video.\n\nNot only do you have more programatic control over your scroll view, but you also have more scroll positions to programmatically scroll to, like the top edge! There are all sorts of additional knobs for you to turn to really dial in on your perfect scrolling experience like turning off bouncing along a given axis, programmatically stoping scrolling, finely controlling your content alignment, and more. The new Swift 6 language mode enables compile-time data-race safety, and SwiftUI has improved its APIs to make it easier to adopt the new language mode in your apps.\n\nViews in SwiftUI have always been evaluated on the main actor, and the view protocol is now marked with the main actor annotation to reflect that. That mean all types conforming to View are implicitly isolated to the main actor by default. So if you were explicitly marking your Views as main actor, you can now remove that annotation without any change in behavior. The new Swift 6 language mode is opt-in, so you can take advantage of it whenever you're ready. To learn more about compile time checking, be sure to watch \"Migrate your app to Swift 6\".\n\nSwiftUI was designed not just for building brand new apps, but also building new features in existing apps written with UIKit and AppKit. Great interoperability with these frameworks is critical. We made significant improvements to the integration of gestures and animation. You can now take any built-in or custom UIGestureRecognizer and use it in your SwiftUI view hierarchy. This works even on SwiftUI views that aren't directly backed by UIKit.\n\nAnd the interoperability improvements go the other way as well. UIKit and AppKit can now take advantage of the power of SwiftUI animations. SwiftUI defines a new animate function on UIView, and NSAnimationContext, allowing UIKit and AppKit changes to be animated using in-process SwiftUI animations.\n\nVelocity is even automatically preserved for gesture-driven animations, just like in SwiftUI views. And UI and NSViewRepresentable context provide new API for bridging animations started in SwiftUI into UIKit and AppKit, ensuring animations run perfectly in sync, even across framework boundaries.\n\nFor more on using animations across frameworks, be sure to check out \"Enhance your UI animations and transitions\". Those foundational improvements look great. Now, all that’s left to is practice my karaoke skills, and then I can get together with Sommer and host the party. SwiftUI’s new tools for crafting experiences will help with both building a great practice app, and setting up the event to be a success.\n\nNew APIs for working with volumes, and immersive spaces, as well as new text effects will help bring our karaoke experience to life.\n\nTo practice my beautiful vocals, I’ve built a visionOS practice app, featuring a microphone in a Volume.\n\nIn visionOS 2, volumes can show a baseplate. This helps you get a sense of the bounds of the Volume, and guides you to the window controls, including the new resize handle. Our microphone already has a microphone stand base, so I like the look of it without the system provided baseplate. I'll use the .volumeBaseplateVisibility modifier to disable the system provided baseplate. Nice! I also made my microphone rotate to always face the singer using the new .onVolumeViewpointChange modifier. This is called any time I move to a new side of the Volume, letting me react to changes in how it’s being viewed.\n\nI’ve got my microphone, now I need a place to put it, and there’s no better place to sing karaoke than a moody karaoke lounge.\n\nI’ve already got a beautiful immersive space, and I can now control the allowed immersion levels.\n\nBy choosing an initial immersion of fifty percent, and a minimum of forty, I can help singers ease into the karaoke lounge.\n\nTo help set the vibe, I can now apply effects to the passthrough video around my progressive immersive space. I could use preferred-surroundings-effect to dim video passthrough or to really make our karaoke experience special, I can use colorMultiply for some cool mood lighting! Ooooh, that’s fantastic.\n\nFor more on improvements to volumes and immersive spaces, including new ways to attach ornaments and specify supported viewpoints be sure to check out “Dive deep into volumes and immersive spaces”.\n\nThe stage is set but before we start the party, we’ll need lyrics we can follow along with! You can now extend SwiftUI Text views with custom rendering effects and interaction behaviors. I can use this to build a word highlighting effect for our karaoke lyrics. My karaoke renderer creates a copy of the text behind the original drawing, which is blurred. and has a tint, making the text look like it's glowing purple! By applying this highlight effect to only certain words, and adding some final polish, I can make some truly incredible effects, like this karaoke word highlighting. To learn all about how to create these amazing text effects, be sure to check out \"Create custom visual effects with SwiftUI.\" Alright Sommer, I think we’ve done all of our party prep. It really is coming together! These changes to SwiftUI really helped Sommer and I make the most of our apps, and we want you to make the most of yours too. If you have a sidebar-based iPad or tvOS app, leverage the new tab view APIs to allow for more flexibility, and for document based apps, enhance your new document launch experience. Add new windowing and input capabilities to your macOS and visionOS apps. Make the most of your live activity by fine-tuning your experience on watchOS. And take advantage of the new capabilities in volumes and immersive spaces on visionOS. It’s looking like a good year to be a SwiftUI developer! And karaoke singer. Alright Sam, are you ready? I was born ready Sommer. Hey Siri, Start the Party!",
    "segments": []
  },
  "codeExamples": [
    {
      "timestamp": "1:38",
      "title": "TabView",
      "language": "swift",
      "code": "import SwiftUI\n\nstruct KaraokeTabView: View {\n    @State var customization = TabViewCustomization()\n    \n    var body: some View {\n        TabView {\n            Tab(\"Parties\", image: \"party.popper\") {\n                PartiesView(parties: Party.all)\n            }\n            .customizationID(\"karaoke.tab.parties\")\n            \n            Tab(\"Planning\", image: \"pencil.and.list.clipboard\") {\n                PlanningView()\n            }\n            .customizationID(\"karaoke.tab.planning\")\n\n            Tab(\"Attendance\", image: \"person.3\") {\n                AttendanceView()\n            }\n            .customizationID(\"karaoke.tab.attendance\")\n\n            Tab(\"Song List\", image: \"music.note.list\") {\n                SongListView()\n            }\n            .customizationID(\"karaoke.tab.songlist\")\n        }\n        .tabViewStyle(.sidebarAdaptable)\n        .tabViewCustomization($customization)\n    }\n}\n\nstruct PartiesView: View {\n    var parties: [Party]\n    var body: some View { Text(\"PartiesView\") }\n}\n\nstruct PlanningView: View {\n    var body: some View { Text(\"PlanningView\") }\n}\n\nstruct AttendanceView: View {\n    var body: some View { Text(\"AttendanceView\") }\n}\n\nstruct SongListView: View {\n    var body: some View { Text(\"SongListView\") }\n}\n\nstruct Party {\n    static var all: [Party] = []\n}\n\n#Preview {\n    KaraokeTabView()\n}"
    },
    {
      "timestamp": "2:28",
      "title": "Presentation sizing",
      "language": "swift",
      "code": "import SwiftUI\n\nstruct AllPartiesView: View {\n    @State var showAddSheet: Bool = true\n    var parties: [Party] = []\n    \n    var body: some View {\n        PartiesGridView(parties: parties, showAddSheet: $showAddSheet)\n            .sheet(isPresented: $showAddSheet) {\n                AddPartyView()\n                    .presentationSizing(.form)\n            }\n    }\n}\n\nstruct PartiesGridView: View {\n    var parties: [Party]\n    @Binding var showAddSheet: Bool\n    \n    var body: some View {\n        Text(\"PartiesGridView\")\n    }\n}\n\nstruct AddPartyView: View {\n    var body: some View {\n        Text(\"AddPartyView\")\n    }\n}\n\nstruct Party {\n    static var all: [Party] = []\n}\n\n#Preview {\n    AllPartiesView()\n}"
    },
    {
      "timestamp": "2:39",
      "title": "Zoom transition",
      "language": "swift",
      "code": "import SwiftUI\n\nstruct PartyView: View {\n    var party: Party\n    @Namespace() var namespace\n    \n    var body: some View {\n        NavigationLink {\n            PartyDetailView(party: party)\n                .navigationTransition(.zoom(\n                    sourceID: party.id, in: namespace))\n        } label: {\n            Text(\"Party!\")\n        }\n        .matchedTransitionSource(id: party.id, in: namespace)\n    }\n}\n\nstruct PartyDetailView: View {\n    var party: Party\n    \n    var body: some View {\n        Text(\"PartyDetailView\")\n    }\n}\n\nstruct Party: Identifiable {\n    var id = UUID()\n    static var all: [Party] = []\n}\n\n#Preview {\n    @Previewable var party: Party = Party()\n    NavigationStack {\n        PartyView(party: party)\n    }\n}"
    },
    {
      "timestamp": "3:18",
      "title": "Controls API",
      "language": "swift",
      "code": "import WidgetKit\nimport SwiftUI\n\nstruct StartPartyControl: ControlWidget {\n    var body: some ControlWidgetConfiguration {\n        StaticControlConfiguration(\n            kind: \"com.apple.karaoke_start_party\"\n        ) {\n            ControlWidgetButton(action: StartPartyIntent()) {\n                Label(\"Start the Party!\", systemImage: \"music.mic\")\n                Text(PartyManager.shared.nextParty.name)\n            }\n        }\n    }\n}\n\n// Model code\n\nclass PartyManager {\n    static let shared = PartyManager()\n    var nextParty: Party = Party(name: \"WWDC Karaoke\")\n}\n\nstruct Party {\n    var name: String\n}\n\n// AppIntent\n\nimport AppIntents\n\nstruct StartPartyIntent: AppIntent {\n    static let title: LocalizedStringResource = \"Start the Party\"\n    \n    func perform() async throws -> some IntentResult {\n        return .result()\n    }\n}"
    },
    {
      "timestamp": "3:49",
      "title": "Function plotting",
      "language": "swift",
      "code": "import SwiftUI\nimport Charts\n\nstruct AttendanceView: View {\n    var body: some View {\n        Chart {\n          LinePlot(x: \"Parties\", y: \"Guests\") { x in\n            pow(x, 2)\n          }\n          .foregroundStyle(.purple)\n        }\n        .chartXScale(domain: 1...10)\n        .chartYScale(domain: 1...100)\n    }\n}\n\n#Preview {\n    AttendanceView()\n        .padding(40)\n}"
    },
    {
      "timestamp": "4:18",
      "title": "Dynamic table columns",
      "language": "swift",
      "code": "import SwiftUI\n\nstruct SongCountsTable: View {\n\n    var body: some View {\n        Table(Self.guestData) {\n            // A static column for the name\n            TableColumn(\"Name\", value: \\.name)\n            \n            TableColumnForEach(Self.partyData) { party in\n                TableColumn(party.name) { guest in\n                    Text(guest.songsSung[party.id] ?? 0, format: .number)\n                }\n            }\n        }\n    }\n    \n    private static func randSongsSung(low: Bool = false) -> [Int : Int] {\n        var songs: [Int : Int] = [:]\n        for party in partyData {\n            songs[party.id] = low ? Int.random(in: 0...3) : Int.random(in: 3...12)\n        }\n        return songs\n    }\n    \n    private static let guestData: [GuestData] = [\n        GuestData(name: \"Sommer\", songsSung: randSongsSung()),\n        GuestData(name: \"Sam\", songsSung: randSongsSung()),\n        GuestData(name: \"Max\", songsSung: randSongsSung()),\n        GuestData(name: \"Kyle\", songsSung: randSongsSung(low: true)),\n        GuestData(name: \"Matt\", songsSung: randSongsSung(low: true)),\n        GuestData(name: \"Apollo\", songsSung: randSongsSung()),\n        GuestData(name: \"Anna\", songsSung: randSongsSung()),\n        GuestData(name: \"Raj\", songsSung: randSongsSung()),\n        GuestData(name: \"John\", songsSung: randSongsSung(low: true)),\n        GuestData(name: \"Harry\", songsSung: randSongsSung()),\n        GuestData(name: \"Luca\", songsSung: randSongsSung()),\n        GuestData(name: \"Curt\", songsSung: randSongsSung()),\n        GuestData(name: \"Betsy\", songsSung: randSongsSung())\n    ]\n    \n    private static let partyData: [PartyData] = [\n        PartyData(partyNumber: 1, numberGuests: 5),\n        PartyData(partyNumber: 2, numberGuests: 6),\n        PartyData(partyNumber: 3, numberGuests: 7),\n        PartyData(partyNumber: 4, numberGuests: 9),\n        PartyData(partyNumber: 5, numberGuests: 9),\n        PartyData(partyNumber: 6, numberGuests: 10),\n        PartyData(partyNumber: 7, numberGuests: 11),\n        PartyData(partyNumber: 8, numberGuests: 12),\n        PartyData(partyNumber: 9, numberGuests: 11),\n        PartyData(partyNumber: 10, numberGuests: 13),\n    ]\n    \n}\n\nstruct GuestData: Identifiable {\n    let name: String\n    let songsSung: [Int : Int]\n    \n    let id = UUID()\n}\n\nstruct PartyData: Identifiable {\n    let partyNumber: Int\n    let numberGuests: Int\n    let symbolSize = 100\n    \n    var id: Int {\n        partyNumber\n    }\n    \n    var name: String {\n        \"\\(partyNumber)\"\n    }\n}\n\n#Preview {\n    SongCountsTable()\n        .padding(40)\n}"
    },
    {
      "timestamp": "4:42",
      "title": "Mesh gradients",
      "language": "swift",
      "code": "import SwiftUI\n\nstruct MyMesh: View {\n    var body: some View {\n        MeshGradient(\n            width: 3,\n            height: 3,\n            points: [\n                .init(0, 0), .init(0.5, 0), .init(1, 0),\n                .init(0, 0.5), .init(0.3, 0.5), .init(1, 0.5),\n                .init(0, 1), .init(0.5, 1), .init(1, 1)\n            ],\n            colors: [\n                .red, .purple, .indigo,\n                .orange, .cyan, .blue,\n                .yellow, .green, .mint\n            ]\n        )\n    }\n}\n\n#Preview {\n    MyMesh()\n        .statusBarHidden()\n}"
    },
    {
      "timestamp": "5:14",
      "title": "Document launch scene",
      "language": "swift",
      "code": "DocumentGroupLaunchScene(\"Your Lyrics\") {\n    NewDocumentButton()\n    Button(\"New Parody from Existing Song\") {\n        // Do something!\n    }\n} background: {\n    PinkPurpleGradient()\n} backgroundAccessoryView: { geometry in\n    MusicNotesAccessoryView(geometry: geometry)\n         .symbolEffect(.wiggle(.rotational.continuous()))\n} overlayAccessoryView: { geometry in\n    MicrophoneAccessoryView(geometry: geometry)\n}"
    },
    {
      "timestamp": "7:04",
      "title": "Window styling and default placement",
      "language": "swift",
      "code": "Window(\"Lyric Preview\", id: \"lyricPreview\") {\n    LyricPreview()\n}\n  .windowStyle(.plain)\n  .windowLevel(.floating)\n  .defaultWindowPlacement { content, context in\n      let displayBounds = context.defaultDisplay.visibleRect\n      let contentSize = content.sizeThatFits(.unspecified)\n      return topPreviewPlacement(size: contentSize, bounds: displayBounds)\n  }\n}"
    },
    {
      "timestamp": "7:30",
      "title": "Window Drag Gesture",
      "language": "swift",
      "code": "Text(currentLyric)\n    .background(.thinMaterial, in: .capsule)\n    .gesture(WindowDragGesture())"
    },
    {
      "timestamp": "8:18",
      "title": "Push window environment action",
      "language": "swift",
      "code": "struct EditorView: View {\n    @Environment(\\.pushWindow) private var pushWindow\n    \n    var body: some View {\n        Button(\"Play\", systemImage: \"play.fill\") {\n            pushWindow(id: \"lyric-preview\")\n        }\n    }\n}"
    },
    {
      "timestamp": "8:47",
      "title": "Hover effects",
      "language": "swift",
      "code": "struct ProfileButtonStyle: ButtonStyle {\n    func makeBody(configuration: Configuration) -> some View {\n        configuration.label\n            .background(.thinMaterial)\n            .hoverEffect(.highlight)\n            .clipShape(.capsule)\n            .hoverEffect { effect, isActive, _ in\n                effect.scaleEffect(isActive ? 1.05 : 1.0)\n            }\n    }\n}"
    },
    {
      "timestamp": "9:14",
      "title": "Modifier key alternates",
      "language": "swift",
      "code": "Button(\"Preview Lyrics in Window\") {\n    // show preview in window\n}\n.modifierKeyAlternate(.option) {\n    Button(\"Preview Lyrics in Full Screen\") {\n        // show preview in full screen\n    }\n}\n.keyboardShortcut(\"p\", modifiers: [.shift, .command])"
    },
    {
      "timestamp": "9:32",
      "title": "Responding to modifier keys",
      "language": "swift",
      "code": "var body: some View {\n        LyricLine()\n            .overlay(alignment: .top) {\n                if showBouncingBallAlignment {\n                    // Show bouncing ball alignment guide\n                }\n            }\n            .onModifierKeysChanged(mask: .option) {\n                showBouncingBallAlignment = !$1.isEmpty\n            }\n    }"
    },
    {
      "timestamp": "9:55",
      "title": "Pointer customization",
      "language": "swift",
      "code": "ForEach(resizeAnchors) { anchor in\n    ResizeHandle(anchor: anchor)\n         .pointerStyle(.frameResize(position: anchor.position))\n}"
    },
    {
      "timestamp": "10:23",
      "title": "Pencil squeeze gesture",
      "language": "swift",
      "code": "@Environment(\\.preferredPencilSqueezeAction) var preferredAction\n    \nvar body: some View {\n    LyricsEditorView()\n        .onPencilSqueeze { phase in\n            if preferredAction == .showContextualPalette, case let .ended(value) = phase {\n                if let anchorPoint = value.hoverPose?.anchor {\n                    lyricDoodlePaletteAnchor = .point(anchorPoint)\n                }\n                lyricDoodlePalettePresented = true\n            }\n       }"
    },
    {
      "timestamp": "13:13",
      "title": "Custom containers",
      "language": "swift",
      "code": "struct DisplayBoard<Content: View>: View {\n  @ViewBuilder var content: Content\n\n  var body: some View {\n    DisplayBoardCardLayout {\n      ForEach(subviewOf: content) { subview in\n        CardView {\n          subview\n        }\n      }\n    }\n    .background { BoardBackgroundView() }\n  }\n}\n\nDisplayBoard {\n  Text(\"Scrolling in the Deep\")\n  Text(\"Born to Build & Run\")\n  Text(\"Some Body Like View\")\n\n  ForEach(songsFromSam) { song in\n    Text(song.title)\n  }\n}"
    },
    {
      "timestamp": "13:35",
      "title": "Custom containers with sectioning",
      "language": "swift",
      "code": "DisplayBoard {\n  Section(\"Matt's Favorites\") {\n    Text(\"Scrolling in the Deep\")\n    Text(\"Born to Build & Run\")\n    Text(\"Some Body Like View\")\n      .displayBoardCardRejected(true)\n  }\n\tSection(\"Sam's Favorites\") {\n    ForEach(songsFromSam) { song in\n      Text(song.title)\n    }\n  }\n}"
    },
    {
      "timestamp": "13:52",
      "title": "Entry macro",
      "language": "swift",
      "code": "extension EnvironmentValues {\n  @Entry var karaokePartyColor: Color = .purple\n}\n\nextension FocusValues {\n  @Entry var lyricNote: String? = nil\n}\n\nextension Transaction {\n  @Entry var animatePartyIcons: Bool = false\n}\n\nextension ContainerValues {\n  @Entry var displayBoardCardStyle: DisplayBoardCardStyle = .bordered\n}"
    },
    {
      "timestamp": "14:12",
      "title": "Default accessibility label augmentation",
      "language": "swift",
      "code": "SongView(song)\n  .accessibilityElement(children: .combine)\n  .accessibilityLabel { label in\n    if let rating = song.rating {\n      Text(rating)\n    }\n    label\n  }"
    },
    {
      "timestamp": "14:52",
      "title": "Previewable",
      "language": "swift",
      "code": "#Preview {\n   @Previewable @State var showAllSongs = true\n   Toggle(\"Show All songs\", isOn: $showAllSongs)\n}"
    },
    {
      "timestamp": "15:06",
      "title": "Programatic text selection",
      "language": "swift",
      "code": "struct LyricView: View {\n  @State private var selection: TextSelection?\n  \n  var body: some View {\n    TextField(\"Line \\(line.number)\", text: $line.text, selection: $selection)\n    // ...\n  }\n}"
    },
    {
      "timestamp": "15:19",
      "title": "Getting selected ranges",
      "language": "swift",
      "code": "InspectorContent(text: line.text, ranges: selection?.ranges)"
    },
    {
      "timestamp": "15:29",
      "title": "Binding to search field focus state",
      "language": "swift",
      "code": "// Binding to search field focus state\n\nstruct SongSearchView: View {\n  @FocusState private var isSearchFieldFocused: Bool\n  \n  @State private var searchText = \"\"\n  @State private var isPresented = false\n\n  var body: some View {\n    NavigationSplitView {\n      Text(\"Power Ballads\")\n      Text(\"Show Tunes\")\n    } detail: {\n      // ...\n      if !isSearchFieldFocused {\n        Button(\"Find another song\") {\n          isSearchFieldFocused = true\n        }\n      }\n    }\n    .searchable(text: $searchText, isPresented: $isPresented)\n    .searchFocused($isSearchFieldFocused)\n  }\n}"
    },
    {
      "timestamp": "15:41",
      "title": "Text suggestions",
      "language": "swift",
      "code": "TextField(\"Line \\(line.number)\", text: $line.text)\n  .textInputSuggestions {\n    ForEach(lyricCompletions) {\n      Text($0.attributedCompletion)\n        .textInputCompletion($0.text)\n    }\n  }"
    },
    {
      "timestamp": "15:59",
      "title": "Color mixing",
      "language": "swift",
      "code": "Color.red.mix(with: .purple, by: 0.2)\nColor.red.mix(with: .purple, by: 0.5)\nColor.red.mix(with: .purple, by: 0.8)"
    },
    {
      "timestamp": "16:13",
      "title": "Custom shaders",
      "language": "swift",
      "code": "ContentView()\n  .task {\n    let slimShader = ShaderLibrary.slim()\n    try! await slimShader.compile(as: .layerEffect)\n  }"
    },
    {
      "timestamp": "16:23",
      "title": "React to scroll geometry changes",
      "language": "swift",
      "code": "struct ContentView: View {\n  @State private var showBackButton = false\n\n  ScrollView {\n    // ...\n  }\n  .onScrollGeometryChange(for: Bool.self) { geometry in\n    geometry.contentOffset.y < geometry.contentInsets.top\n  } action: { wasScrolledToTop, isScrolledToTop in\n    withAnimation {\n      showBackButton = !isScrolledToTop\n    }\n  }\n}"
    },
    {
      "timestamp": "16:42",
      "title": "React to scroll visibility changes",
      "language": "swift",
      "code": "struct AutoPlayingVideo: View {\n  @State private var player: AVPlayer = makePlayer()\n\n  var body: some View {\n    VideoPlayer(player: player)\n      .onScrollVisibilityChange(threshold: 0.2) { visible in\n        if visible {\n          player.play()\n        } else {\n          player.pause()\n        }\n      }\n  }\n}"
    },
    {
      "timestamp": "16:54",
      "title": "New scroll positions",
      "language": "swift",
      "code": "struct ContentView: View {\n  @State private var position: ScrollPosition =\n    .init(idType: Int.self)\n\n  var body: some View {\n    ScrollView {\n      // ... \n    }\n    .scrollPosition($position)\n    .overlay {\n      FloatingButton(\"Back to Invitation\") {\n        position.scrollTo(edge: .top)\n      }\n    }\n  }\n}"
    },
    {
      "timestamp": "18:17",
      "title": "Gesture interoperability",
      "language": "swift",
      "code": "struct VideoThumbnailScrubGesture: UIGestureRecognizerRepresentable {\n  @Binding var progress: Double\n\n  func makeUIGestureRecognizer(context: Context) -> VideoThumbnailScrubGestureRecognizer {\n    VideoThumbnailScrubGestureRecognizer()\n  }\n\n  func handleUIGestureRecognizerAction(\n    _ recognizer: VideoThumbnailScrubGestureRecognizer, context: Context\n  ) {\n    progress = recognizer.progress\n  }\n}\n\nstruct VideoThumbnailTile: View {\n  var body: some View {\n    VideoThumbnail()\n      .gesture(VideoThumbnailScrubGesture(progress: $progress))\n  }\n}"
    },
    {
      "timestamp": "18:34",
      "title": "SwiftUI animations in UIKit and AppKit",
      "language": "swift",
      "code": "let animation = SwiftUI.Animation.spring(duration: 0.8)\n\n// UIKit\nUIView.animate(animation) {\n    view.center = endOfBracelet\n}\n\n// AppKit\nNSAnimationContext.animate(animation) {\n    view.center = endOfBracelet\n}"
    },
    {
      "timestamp": "18:57",
      "title": "Representable animation bridging",
      "language": "swift",
      "code": "struct BeadBoxWrapper: UIViewRepresentable {\n  @Binding var isOpen: Bool\n\n  func updateUIView(_ box: BeadBox, context: Context) {\n\t\tcontext.animate {\n\t\t  box.lid.center.y = isOpen ? -100 : 100\n\t\t}\n  }\n}"
    },
    {
      "timestamp": "19:59",
      "title": "Volume baseplate visibility",
      "language": "swift",
      "code": "struct KaraokePracticeApp: App {\n  var body: some Scene {\n    WindowGroup {\n      ContentView()\n    }\n    .windowStyle(.volumetric)\n    .defaultWorldScaling(.trueScale)\n    .volumeBaseplateVisibility(.hidden)\n  }\n}"
    },
    {
      "timestamp": "20:15",
      "title": "React to volume viewpoint changes",
      "language": "swift",
      "code": "struct MicrophoneView: View {\n @State var micRotation: Rotation3D = .identity\n    \n  var body: some View {\n    Model3D(named: \"microphone\")\n      .onVolumeViewpointChange { _, new in\n        micRotation = rotateToFace(new)\n      }\n      .rotation3DEffect(micRotation)\n      .animation(.easeInOut, value: micRotation)\n  } \n}"
    },
    {
      "timestamp": "20:38",
      "title": "Control allowed immersion levels",
      "language": "swift",
      "code": "struct KaraokeApp: App {\n  @State private var immersion: ImmersionStyle = .progressive(\n    0.4...1.0, initialAmount: 0.5)\n  \n  var body: some Scene {\n    ImmersiveSpace(id: \"Karaoke\") {\n      LoungeView()\n    }\n    .immersionStyle(selection: $immersion, in: immersion)\n   }\n}"
    },
    {
      "timestamp": "21:00",
      "title": "Preferred surrounding effects",
      "language": "swift",
      "code": "struct LoungeView: View {\n  var body: some View {\n    StageView()\n      .preferredSurroundingsEffect(.colorMultiply(.purple))\n  }\n}"
    },
    {
      "timestamp": "21:33",
      "title": "Custom text renderers",
      "language": "swift",
      "code": "struct KaraokeRenderer: TextRenderer {\n  func draw(\n    layout: Text.Layout,\n    in context: inout GraphicsContext\n  ) {\n    for line in layout {\n      for run in line {\n        var glow = context\n\n        glow.addFilter(.blur(radius: 8))\n        glow.addFilter(purpleColorFilter)\n\n        glow.draw(run)\n        context.draw(run)\n      }\n    }\n  }\n}\n\nstruct LyricsView: View {\n  var body: some View {\n    Text(\"A Whole View World\")\n      .textRenderer(KaraokeRenderer())\n  }\n}\n\n#Preview {\n  LyricsView()\n}"
    }
  ],
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "Forum: UI Frameworks",
        "url": "https://developer.apple.com/forums/topics/ui-frameworks?cid=vf-a-0010"
      },
      {
        "title": "SwiftUI updates",
        "url": "https://developer.apple.com/documentation/Updates/SwiftUI"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2024/10144/4/8A69C683-3259-454B-9F94-5BBE98999A1B/downloads/wwdc2024-10144_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2024/10144/4/8A69C683-3259-454B-9F94-5BBE98999A1B/downloads/wwdc2024-10144_sd.mp4?dl=1"
  },
  "relatedVideos": [
    {
      "id": "10068",
      "year": "2024",
      "title": "Bring your Live Activity to Apple Watch",
      "url": "https://developer.apple.com/videos/play/wwdc2024/10068"
    },
    {
      "id": "10073",
      "year": "2024",
      "title": "Catch up on accessibility in SwiftUI",
      "url": "https://developer.apple.com/videos/play/wwdc2024/10073"
    },
    {
      "id": "10152",
      "year": "2024",
      "title": "Create custom hover effects in visionOS",
      "url": "https://developer.apple.com/videos/play/wwdc2024/10152"
    },
    {
      "id": "10151",
      "year": "2024",
      "title": "Create custom visual effects with SwiftUI",
      "url": "https://developer.apple.com/videos/play/wwdc2024/10151"
    },
    {
      "id": "10146",
      "year": "2024",
      "title": "Demystify SwiftUI containers",
      "url": "https://developer.apple.com/videos/play/wwdc2024/10146"
    },
    {
      "id": "10153",
      "year": "2024",
      "title": "Dive deep into volumes and immersive spaces",
      "url": "https://developer.apple.com/videos/play/wwdc2024/10153"
    },
    {
      "id": "10147",
      "year": "2024",
      "title": "Elevate your tab and sidebar experience in iPadOS",
      "url": "https://developer.apple.com/videos/play/wwdc2024/10147"
    },
    {
      "id": "10145",
      "year": "2024",
      "title": "Enhance your UI animations and transitions",
      "url": "https://developer.apple.com/videos/play/wwdc2024/10145"
    },
    {
      "id": "10132",
      "year": "2024",
      "title": "Evolve your document launch experience",
      "url": "https://developer.apple.com/videos/play/wwdc2024/10132"
    },
    {
      "id": "10157",
      "year": "2024",
      "title": "Extend your app’s controls across the system",
      "url": "https://developer.apple.com/videos/play/wwdc2024/10157"
    },
    {
      "id": "10169",
      "year": "2024",
      "title": "Migrate your app to Swift 6",
      "url": "https://developer.apple.com/videos/play/wwdc2024/10169"
    },
    {
      "id": "10214",
      "year": "2024",
      "title": "Squeeze the most out of Apple Pencil",
      "url": "https://developer.apple.com/videos/play/wwdc2024/10214"
    },
    {
      "id": "10155",
      "year": "2024",
      "title": "Swift Charts: Vectorized and function plots",
      "url": "https://developer.apple.com/videos/play/wwdc2024/10155"
    },
    {
      "id": "10148",
      "year": "2024",
      "title": "Tailor macOS windows with SwiftUI",
      "url": "https://developer.apple.com/videos/play/wwdc2024/10148"
    },
    {
      "id": "10188",
      "year": "2024",
      "title": "What’s new in SF Symbols 6",
      "url": "https://developer.apple.com/videos/play/wwdc2024/10188"
    },
    {
      "id": "10149",
      "year": "2024",
      "title": "Work with windows in SwiftUI",
      "url": "https://developer.apple.com/videos/play/wwdc2024/10149"
    }
  ],
  "extractedAt": "2025-07-18T10:20:42.396Z"
}