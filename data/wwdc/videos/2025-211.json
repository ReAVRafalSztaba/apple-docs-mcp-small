{
  "id": "211",
  "year": "2025",
  "url": "https://developer.apple.com/videos/play/wwdc2025/211/",
  "title": "Go further with Metal 4 games",
  "speakers": [],
  "duration": "",
  "topics": [
    "Graphics & Games"
  ],
  "hasTranscript": true,
  "hasCode": true,
  "transcript": {
    "fullText": "Hi, my name is Matias Koskela. Today I am going to introduce you to the techniques and best practices, that will help you go further with your advanced games and pro-apps on Apple platforms.\n\nBefore this talk you might want to watch “Discover Metal 4” for an overview of Metal 4, and “Explore Metal 4 games”, to learn how to use the latest iteration of Metal. This \"go further\" talk is the second part of our Metal 4 gaming series. You can also learn about how Metal 4 can help you combine machine learning and graphics in a separate track.\n\nGames, like CyberPunk 2077 shown here, are becoming more realistic with high quality rendering. This makes each pixel a more expensive task, making high resolutions and frame rates even more challenging. With Metal, you can render high quality frames across Apple platforms ranging from iPhones to Macs. If you're using techniques, such as rasterization or ray tracing, Metal provides you with easy to use APIs. You can scale your workloads for even higher resolutions, and frame rates, by using MetalFX Upscaling.\n\nAnd if you want to go even further, you can now use the new MetalFX frame interpolator.\n\nThe latest games, like Cyberpunk 2077, offer a very realistic, real time path tracing. These expanded capabilities in real time rendering can be achieved with the new awesome features in Metal 4. These include ray tracing enhancements, and the new MetalFX denoised upscaler, to easily scale, by reducing the required ray count in your game.\n\nThe MetalFX Upscaler can help you achieve higher resolution and faster frame rates. You can smooth out your gameplay even more with the new MetalFX frame interpolator. New Metal 4 ray tracing features can improve your performance even further, and you can combine them with the new MetalFX denoised upscaler.\n\nUpscaling is a widely used technique, that will help you boost your performance in most scenarios. MetalFX has a machine learning based upscaler, that has been a part of Apple platforms since 2022, and has gotten better every year.\n\nMetalFX Upscaling now includes new tools and techniques, which you can use to improve your game's quality and performance. The first step is to properly apply temporal upscaling to your game. One part of that process is getting the exposure input parameter right. You can then improve performance further with dynamic resolution and you can also improve the quality in certain scenarios using reactivity hints.\n\nImagine a typical rendering pipeline. First the frame is rasterized, or ray traced, before your game performs post processing effects such as motion blur. Next, it applies exposure and tone-mapping, then it renders UI, and finally it displays the frame to the player. The ideal place to add MetalFX upscaling is after jittered rendering, and before post effects. You can watch \"Boost performance with MetalFX Upscaling\" for more details on integrating the upscaler. This year, you have even more tools and features available to improve your game performance.\n\nSetting a correct exposure value on the upscaler is essential for a high quality outcome.\n\nIf you pass in a drastically wrong value it can lead to flickering and ghosting.\n\nIn the rendering pipeline, the input and output color of the upscaler are in linear color space. The upscaler takes in a parameter called exposure, which when multiplied with your color input, results in a brightness that should approximately match the exposure used, in your tone mapping. This ensures that the upscaler understands what visible features of the frame are, when they are displayed to the player. Note that the value is just a hint for the upscaler, and doesn't change the brightness of the output. MetalFX includes a new tool to help you tune the exposure input value, you send to the upscaler. It's called the exposure debugger. To enable it, set the environment variable MTLFX_EXPOSURE_TOOL_ENABLED Now the upscaler renders a grey checkerboard on top of your frame and applies the inverse of your exposure value to it.\n\nYou can then review how the pattern looks at the very end of your pipeline on the display.\n\nIf the exposure value you pass in to the upscaler is a mismatch with the tonemapper, the checkerboard will appear too dark, or too bright.\n\nAnother indicator of a mismatch is when the brightness of the checkerboard changes while your game is running.\n\nWhen your exposure value is correct the grid pattern is a constant mid gray.\n\nBecause game complexities can change a lot from scene to scene, many games have adopted Dynamic Resolution Rendering.\n\nWhen the frame is more complex, the upscaler input resolution is lowered. And when it is even more challenging, your game dynamically lowers the input resolution even further. The MetalFX temporal upscaler now supports dynamically sized inputs, instead of requiring you to pass in the same sized input every frame. To get the best scaling quality, your game should not set the maximum scale to higher than 2x scaling if it is not needed.\n\nAnother new feature in the MetalFX temporal upscaler is a new optional functionality to hint to the upscaler about pixels reactivity.\n\nWhen your game is rendering transparent effects, or particles like the fireworks, it does not render them into motion and depth textures.\n\nAt high scaling ratios and low input resolutions, you might find that such particles blend in a bit with the background or they might show ghosting. This happens because in rendering they can appear just like texture details or specular highlights. To give you control over how your particles are handled the upscaler now takes in a new optional input called the reactive mask. This mask allows you to mark areas covered by these effects.\n\nTo use it, set a reactive mask value in the shader, for example, based on the material type in the G buffer. On the host code, bind the texture to the temporal upscaler object before you encode it.\n\nOnly use the reactive mask if going to higher input resolutions is not an option. Also do not use a reactive mask that is tuned for another upscaler, because it could be masking areas that already look great in the MetalFX upscaler output. Using the Upscaler provides great performance with great quality. But sometimes you want to hit even higher refresh rates. This year MetalFX introduces frame interpolation to all Apple platforms. MetalFX frame interpolation is really easy to integrate into your game. You'll first set up an interpolator object, render UI into your interpolated frames, and correctly present and pace your frame.\n\nFrame interpolation can help you use pixels you’ve already rendered, to enable a smooth gaming experience.\n\nHere is the same rendering pipeline, this time without UI rendering.\n\nInterpolate your frames after your tone-mapping step. And note that for even higher resolutions and frame-rates you can have both upscaling and interpolation in the same pipeline.\n\nTo use the MetalFX frame interpolator your app provides two rendered frames, motion vectors and depth. If you have adopted the upscaler, the same motion vectors and depth can be used. The motion texture has color for objects because they have moved right. With these inputs, MetalFX generates a frame in between those two rendered frames.\n\nTo set up the interpolator, for higher combined performance, provide the upscale object to the interpolator descriptor. When you create the interpolator, define its motion scale and depth convention. Then bind all the required five textures to the interpolator.\n\nOnce you are starting to get some interpolated frames, it's time to think about UI rendering.\n\nIn the typical rendering pipeline, a game typically renders its UI at the end of each frame around the same location where the frame interpolation should happen.\n\nThe UI rendering alpha blends elements into to the frame, might contain every frame changing text and doesn't modify the motion or depth textures.\n\nYou have multiple ways to achieve great looking UI with frame interpolation enabled.\n\nThere are three most commonly used techniques for rendering UI with frame interpolation. There's Composited UI, Offscreen UI and Every-Frame UI.\n\nIn composited UI, the interpolator gets the previous frame N - 1, the current frame N without UI, and the same frame N with UI. The composited UI is easiest to adopt. In this mode the frame interpolator can see the delta between texture with UI and without UI. This way it can try to remove the UI, and put it in the right location in the interpolated frame. But unblending an already blended pixel cannot be done perfectly. Therefore, you can help the interpolator out by using one of the other options.\n\nLike the offscreen UI, where the UI is rendered into a completely separate UI texture. The interpolator then adds it on top of the interpolated frame. Inputting it to the interpolator saves you from one extra load and store. Since the interpolator can write the UI into its output.\n\nFinally in every-frame UI, the UI handling is left up to your code, which might require the biggest code changes on your side. But in this case you can also update the UI for the interpolated frame, resulting in the smoothest experience for the player.\n\nNow you have a nice looking UI on top of the interpolated frame too. And it is time to think about, how both the interpolated and natively rendered frames can be presented in the right order, and with the right intervals.\n\nTypically your game rendering consists of the Render thread, the GPU, and the Present thread. The render thread sets up the necessary work for the GPU and Presentation. When a frame is rendered, the interpolator can generate a frame with a timestamp in between the just rendered frame and the previous frame. And your game can then present the interpolated frame. After a present interval your game can display the most recently rendered frame.\n\nDetermining the length of this interval in a consistent way can be tricky. But it's needed to get the pacing of your game just right.\n\nThe new Metal HUD can be a great tool to help you identify when your pacing is off. Watch the \"Level up your games\" talk for more details on how to enable it, and learn more about all the new awesome features it has to offer.\n\nTake a look at the Frame Interval graph where horizontal axis is time and vertical axis is frame interval length.\n\nIf the graph shows an irregular pattern and the spikes indicating longer frame update intervals seem random, it indicates that your pacing is off.\n\nAnother way to know that your pacing is off, is that you have more than two frame interval histogram buckets.\n\nOnce your pacing is fixed, you should see a flat line if you are meeting your target display refresh rate, or regular repeating pattern if you are below it, with maximum of two histogram buckets.\n\nHere's an example of how it can be done correctly with a handy presentHelper class. During the draw loop, everything is rendered into low resolution texture, and upscaled by the MetalFX upscaler. UI is rendered after telling the helper that UI render starts. And finally, the interpolator call is handled by the presentHelper class. Check out the sample code for implementation details.\n\nIn addition to pacing, it's also important to get the delta time and camera parameters right. The occlusion area might have artifacts, if not all the parameters are correct. With the correct parameters the occlusion area aligns perfectly.\n\nThis is because the interpolator can now adjust the motion vectors, to match the length of the real simulation motion.\n\nAfter getting all the inputs and pacing right, the interpolated frames should look great. And, your interpolation input should have a decently high frame rate. Try to have at minimum 30 frames per second before interpolation.\n\nThe upscaler and frame interpolator are techniques you can universally use to scale almost any rendering style. In contrast, ray tracing is typically used in higher end rendering scenarios. Metal 4 adds a number of new ray tracing features around acceleration structure builds and intersection functions.\n\nMore and more games are using Metal ray tracing on Apple platforms.\n\nIn this demo, the lighting is realistic, and the drone is visible in the reflections on the floor. The ray tracing techniques and the complexities vary from game to game.\n\nThat requires more flexibility in intersection function management and more options for acceleration structure builds.\n\nMetal 4 introduces new features to help streamline both of these.\n\nTo learn the basics of Metal ray tracing, such as building acceleration structures and intersection functions, watch \"Your guide to Metal ray tracing\".\n\nConsider a game that ray traces a simple scene with grass around a tree.\n\nAlready in this simple scene, there are multiple material types such as alpha tested foliage and the opaque trunk of the tree. And as a result, many different ray tracing intersection functions are required. Separately for primary rays and shadow rays. An intersection function buffer is an argument buffer that contains handles to your scene’s intersection functions.\n\nFor example, the grass and the leaves might need similar functionality to trace primary rays. Intersection function buffers allow your game to easily have multiple entries pointing to the same intersection function.\n\nSetting up intersection function buffer indices requires, setting state on the instance level, where this example scene has two instances. And on the geometry level, where the grass has only one geometry and the tree has two. The intersector needs to know, which intersection function to use for shadow rays that hit the trunk.\n\nWhen you’re creating your instance acceleration structures, specify the intersectionFunctionTableOffset on each instance descriptor.\n\nWhen building your primitive acceleration structure, you also set the intersectionFunctionTableOffset on the geometry descriptors.\n\nWhen you set up the intersector in your shader, add “intersection_function_buffer” to its tags.\n\nNext, set the geometry multiplier on the intersector. The multiplier is the number of ray types in your intersection function buffer. Our example has two ray types for each geometry. Therefore the correct value here is two. And within those two ray types, you need to provide the base index for the ray type you are tracing. In this example the base index for tracing primary rays would be 0.\n\nAnd for tracing shadows, the base id is 1.\n\nWhen the instance and geometry contribution of the tree trunk, the geometry multiplier, and the base id of shadow ray type are combined, the pointer ends up in the desired intersection function.\n\nFinish your code off by passing the intersection function buffer arguments to the intersect method.\n\nBy specifying the buffer, its size, and stride. These give you some extra flexibility, compared to what you might be used to in other APIs. If you’re porting from DirectX, you can port your shader binding tables to Metal intersection function buffers easily.\n\nIn DirectX, you set the Intersection Function Buffer address and stride on the host, when creating the descriptor to dispatch the rays. In Metal, you set this in the shader. All the threads in the SIMD group should set the same value, or the behavior is undefined.\n\nRay type index and geometry multiplier are handled in the same way in DirectX and Metal. Your app can set them in your shader. In DirectX and Metal, you set the instance offset index per instance when creating your instance acceleration structure. But while the geometry offset index is generated automatically in DirectX, Metal gives you the flexibility to set this geometry offset yourself.\n\nIntersection function buffers greatly improve the Metal porting experience for your ray traced game. Once you’re up and running, Metal 4 also gives you the ability to optimize how Metal builds your acceleration structures. Metal already provides you a lot of control over acceleration structure builds. Besides the default behavior, you can optimize for refit, enable larger scenes, or build the acceleration structure more quickly. This year, you get even more flexibility and can prefer fast intersection to reduce the time it takes to trace rays.\n\nOr you can opt to minimize the memory usage of your acceleration structure as well.\n\nUsage flags can be set per acceleration structure build, and don't have to be the same for all acceleration structures.\n\nThe new acceleration structure flags make the ray tracing part of your rendering pipeline even more tailored for your needs. In case you use it for stochastic effects, you'll need a denoiser. And now, denoising can be part of your MetalFX upscaler.\n\nReal time ray tracing is used more all the time, both simpler hybrid ray tracing, and all the way to complex path tracing. In this example image, ray tracing makes everything more grounded, and improves the reflections significantly. The best quality and performance trade off in ray tracing can be achieved by using denoising with fewer rays.\n\nWith the new MetalFX API, combining upscaling and denoising can be as easy as adding a couple of extra inputs. But you can improve the quality further by helping the denoised upscaler more, by adding additional inputs, and by getting the details right.\n\nBefore you can combine your upscaler and denoiser let's take look how these steps are traditionally done.\n\nTypical real time and interactive ray traced rendering pipelines trace multiple effects separately, denoise them separately, and compose the result into one noise free jittered texture. Which is upscaled by MetalFX temporal upscaler. Followed by post processing.\n\nTraditional denoisers require separate artistic parameter tuning for each scene. Here you can see how some denoisers look without artist tuned parameters. In contrast, there is no need to tune parameters with MetalFX denoised upscaler. Which is applied after the main rendering, and just before post processing. Machine learning based techniques in MetalFX provide robust, high performance and high quality denoising and upscaling across many scenarios. And it is easier to integrate. Integrating the upscaler is a good starting point on the way to integrate the denoised upscaler. Here we can see the inputs to the upscaler. Color, motion and depth. The new combined API is a super set of the upscaler API.\n\nFor the new API, we need to add extra noise free auxiliary buffers, which are shown here on the left. Most of these are something your app might already have. Let's dive deeper into each one of them next.\n\nThe first new input is normals. For best results, these should be in world space.\n\nThen diffuse albedo, this is the base color of the diffuse radiance of the material.\n\nNext roughness, it represents how smooth or how rough the surface is, which is a linear value. And the last input is specular albedo. This should be a noise free approximation of the specular radiance of your rendering. It should include a fernel component. In code the addition of these new inputs is simple.\n\nCreation of a typical temporal upscaler only takes about 10 lines of code. To enable the denoised version, you need to change the scaler type and add the types of the additional textures.\n\nSimilarly when encoding the scaler this would be the upscaler call. And also here the only difference is that you need to bind the extra input textures.\n\nAfter setting up the basic usage of the denoiser, you can improve it by using some of the optional inputs. And by avoiding some typical integration pit falls.\n\nThere are some optional input textures, which can be used to improve the quality.\n\nFirst is specular hit distance, telling the ray length from the pixel primary visibility point to secondary bounce point. Then denoiser strength mask, which can be used to mark areas that don't need denoising. And finally transparency overlay, which is used based on the alpha channel to blend in color that is only upscaled and not denoised.\n\nThe most typical integration issue is input that is too noisy. To fix this, you should use all the standard path tracing sampling improvements, like next event estimation, importance sampling techniques, and in a bigger scene with many light sources, mostly sample the light sources that actually contribute to the area. Another thing related to ray tracing sample quality is correlated random numbers. You should not use random number generators that are too correlated. Both spatial and temporal correlation can cause artifacts.\n\nOne potential pit fall related to the auxiliary data is with metallic material's diffuse albedo. In this example, the chess pieces are metallic, and therefore have color in specular albedo. In that case, the diffuse albedo for the chess pieces should be darker.\n\nAnd finally, there are some common pitfalls related to the normals. MetalFX denoised upscaler expects normals to be in world space for better denoising decisions. You need to use a texture datatype that has a sign bit, otherwise the quality can be suboptimal, depending on the orientation of the camera.\n\nAfter getting all these details right, you should have nice denoised and upscaled frames.\n\nLet's take a look at what happens when you put all of these features into a single renderer.\n\nMy colleagues put together a demo, that uses the rendering pipeline I talked about earlier. The demo uses the new Metal 4 ray tracing features to optimize the ray tracing part of the rendering. It does denoising and upscaling at the same time with MetalFX denoised upscaler. And after exposure and tone mapping, the frames are interpolated by MetalFX frame interpolator.\n\nThis demo uses advanced ray tracing lighting effects such as global illumination, reflections, shadows, and ambient occlusions, to bring to life a scene showing two robots playing chess. In the right upper corner view you can see the rendering before any MetalFX processing. And other MetalFX input in other views.\n\nWe adopted both the MetalFX denoised upscaler and the frame interpolator. The denoiser also greatly simplified the rendering by eliminating all manual tuning of the final look.\n\nIf you have already integrated the MetalFX upscaler, this is your opportunity to upgrade to frame interpolation. If you're new to MetalFX, take a look at the upscaler first. Then make sure your ray tracing effects are using best practices like the intersection function buffers covered today. And reduce your game's ray budget with denoised upscaler.\n\nI cannot wait to see the new features in action in your games. And what you will create using Metal 4. Thanks for watching!",
    "segments": []
  },
  "codeExamples": [
    {
      "timestamp": "6:46",
      "title": "Reactive Mask",
      "language": "swift",
      "code": "// Create reactive mask setup in shader\nout.reactivity = m_material_id == eRain ? (m_material_id == eSpark ? 1.0f : 0.0f) : 0.8f;\n\n// Set reactive mask before encoding upscaler on host\ntemporalUpscaler.reactiveMask = reactiveMaskTexture;"
    },
    {
      "timestamp": "8:35",
      "title": "MetalFX Frame Interpolator",
      "language": "swift",
      "code": "// Create and configure the interpolator descriptor\nMTLFXFrameInterpolatorDescriptor* desc = [MTLFXFrameInterpolatorDescriptor new];\ndesc.scaler = temporalScaler;\n// ...\n\n// Create the effect and configure your effect\nid<MTLFXFrameInterpolator> interpolator = [desc newFrameInterpolatorWithDevice:device];\ninterpolator.motionVectorScaleX = mvecScaleX;\ninterpolator.motionVectorScaleY = mvecScaleY;\ninterpolator.depthReversed = YES;\n\n// Set input textures\ninterpolator.colorTexture = colorTexture;\ninterpolator.prevColorTexture = prevColorTexture;\ninterpolator.depthTexture = depthTexture;\ninterpolator.motionTexture = motionTexture;\ninterpolator.outputTexture = outputTexture;"
    },
    {
      "timestamp": "12:45",
      "title": "Interpolator present helper class",
      "language": "swift",
      "code": "#include <thread>\n#include <mutex>\n#include <sys/event.h>\n#include <mach/mach_time.h>\n\n\nclass PresentThread\n{\n    int m_timerQueue;\n    std::thread m_encodingThread, m_pacingThread;\n    std::mutex m_mutex;\n    std::condition_variable m_scheduleCV, m_threadCV, m_pacingCV;\n    float m_minDuration;\n    \n    uint32_t m_width, m_height;\n    MTLPixelFormat m_pixelFormat;\n    \n    const static uint32_t kNumBuffers = 3;\n    uint32_t m_bufferIndex, m_inputIndex;\n    bool m_renderingUI, m_presentsPending;\n    \n    CAMetalLayer *m_metalLayer;\n    id<MTLCommandQueue> m_presentQueue;\n\n    id<MTLEvent> m_event;\n    id<MTLSharedEvent> m_paceEvent, m_paceEvent2;\n    uint64_t m_eventValue;\n    uint32_t m_paceCount;\n    \n    int32_t m_numQueued, m_framesInFlight;\n    \n    id<MTLTexture> m_backBuffers[kNumBuffers];\n    id<MTLTexture> m_interpolationOutputs[kNumBuffers];\n    id<MTLTexture> m_interpolationInputs[2];\n    id<MTLRenderPipelineState> m_copyPipeline;\n    \n    std::function<void(id<MTLRenderCommandEncoder>)> m_uiCallback = nullptr;\n    \n    void PresentThreadFunction();\n    void PacingThreadFunction();\n    \n    void CopyTexture(id<MTLCommandBuffer> commandBuffer, id<MTLTexture> dest, id<MTLTexture> src, NSString *label);\n\npublic:\n    \n    PresentThread(float minDuration, CAMetalLayer *metalLayer);\n    ~PresentThread()\n    {\n        std::unique_lock<std::mutex> lock(m_mutex);\n        m_numQueued = -1;\n        m_threadCV.notify_one();\n        m_encodingThread.join();\n    }\n    void StartFrame(id<MTLCommandBuffer> commandBuffer)\n    {\n        [commandBuffer encodeWaitForEvent:m_event value:m_eventValue++];\n    }\n\n    void StartUI(id<MTLCommandBuffer> commandBuffer)\n    {\n        assert(m_uiCallback == nullptr);\n        if(!m_renderingUI)\n        {\n            CopyTexture(commandBuffer, m_interpolationInputs[m_inputIndex], m_backBuffers[m_bufferIndex], @\"Copy HUDLESS\");\n            m_renderingUI = true;\n        }\n    }\n    \n    void Present(id<MTLFXFrameInterpolator> frameInterpolator, id<MTLCommandQueue> queue);\n    \n    id<MTLTexture> GetBackBuffer()\n    {\n        return m_backBuffers[m_bufferIndex];\n    }\n\n    void Resize(uint32_t width, uint32_t height, MTLPixelFormat pixelFormat);\n    \n    void DrainPendingPresents()\n    {\n        std::unique_lock<std::mutex> lock(m_mutex);\n        while(m_presentsPending)\n            m_scheduleCV.wait(lock);\n    }\n    \n    bool UICallbackEnabled() const\n    {\n        return m_uiCallback != nullptr;\n    }\n    \n    void SetUICallback(std::function<void(id<MTLRenderCommandEncoder>)> callback)\n    {\n        m_uiCallback = callback;\n    }\n    \n};\n\nPresentThread::PresentThread(float minDuration, CAMetalLayer *metalLayer)\n    : m_encodingThread(&PresentThread::PresentThreadFunction, this)\n    , m_pacingThread(&PresentThread::PacingThreadFunction, this)\n    , m_minDuration(minDuration)\n    , m_numQueued(0)\n    , m_metalLayer(metalLayer)\n    , m_inputIndex(0u)\n    , m_bufferIndex(0u)\n    , m_renderingUI(false)\n    , m_presentsPending(false)\n    , m_framesInFlight(0)\n    , m_paceCount(0)\n    , m_eventValue(0)\n{\n    id<MTLDevice> device = metalLayer.device;\n    m_presentQueue = [device newCommandQueue];\n    m_presentQueue.label = @\"presentQ\";\n    m_timerQueue = kqueue();\n    \n    metalLayer.maximumDrawableCount = 3;\n    \n    Resize(metalLayer.drawableSize.width, metalLayer.drawableSize.height, metalLayer.pixelFormat);\n    \n    m_event = [device newEvent];\n    m_paceEvent = [device newSharedEvent];\n\tm_paceEvent2 = [device newSharedEvent];\n}\n\n\nvoid PresentThread::Present(id<MTLFXFrameInterpolator> frameInterpolator, id<MTLCommandQueue> queue)\n{\n    id<MTLCommandBuffer> commandBuffer = [queue commandBuffer];\n    \n    if(m_renderingUI)\n    {\n        frameInterpolator.colorTexture = m_interpolationInputs[m_inputIndex];\n        frameInterpolator.prevColorTexture = m_interpolationInputs[m_inputIndex^1];\n        frameInterpolator.uiTexture = m_backBuffers[m_bufferIndex];\n    }\n    else\n    {\n        frameInterpolator.colorTexture = m_backBuffers[m_bufferIndex];\n        frameInterpolator.prevColorTexture = m_backBuffers[(m_bufferIndex + kNumBuffers - 1) % kNumBuffers];\n        frameInterpolator.uiTexture = nullptr;\n    }\n    \n    frameInterpolator.outputTexture = m_interpolationOutputs[m_bufferIndex];\n\n    [frameInterpolator encodeToCommandBuffer:commandBuffer];\n    [commandBuffer addCompletedHandler:^(id<MTLCommandBuffer> _Nonnull) {\n        std::unique_lock<std::mutex> lock(m_mutex);\n        m_framesInFlight--;\n        m_scheduleCV.notify_one();\n        m_paceCount++;\n        m_pacingCV.notify_one();\n    }];\n    [commandBuffer encodeSignalEvent:m_event value:m_eventValue++];\n    [commandBuffer commit];\n\n    std::unique_lock<std::mutex> lock(m_mutex);\n    m_framesInFlight++;\n    m_numQueued++;\n    m_presentsPending = true;\n    m_threadCV.notify_one();\n    while((m_framesInFlight >= 2) || (m_numQueued >= 2))\n        m_scheduleCV.wait(lock);\n\n    m_bufferIndex = (m_bufferIndex + 1) % kNumBuffers;\n    m_inputIndex = m_inputIndex^1u;\n    m_renderingUI = false;\n}\n\nvoid PresentThread::CopyTexture(id<MTLCommandBuffer> commandBuffer, id<MTLTexture> dest, id<MTLTexture> src, NSString *label)\n{\n    MTLRenderPassDescriptor *desc = [MTLRenderPassDescriptor new];\n    desc.colorAttachments[0].texture = dest;\n    desc.colorAttachments[0].loadAction = MTLLoadActionDontCare;\n    desc.colorAttachments[0].storeAction = MTLStoreActionStore;\n    id<MTLRenderCommandEncoder> renderEncoder = [commandBuffer renderCommandEncoderWithDescriptor:desc];\n    [renderEncoder setFragmentTexture:src atIndex:0];\n    [renderEncoder setRenderPipelineState:m_copyPipeline];\n    [renderEncoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:3];\n    if(m_uiCallback)\n        m_uiCallback(renderEncoder);\n    renderEncoder.label = label;\n    [renderEncoder endEncoding];\n}\n\n\nvoid PresentThread::PacingThreadFunction()\n{\n    NSThread *thread = [NSThread currentThread];\n    [thread setName:@\"PacingThread\"];\n    [thread setQualityOfService:NSQualityOfServiceUserInteractive];\n    [thread setThreadPriority:1.f];\n    \n    mach_timebase_info_data_t info;\n    mach_timebase_info(&info);\n    \n    // maximum delta (0.1ms) in machtime units\n    const uint64_t maxDeltaInNanoSecs = 100000000;\n    const uint64_t maxDelta = maxDeltaInNanoSecs * info.denom / info.numer;\n    \n    uint64_t time = mach_absolute_time();\n    \n    uint64_t paceEventValue = 0;\n    \n    for(;;)\n    {\n        std::unique_lock<std::mutex> lock(m_mutex);\n        while(m_paceCount == 0)\n            m_pacingCV.wait(lock);\n        m_paceCount--;\n        lock.unlock();\n        \n        // we get signal...\n        const uint64_t prevTime = time;\n        time = mach_absolute_time();\n\t\tm_paceEvent.signaledValue = ++paceEventValue;\n\n        const uint64_t delta = std::min(time - prevTime, maxDelta);\n        const uint64_t timeStamp = time + ((delta*31)>>6);\n        \n        struct kevent64_s timerEvent, eventOut;\n        struct timespec timeout;\n        timeout.tv_nsec = maxDeltaInNanoSecs;\n        timeout.tv_sec = 0;\n        EV_SET64(&timerEvent,\n                 0,\n                 EVFILT_TIMER,\n                 EV_ADD | EV_ONESHOT | EV_ENABLE,\n                 NOTE_CRITICAL | NOTE_LEEWAY | NOTE_MACHTIME | NOTE_ABSOLUTE,\n                 timeStamp,\n                 0,\n                 0,\n                 0);\n        \n        kevent64(m_timerQueue, &timerEvent, 1, &eventOut, 1, 0, &timeout);\n        \n        // main screen turn on...\n        m_paceEvent2.signaledValue = ++paceEventValue;\n    }\n}\n\n\nvoid PresentThread::PresentThreadFunction()\n{\n    NSThread *thread = [NSThread currentThread];\n    [thread setName:@\"PresentThread\"];\n    [thread setQualityOfService:NSQualityOfServiceUserInteractive];\n    [thread setThreadPriority:1.f];\n    \n\n    uint64_t eventValue = 0;\n    uint32_t bufferIndex = 0;\n\n    uint64_t paceEventValue = 0;\n\n    for(;;)\n    {\n        std::unique_lock<std::mutex> lock(m_mutex);\n        \n        if(m_numQueued == 0)\n        {\n            m_presentsPending = false;\n            m_scheduleCV.notify_one();\n        }\n        \n        while(m_numQueued == 0)\n            m_threadCV.wait(lock);\n        \n        if(m_numQueued < 0)\n            break;\n        lock.unlock();\n\n        @autoreleasepool\n        {\n            id<CAMetalDrawable> drawable = [m_metalLayer nextDrawable];\n\n\t\t\tlock.lock();\n\t\t\tm_numQueued--;\n\t\t\tm_scheduleCV.notify_one();\n\t\t\tlock.unlock();\n\n            id<MTLCommandBuffer> commandBuffer = [m_presentQueue commandBuffer];\n            [commandBuffer encodeWaitForEvent:m_event value:++eventValue];\n            CopyTexture(commandBuffer, drawable.texture, m_interpolationOutputs[bufferIndex], @\"Copy Interpolated\");\n            [commandBuffer encodeSignalEvent:m_event value:++eventValue];\n\t\t\t[commandBuffer encodeWaitForEvent:m_paceEvent value:++paceEventValue];\n\n            if(m_minDuration > 0.f)\n                [commandBuffer presentDrawable:drawable afterMinimumDuration:m_minDuration];\n            else\n                [commandBuffer presentDrawable:drawable];\n            [commandBuffer commit];\n        }\n        \n        @autoreleasepool\n        {\n            id<MTLCommandBuffer> commandBuffer = [m_presentQueue commandBuffer];\n            id<CAMetalDrawable> drawable = [m_metalLayer nextDrawable];\n            CopyTexture(commandBuffer, drawable.texture, m_backBuffers[bufferIndex], @\"Copy Rendered\");\n\t\t\t[commandBuffer encodeWaitForEvent:m_paceEvent2 value:++paceEventValue];\n            if(m_minDuration > 0.f)\n                [commandBuffer presentDrawable:drawable afterMinimumDuration:m_minDuration];\n            else\n                [commandBuffer presentDrawable:drawable];\n            [commandBuffer commit];\n        }\n        \n        bufferIndex = (bufferIndex + 1) % kNumBuffers;\n    }\n}\n\nvoid PresentThread::Resize(uint32_t width, uint32_t height, MTLPixelFormat pixelFormat)\n{\n    if((m_width != width) || (m_height != height) || (m_pixelFormat != pixelFormat))\n    {\n        id<MTLDevice> device = m_metalLayer.device;\n\n        if(m_pixelFormat != pixelFormat)\n        {\n            id<MTLLibrary> lib = [device newDefaultLibrary];\n            MTLRenderPipelineDescriptor *pipelineDesc = [MTLRenderPipelineDescriptor new];\n            pipelineDesc.vertexFunction = [lib newFunctionWithName:@\"FSQ_VS_V4T2\"];\n            pipelineDesc.fragmentFunction = [lib newFunctionWithName:@\"FSQ_simpleCopy\"];\n            pipelineDesc.colorAttachments[0].pixelFormat = pixelFormat;\n            m_copyPipeline = [device newRenderPipelineStateWithDescriptor:pipelineDesc error:nil];\n            m_pixelFormat = pixelFormat;\n        }\n        \n        DrainPendingPresents();\n        \n        m_width = width;\n\t\tm_height = height;\n        \n        MTLTextureDescriptor *texDesc = [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:pixelFormat width:width height:height mipmapped:NO];\n\t\ttexDesc.storageMode = MTLStorageModePrivate;\n        for(uint32_t i = 0; i < kNumBuffers; i++)\n        {\n            texDesc.usage = MTLTextureUsageShaderRead|MTLTextureUsageShaderWrite|MTLTextureUsageRenderTarget;\n            m_backBuffers[i] = [device newTextureWithDescriptor:texDesc];\n            texDesc.usage = MTLTextureUsageShaderRead|MTLTextureUsageRenderTarget;\n            m_interpolationOutputs[i] = [device newTextureWithDescriptor:texDesc];\n        }\n        texDesc.usage = MTLTextureUsageShaderRead|MTLTextureUsageRenderTarget;\n        m_interpolationInputs[0] = [device newTextureWithDescriptor:texDesc];\n        m_interpolationInputs[1] = [device newTextureWithDescriptor:texDesc];\n\n    }\n}"
    },
    {
      "timestamp": "13:00",
      "title": "Set intersection function table offset",
      "language": "swift",
      "code": "// Set intersection function table offset on host-side geometry descriptors\nNSMutableArray<MTLAccelerationStructureGeometryDescriptor *> *geomDescs ...;\nfor (auto g = 0; g < geomList.size(); ++g)\n{\n    MTLAccelerationStructureGeometryDescriptor *descriptor = ...;\n    descriptor.intersectionFunctionTableOffset = g;\n    ...\n    [geomDescs addObject:descriptor];\n}"
    },
    {
      "timestamp": "13:01",
      "title": "Set up the intersector",
      "language": "swift",
      "code": "// Set up the intersector\nmetal::raytracing::intersector<intersection_function_buffer, instancing, triangle> trace;\ntrace.set_geometry_multiplier(2); // Number of ray types, defaults to 1\ntrace.set_base_id(1);             // Set ray type index, defaults to 0"
    },
    {
      "timestamp": "13:02",
      "title": "Ray trace intersection function buffers",
      "language": "swift",
      "code": "// Ray trace intersection function buffers\n\n// Set up intersection function buffer arguments\nintersection_function_buffer_arguments ifb_arguments;\nifb_arguments.intersection_function_buffer = raytracingResources.ifbBuffer;\nifb_arguments.intersection_function_buffer_size = raytracingResources.ifbBufferSize;\nifb_arguments.intersection_function_stride = raytracingResources.ifbBufferStride;\n\n// Set up the ray and finish intersecting\nmetal::raytracing::ray r = { origin, direction };\nauto result = trace.intersect(r, ads, ifb_arguments);"
    },
    {
      "timestamp": "13:02",
      "title": "Change of temporal scaler setup to denoised temporal scaler setup",
      "language": "swift",
      "code": "// Change of temporal scaler setup to denoised temporal scaler setup\n\nMTLFXTemporalScalerDescriptor* desc = [MTLFXTemporalScalerDescriptor new];\ndesc.colorTextureFormat = MTLPixelFormatBGRA8Unorm_sRGB;\ndesc.outputTextureFormat = MTLPixelFormatBGRA8Unorm_sRGB;\ndesc.depthTextureFormat = DepthStencilFormat;\ndesc.motionTextureFormat = MotionVectorFormat;\n\ndesc.diffuseAlbedoTextureFormat = DiffuseAlbedoFormat;\ndesc.specularAlbedoTextureFormat = SpecularAlbedoFormat;\ndesc.normalTextureFormat = NormalVectorFormat;\ndesc.roughnessTextureFormat = RoughnessFormat;\n\ndesc.inputWidth = _mainViewWidth;\ndesc.inputHeight = _mainViewHeight;\ndesc.outputWidth = _screenWidth;\ndesc.outputHeight = _screenHeight;\ntemporalScaler = [desc newTemporalDenoisedScalerWithDevice:_device];"
    },
    {
      "timestamp": "13:04",
      "title": "Change temporal scaler encode to denoiser temporal scaler encode",
      "language": "swift",
      "code": "// Change temporal scaler encode to denoiser temporal scaler encode\n\ntemporalScaler.colorTexture = _mainView;\ntemporalScaler.motionTexture = _motionTexture;\n\ntemporalScaler.diffuseAlbedoTexture = _diffuseAlbedoTexture;\ntemporalScaler.specularAlbedoTexture = _specularAlbedoTexture;\ntemporalScaler.normalTexture = _normalTexture;\ntemporalScaler.roughnessTexture = _roughnessTexture;\n\ntemporalScaler.depthTexture = _depthTexture;\ntemporalScaler.jitterOffsetX = _pixelJitter.x;\ntemporalScaler.jitterOffsetY = -_pixelJitter.y;\ntemporalScaler.outputTexture = _upscaledColorTarget;\ntemporalScaler.motionVectorScaleX = (float)_motionTexture.width;\ntemporalScaler.motionVectorScaleY = (float)_motionTexture.height;\n[temporalScaler encodeToCommandBuffer:commandBuffer];"
    },
    {
      "timestamp": "16:04",
      "title": "Creating instance descriptors for instance acceleration structure",
      "language": "swift",
      "code": "// Creating instance descriptors for instance acceleration structure\nMTLAccelerationStructureInstanceDescriptor *grassInstanceDesc, *treeInstanceDesc = . . .;\ngrassInstanceDesc.intersectionFunctionTableOffset = 0;\ntreeInstanceDesc.intersectionFunctionTableOffset  = 1;\n\n// Create buffer for instance descriptors of as many trees/grass instances the scene holds\nid <MTLBuffer> instanceDescs = . . .;\nfor (auto i = 0; i < scene.instances.size(); ++i)\n. . ."
    }
  ],
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2025/211/4/03920d98-a8a0-4cc8-bc99-3fcf874e0232/downloads/wwdc2025-211_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2025/211/4/03920d98-a8a0-4cc8-bc99-3fcf874e0232/downloads/wwdc2025-211_sd.mp4?dl=1"
  },
  "relatedVideos": [
    {
      "id": "262",
      "year": "2025",
      "title": "Combine Metal 4 machine learning and graphics",
      "url": "https://developer.apple.com/videos/play/wwdc2025/262"
    },
    {
      "id": "205",
      "year": "2025",
      "title": "Discover Metal 4",
      "url": "https://developer.apple.com/videos/play/wwdc2025/205"
    },
    {
      "id": "254",
      "year": "2025",
      "title": "Explore Metal 4 games",
      "url": "https://developer.apple.com/videos/play/wwdc2025/254"
    },
    {
      "id": "209",
      "year": "2025",
      "title": "Level up your games",
      "url": "https://developer.apple.com/videos/play/wwdc2025/209"
    },
    {
      "id": "294",
      "year": "2025",
      "title": "What’s new in Metal rendering for immersive apps",
      "url": "https://developer.apple.com/videos/play/wwdc2025/294"
    },
    {
      "id": "10128",
      "year": "2023",
      "title": "Your guide to Metal ray tracing",
      "url": "https://developer.apple.com/videos/play/wwdc2023/10128"
    },
    {
      "id": "10103",
      "year": "2022",
      "title": "Boost performance with MetalFX Upscaling",
      "url": "https://developer.apple.com/videos/play/wwdc2022/10103"
    }
  ],
  "extractedAt": "2025-07-18T10:28:37.846Z"
}