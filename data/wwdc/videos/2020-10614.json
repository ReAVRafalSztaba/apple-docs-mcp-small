{
  "id": "10614",
  "year": "2020",
  "url": "https://developer.apple.com/videos/play/wwdc2020/10614/",
  "title": "Advancements in Game Controllers",
  "speakers": [],
  "duration": "",
  "topics": [
    "Graphics & Games"
  ],
  "hasTranscript": true,
  "hasCode": true,
  "transcript": {
    "fullText": "â™ª Hello and welcome to WDDC.\n\nJames Kelly: Hello. My name is James Kelly, and I'm a member of the Game Technologies Engineering team at Apple.\n\nIn this video, we'll be talking about new game controller features and changes coming to our platforms this year, and we'll give some advice on how you can best adopt these new changes.\n\nAs a reminder, the game controller framework has a goal to make it easy to add support for MFI select third-party game controllers to your games on iOS, tvOS and MacOS.\n\nBy abstracting controller hardware through a common API, the game controller framework lets you write your code once without you having to worry about how that controller data is mapped.\n\nThis year we're making sure you can take advantage of, and customize, the great features of game controllers like haptics and rumble, motion, lights, as well as unique inputs like touchpads and paddles.\n\nWe'll also show how users can remap their controllers globally or tune it to their game to get just the configuration they want.\n\nBefore we start, we're excited to announce some additions to our supported lineup of great controllers.\n\nFirst up, we've added support for the Xbox Elite Wireless Controller Series 2.\n\nIt's got a really great feel and it's been highly requested by our users.\n\nWe're also really excited to announce support for the Xbox Adaptive Controller.\n\nThis unique extensible controller helps to make gaming more accessible for all.\n\nSo developers are creating some great games with controller support.\n\nOceanhorn 2, Sonic Racing, Spyder, and Lego Brawls are some excellent examples on Apple Arcade and just a few of the games on the App Store that support controllers.\n\nBy using the game controller framework, these games automatically support newly-added controllers like the Xbox Adaptive Controller or the Xbox Elite Wireless Controller Series 2.\n\nSo now let's talk about changes coming to the game controller framework this year in support of these new controllers.\n\nSo let's start by talking about how you can access the buttons of these new controllers.\n\nThere's a new way to access controller input this year.\n\nGC PhysicalInputProfile, which represents the collection of all physical inputs available on a controller -- meaning its buttons, triggers, Dpads, thumbsticks, and so on.\n\nWe're calling this the new Extensible Input API as it allows your game to dynamically query and support all of the controller's inputs at runtime -- even non-standard inputs like the DualShock 4's touchpad or the Xbox Elite Controller's paddle buttons.\n\nEvery controller now has a physical input profile.\n\nAnd so GC ExtendedGamepad and GC MicroGamepad have both been made subclasses of this GC PhysicalInputProfile.\n\nYou're encouraged to still check for the presence of profiles like GC ExtendedGamepad to filter out controllers that don't have the buttons you need.\n\nYou can then use the PhysicalInputProfile to access the controller's unique buttons like the DualShock 4's touchpad.\n\nSo let's take a look at a code example to get a sense of these changes.\n\nLet's say we want to add some special shortcuts for controllers with extra buttons.\n\nFirst, we'll add an action that can instantly trigger an attack combo which would normally require a combination of button presses.\n\nWe'll also track the buttons on the controller that we have and have not mapped to actions.\n\nNow let's look at setupConnectedController that is called when a controller connects.\n\nWe grab a reference to the physical input profile on the controller.\n\nRemember that every controller will have this profile.\n\nWe have a helper function, setupBasicControls, that will set up all the standard controls for the face buttons, the left and right thumbsticks, the Dpad, et cetera, and it will also update mapped buttons.\n\nUsing that physical input profile, we can then easily grab a reference to a panel button, if one exists, and update our mapped button set.\n\nFinally, we can look at all of the buttons available on the physical input profile and filter out any buttons that have already been mapped.\n\nWe can use this to populate an in-game mapping UI with a list of unused buttons.\n\nSo for ease of use, we've added two new subclasses to GC ExtendedGamepad: GC DualShockGamepad and GC XboxGamepad.\n\nThe DualShockGamepad exposes the touchpad surface with two-finger tracking as well as the touchpad's button.\n\nThe XboxGamepad exposes the four paddle buttons of the Xbox Elite Wireless Controller.\n\nUse extra buttons to augment your games with additional convenience controls, but avoid requiring these buttons as other controllers don't have them.\n\nSo one quick note about the paddle buttons on the Xbox Elite Wireless Controller Series 2.\n\nThe controller supports hardware button remapping, which can be configured and then stored in one of three profiles.\n\nThe selected profile is indicated by the three LEDs on the front of the controller.\n\nAnd due to how the controller sends data, the paddle buttons will only work when the controller does not have a button mapping profile selected, meaning that the three LEDs are unlit.\n\nSo up next, let's talk about haptics and rumble, one of the most exciting additions to the API this year.\n\nGames coordinate visuals, sounds, and haptics from the controller to more deeply immerse the player.\n\nSo great haptics can help give a sense that your car is driving over gravel, that your character is walking through sand, that you feel the recoil in your trigger finger, or even that a nearby explosion is shaking your room.\n\nMany of our supported controllers can provide haptic feedback, including the DualShock 4, the Xbox Wireless Controller, and the Xbox Elite Wireless Controller.\n\nAnd that feedback is programmable, meaning that you have fine-grained control over the low-level haptic feeling that is played.\n\nThese controllers all use different hardware for generating haptics.\n\nSo let's talk a little bit about how you can easily add haptic feedback to your game without having to worry about the physical details of each controller.\n\nSo this year we're happy to add game controller support to Core Haptics, on top of the existing phone haptic support.\n\nCore Haptics is a powerful API that allows you to compose and play haptic patterns to customize your app's haptic feedback.\n\nIn Core Haptics, you can craft custom haptic patterns from basic building blocks called haptic events.\n\nThese patterns can be created programmatically or stored in Apple haptic and audio pattern, or AHAP, files.\n\nAfter designing your haptic patterns, you simply create pattern players from a haptic engine to play your haptic content.\n\nCore Haptics and AHAP allows you to design your haptic content once and then play it everywhere, be it a phone, a DualShock 4, or any one of our other supported devices.\n\nFor more information on the details of the Core Haptics framework, including some excellent examples on how to design AHAP content, please watch Introducing Core Haptics from WWDC 2019.\n\nLet's look at a simple practical example.\n\nHaptic feedback is a great way to immerse players in a game and let them really feel the impact of their gameplay.\n\nSo let's say we have a player and an enemy in an action game.\n\nWhen the enemy attacks the player, they're dealt damage and the controller rumbles.\n\nSo how do we achieve this in our game using the game controller and Core Haptics frameworks? Well first, we need to design our haptic content.\n\nHere we've programmatically created a haptic pattern called enemy strike that will play when an enemy attacks.\n\nWe can then feed this data into a CHHapticPattern.\n\nOnce we have our haptic content designed and loaded into a pattern, we can get ready to play it.\n\nBut how do we play it on a controller? Well first we need a GCController instance.\n\nHere representing the Xbox Elite Controller shown on the right.\n\nNext, we can create a CHHapticEngine that targets the locations on a controller that we'd like to play haptics on.\n\nA haptic engine is just an object that manages your app's requests to play haptic patterns.\n\nFinally, we can create a CHHapticPatternPlayer from our engine and our pattern.\n\nOnce we call start on this pattern player, our AHAP content will play on our controller.\n\nIn this case, just the handles.\n\nYou can even layer these pattern players.\n\nThe system will automatically combine the haptics from all active patterns for you at runtime, allowing you to create some really dynamic effects.\n\nSo how do you create a haptic engine? Simply call createEngineWithLocality on a controller instance and pass in a GC haptic locality.\n\nThis locality defines the physical locations on the controller that the haptic engine will target.\n\nThe default haptic locality is geared towards providing a haptic experience that your users would expect.\n\nFor example, on game controllers, the default locality typically targets the handles.\n\nYou can get more specific if you'd like.\n\nHere we're targeting just the left impulse trigger.\n\nSo how do we put all this together? Let's look at a code example.\n\nWe begin by creating an instance of a CH haptic engine.\n\nOne that targets the handles of the active controller.\n\nThe engine is assigned to our member variable so we can keep it around.\n\nAfter creating the haptic engine, we'll need to start it and check for possible errors.\n\nThe engine will continue to run until the application or possible outside action stops it.\n\nSo let's play some haptics.\n\nHere's the function that executes when the player is dealt damage by the enemy.\n\nIn this example, you want to generate a haptic pattern that scales with the amount of damage that was dealt.\n\nSo we have to create the pattern player and its pattern at the moment they're needed to account for this damage.\n\nOnce the pattern player is created, we start it at time CHHapticTimeImmediate, which indicates that we want to play it with minimal latency.\n\nIf you had two separate haptic players that you wanted to synchronize, you would need to specify an actual time here.\n\nNotice that the app does not hold onto the instance of the player.\n\nIt's pattern is guaranteed to continue playing until it's finished, so we can simply fire and forget it.\n\nLet's look at creating a pattern player.\n\nThis method is responsible for creating the custom haptic content that will play when we take damage.\n\nWe'll create a continuous haptic event that applies over a specified duration.\n\nWe'll give it a sharpness and intensity.\n\nThis will provide a nice baseline of haptic feedback, regardless of how much damage was done to the player.\n\nNext we create a transient haptic event.\n\nThese are brief impulses that occur at a specific point in time such as the click you would feel from toggling a switch.\n\nNote that the transient events don't have a specified duration.\n\nThey're just the shortest haptic event that you can produce, so the actual time a transient takes will vary from controller to controller.\n\nAgain, we set the sharpness and intensity.\n\nThis time we scale the intensity by the amount of damage that was dealt to the player.\n\nNext, we create the pattern containing these two events.\n\nFinally, we create the pattern player from this pattern and return it.\n\nOK. So now that you saw how easy it was to generate haptic content in Core Haptics, let's talk about how you can transition your existing rumble code from other platforms.\n\nIn many existing games, haptics are tied directly to the update loop.\n\nThis typically means that every update, the engine will set the intensity of each physical actuator on a game controller directly.\n\nWith this approach, the engine combines different haptic effects each frame.\n\nLet's talk about how you can migrate a game that uses this architecture to Core Haptics.\n\nOur goal is to update the intensities of the controller's motors each frame.\n\nTo achieve this, we'll need to create a pattern player so we can send changes to it and then we'll create a long-running pattern with an initial haptic intensity set to one.\n\nIn our update loop, we'll just change the intensity of the motors.\n\nTo do this, we create a dynamic parameter with the haptic intensity we calculate for a given motor and then we send it to the pattern player.\n\nWe can do this each frame, and as long as our updates are fast enough, the user will feel a continuous change in haptic intensity.\n\nLet's take a quick look at how we can achieve this in code.\n\nHere we're setting up all the pieces you need to be able to update your controller's motors in your update loop.\n\nWe're setting up our pattern player, which will later send new intensities to each update.\n\nIn this function, we'll create a long-running, continuous haptic event with a haptic intensity set to the max value of one.\n\nWe'll use the continuous event to create a haptic pattern.\n\nAnd finally, we'll create our pattern player and start it immediately.\n\nYou'll need to hold onto this, as you'll be using it later.\n\nNow in our update loop, we're also going to update our haptics.\n\nThis is where we update the intensity of our motors.\n\nWe create a dynamic parameter targeting haptic intensity.\n\nThese are similar to the parameters used to generate events, except these could be applied dynamically to an already-running pattern, and they apply to the entire pattern, not just a single event.\n\nHere, haptic engine motor intensity represents the intensity of the motor from 0 to 1 as calculated by the engine for this frame.\n\nThis will act as a multiplier on the pattern player's intensity.\n\nWe finish up by sending our dynamic intensity parameter to our pattern player.\n\nPlease note that this example only covers one CH haptic engine.\n\nYou will need to repeat this approach for each motor if you would like to control them independently from one another.\n\nNext up, let's talk about some other features that we've added to the Game Controller framework this year that'll help you to fully utilize the extended capabilities of newly-supported controllers.\n\nLet's start by looking at a situation that single-player games frequently need to handle.\n\nYour game launches, and you see multiple controllers connected.\n\nParticularly with the Apple TV, it's common to see the Siri Remote and a game controller -- but which one should you take input from? How do you know which controller is currently being used by the player? You could register your controller connection and disconnection handlers and manage the lifecycles of the controllers, but you still need to track when a controller becomes active to update the UI and controls as the user switches between input devices.\n\nThis is why we're introducing some new API to handle this for you.\n\nWe've added the current property to GCController which always returns the most recently-used controller or nil if no controller is connected.\n\nWe've also added two new notifications that you can observe to properly respond to the current controller changing.\n\nGCControllerDidBecomeCurrent and GCControllerDidStopBeingCurrent.\n\nSingle-player games should adapt to the currently active game controller by using this property.\n\nBy listening to the notifications, you can easily adapt your UI to reflect the currently used controller.\n\nNext, let's talk about the motion sensors on the DualShock 4.\n\nThe DualShock 4 has a gyroscope, meaning that it knows its rotation rate in 3D space allowing for some great gameplay possibilities.\n\nOne common technique is to use the gyroscope for fine-tuned camera aiming with the thumbsticks used for more coarse aiming.\n\nThe DualShock 4 also has an accelerometer.\n\nThere are many ways to use accelerometer.\n\nFor example, you can detect whether the controller is tilted to the left or the right for driving controls in a racing game or you can interpret high, rapid shifts in acceleration as a shake gesture to make your player character attack.\n\nWe've introduced support for the DualShock 4's motion sensors via GCMotion, a property on GCController.\n\nFor those of you familiar with supporting the Siri Remote on tvOS, we're using the same API here but with a few tweaks.\n\nWhen supporting the DualShock 4, you need to manually turn the motion sensors on and off to preserve battery.\n\nYou can query whether you need to manage the sensors yourself or leave it up to the system like with the Siri Remote.\n\nSet motion.sensorsActive to toggle motion sensors on and off.\n\nAdditionally, some controllers like the DualShock 4 do not separate gravity from user acceleration and only report that total acceleration of the controller.\n\nQuery whether the connected controller has the ability to separate gravity from user acceleration, and if it doesn't, use the total acceleration instead.\n\nThe next feature I want to tell you about is the DualShock 4's lightbar.\n\nIt's usually used as a player indicator but you can also use it for game effects.\n\nFor example, it could flash a different color when the player walks into lava or shine green, then yellow, then red as the player loses health.\n\nWe've surfaced support for the DualShock 4's lightbar via GCDeviceLight, a property on GCController.\n\nIt's easy to change the color of a DualShock 4 lightbar.\n\nJust set the GCDeviceLight color value.\n\nHere, we're setting the color to red.\n\nNowadays, many controllers are wireless and may need charging.\n\nWe're making battery state available to you so that you can show it in your UI, particularly in low battery situations.\n\nThis is provided via GCDeviceBattery, a property on GCController.\n\nYou can check the level of the battery as well as its charging state, whether it's charging, discharging, or fully charged.\n\nYou can then use key value observing (or KVO) to monitor any changes to the battery.\n\nNow I'd like to introduce my colleague Hannah Gillis, who will give some tips on how to best take advantage of our new input remapping feature.\n\nHannah Gillis: Thanks, James.\n\nLet's talk about how you can indicate that your app supports game controllers and the benefits that come along when you do so.\n\nThere are a few reasons to indicate controller support.\n\nFirst, it surfaces information on the App Store and on Apple TV to communicate to users when a controller is required for an application.\n\nA game controller badge will be listed on the app's product page to visually declare this info.\n\nSecond, indicating controller support provides the ability for input remapping in your application, which I'll discuss shortly.\n\nFor these reasons, we highly recommend you update your apps for the best user experience.\n\nTo indicate controller support, you should enable the game controllers capability in Xcode.\n\nThis informs the system that your app uses game controller features.\n\nOnce enabled, you can take advantage of many associated benefits.\n\nAs mentioned, one of these benefits is game controller input remapping.\n\nAnd I'm excited tell you about this feature in both iOS and tvOS.\n\nHave you ever played a game and wished the buttons were configured differently? For example, maybe you're in an open world.\n\nYou have a controller in your hand and want your character to look up.\n\nWhat direction do you push the joystick? Well, depending on your preference, you might actually want to invert the Y-axis if it better matches your intuition.\n\nThis is called input remapping and it's incredibly powerful for allowing users to customize their gaming experience.\n\nAdditionally, it empowers our accessibility community to enjoy gaming the way they want.\n\nIn iOS 14 and tvOS 14, we have created a method to support input remapping, even if it's not built directly into your app.\n\nThere are two ways you can take advantage of input remapping.\n\nThe first is globally, meaning any button customizations will apply to all game controller apps on your device.\n\nThe second is per application.\n\nIt allows you to specify different remapping for an individual app.\n\nBoth of these options are available if you've indicated game controller support in Xcode.\n\nLet's take a look at how a user will experience input remapping.\n\nIn iOS 14, start by connecting one of our supported game controllers via Bluetooth.\n\nGo to Settings and tap General, where you will now see game controller.\n\nTap Game Controller to see your currently connected device, then tap Customizations to choose the button you want to customize.\n\nI want to remap the R1 button so I'll select that.\n\nLet's remap this to the L1 button.\n\nNow if you go back, you can see the R1 button is remapped to the L1 button.\n\nRemember our joystick example? You can invert the joystick axis here as well.\n\nSimply click Left Stick and then toggle Invert Vertically.\n\nNow let's say you want to add custom remapping for just one specific app.\n\nYou can do this by selecting Add App and choosing one of your game controller supported apps to remap as needed.\n\nThese customizations will only apply to the app you have selected rather than all game controller apps you might have.\n\nWe have input remapping available in tvOS 14 as well.\n\nIt can be found under Settings > Remotes and Devices > Bluetooth.\n\nThen simply select your connected controller for customization.\n\nSo now that you know how global and per app input remapping work for the user, how can you adopt this in your game? To support global remapping, you simply need to use the game controller framework we reviewed earlier.\n\nThis ensures the benefit of input remapping across all apps on the device.\n\nFor per application remapping, you should additionally check the box called Extended Gamepad in the Game Controller section of Xcode.\n\nThis allows users to apply unique customizations to your app specifically.\n\nIf a user has applied input remapping, you can make sure your in-game UI and tutorials reflect this, along with other controller scenarios your player might encounter.\n\nTo enable this, we have added game controller input glyphs to SF Symbols in iOS 14.\n\nYou no longer need to generate art assets on your own, and Apple keeps this library of glyphs accurate for all controllers that are supported today and in the future.\n\nLike all SF Symbols, you can choose different weights for your game controller glyphs.\n\nAnd to match the look and feel of your game, you can choose Light and Dark Mode glyphs as well as tinted colors to go with your design.\n\nTo learn more, check out Introducing SF Symbols from WWDC 2019.\n\nTo find the correct glyph that matches the player's input, you can look at the sfSymbolsName property of the GCController element.\n\nThis works for the button, axis, joystick, trigger, or shoulder button.\n\nHere, if I want to display the corresponding glyph for the classic Y button, it will return the Y in a circle glyph if the input device is an MFI or Xbox controller or the triangle in a circle glyph if the input device is a DualShock 4.\n\nAnd of course we made sure that the UI accurately reflects any global or per application button remapping your player has chosen to do.\n\nFor example, say the player remapped the Y button to the X button.\n\nWhen you reference the Y button in your game, it will display the X in a circle glyph in the UI.\n\nYour game and your UI are easily responsive to input remapping decisions like these.\n\nAnd that wraps our section on input remapping and UI glyphs.\n\nNow I'll pass it back to James.\n\nJames: Thanks, Hannah.\n\nOK, so let's summarize what we've discussed in this video.\n\nWe talked about how the extensible input API can keep your controller support flexible to any new controllers that may be added.\n\nWe went over game controller and Core Haptics integration that will allow you to create rich haptic and rumble experiences on supported controllers.\n\nWe dove into how you can support some of the more unique features of controllers like motion, lightbar, and battery.\n\nWe also went over the new input remapping available on iOS and tvOS and what that means for your game.\n\nWe talked about new controller button glyphs that have been added to SF Symbols and how you can use them to create a polished and adaptive UI.\n\nAnd finally, we showed how updating your app's capabilities in Xcode to indicate extended gamepad support will badge your game in the App Store, allow per app input remapping, and futureproof your game for any new features that rely on this capability.\n\nFor more information about this year's game controller update, please visit the Developer site for the game controller framework.\n\nIf you're interested in learning about adding keyboard and mouse support to your game, watch this year's talk on Bring Keyboard and Mouse Gaming to iPadOS.\n\nThat's it for this year's game controllers update.\n\nThank you for watching.\n\nWe hope you found this information helpful and that you use it to create some awesome games with game controller support.",
    "segments": []
  },
  "codeExamples": [
    {
      "timestamp": "2:53",
      "title": "Extensible input API",
      "language": "swift",
      "code": "// Extensible input API example\n\nvar attackComboBtn: GCControllerButtonInput?\nvar mapBtn: GCControllerButtonInput?\nvar mappedButtons = Set<GCControllerButtonInput>()\nvar unmappedButtons = Set<GCControllerButtonInput>()\n\nfunc setupConnectedController(_ controller: GCController) {\n    let input = controller.physicalInputProfile\n    \n    // Set up standard button mapping\n    setupBasicControls(input)\n    \n    // Map a shortcut to the player's special combo attack\n    attackComboBtn = input.buttons[\"Paddle 1\"]\n    if (attackComboBtn != nil) { mappedButtons.insert(attackComboBtn!) }\n    \n    // Map a shortcut to the in-game map\n    mapBtn = input.buttons[GCInputDualShockTouchpadButton]\n    if (mapBtn != nil) { mappedButtons.insert(mapBtn!) }\n    \n    // Find buttons that havent' been mapped to any actions yet\n    unmappedButtons = input.allButtons.filter { !mappedButtons.contains($0) }\n}"
    },
    {
      "timestamp": "8:45",
      "title": "Starting the Haptic Engine",
      "language": "swift",
      "code": "private func createAndStartHapticEngine() {\n    // Create and configure a haptic engine for the active controller\n    \n    guard let controller = activeController else { return }\n    \n    hapticEngine = controller.haptics?.createEngine(withLocality: .handles)\n    \n    guard let engine = hapticEngine else {\n        print(\"Active controller does not support handle haptics\")\n        return\n    }"
    },
    {
      "timestamp": "9:05",
      "title": "Play haptics",
      "language": "swift",
      "code": "// Play haptics whenever the player is damaged\n\nprivate func playerWasDamaged(damage: Float) {\n    do {\n        // Calculate the magnitude of damage as percentage of range [0, maxPossibleDamage]\n        let damageMagnitude: Float = ...\n        \n        // Create a haptic pattern player for the player being hit by an enemy\n        let hapticPlayer = try patternPlayerForPlayerDamage(damageMagnitude)\n        \n        // Start player, \"fire and forget\".\n        try hapticPlayer?.start(atTime: CHHapticTimeImmediate)\n    } catch let error {\n        print(\"Haptic Playback Error: \\(error)\")\n    }\n}"
    },
    {
      "timestamp": "9:49",
      "title": "Creating a haptic pattern",
      "language": "swift",
      "code": "// Create a haptic pattern that scales to the damage dealt to the player\n\nprivate func patternPlayerForPlayerDamage(_ damage: Float) throws -> CHHapticPatternPlayer? {\n    let continuousEvent = CHHapticEvent(eventType: .hapticContinuous, parameters: [\n        CHHapticEventParameter(parameterID: .hapticSharpness, value: 0.5),\n        CHHapticEventParameter(parameterID: .hapticIntensity, value: 0.3),\n    ], relativeTime: 0, duration: 0.6)\n    \n    let firstTransientEvent = CHHapticEvent(eventType: .hapticTransient, parameters: [\n        CHHapticEventParameter(parameterID: .hapticSharpness, value: 0.5),\n        CHHapticEventParameter(parameterID: .hapticIntensity, value: 0.9 * damage),\n    ], relativeTime: 0.2)\n    \n    let secondTransientEvent = CHHapticEvent(eventType: .hapticTransient, parameters: [\n        CHHapticEventParameter(parameterID: .hapticSharpness, value: 0.5),\n        CHHapticEventParameter(parameterID: .hapticIntensity, value: 0.9 * damage),\n    ], relativeTime: 0.4)\n    \n    let pattern = try CHHapticPattern(events: [continuousEvent, firstTransientEvent,\n                                               secondTransientEvent], parameters: [])\n    \n    return try engine.makePlayer(with: pattern)\n}"
    },
    {
      "timestamp": "12:28",
      "title": "Updating haptics every frame",
      "language": "swift",
      "code": "// Update the state of the connected controller's haptics every frame\n\nprivate func update() {\n    updateHaptics()\n}\n\nprivate func updateHaptics() {\n    // Update the controller's haptics by sending a dynamic intensity parameter each frame\n    do {\n        // Create dynamic parameter for the intensity.\n        let intensityParam = CHHapticDynamicParameter(parameterID: .hapticIntensityControl,\n                                                        value: hapticEngineMotorIntensity,\n                                                        relativeTime: 0)\n        \n        // Send parameter to the pattern player.\n        try hapticsUpdateLoopPatternPlayer?.sendParameters([intensityParam],\n                                 atTime: CHHapticTimeImmediate)\n    } catch let error {\n        print(\"Dynamic Parameter Error: \\(error)\")\n    }\n}"
    },
    {
      "timestamp": "14:11",
      "title": "Current controller notifications",
      "language": "swift",
      "code": "NSNotification.Name.GCControllerDidBecomeCurrent\nNSNotification.Name.GCControllerDidStopBeingCurrentNotification"
    },
    {
      "timestamp": "15:25",
      "title": "Manual activation",
      "language": "swift",
      "code": "if motion.sensorsRequireManualActivation {\n    motion.sensorsActive = true\n}"
    },
    {
      "timestamp": "15:44",
      "title": "Using total acceleration",
      "language": "swift",
      "code": "if motion.hasGravityAndUserAcceleration {\n    handleMotion(gravity: motion.gravity, userAccel: motion.userAcceleration)\n} else {\n    handleMotion(totalAccel: motion.acceleration)\n}"
    },
    {
      "timestamp": "16:27",
      "title": "Setting up the lightbar",
      "language": "swift",
      "code": "guard let controller = GCController.current else { return }\ncontroller.light?.color = GCColor.init(red: 1.0, green: 0, blue: 0)"
    },
    {
      "timestamp": "22:36",
      "title": "Input glyphs with SF Symbols",
      "language": "swift",
      "code": "let xboxButtonY = xboxController.physicalInputProfile[GCInputButtonY]!\nguard let xboxSfSymbolsName = xboxButtonY.sfSymbolsName else { return }\nlet xboxButtonYGlyph = UIImage(systemName: xboxSfSymbolsName)\n\nlet ds4ButtonY = ds4Controller.physicalInputProfile[GCInputButtonY]!\nguard let ds4SfSymbolsName = ds4ButtonY.sfSymbolsName else { return }\nlet ds4ButtonYGlyph = UIImage(systemName: ds4SfSymbolsName)"
    }
  ],
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "Game Controller",
        "url": "https://developer.apple.com/documentation/GameController"
      },
      {
        "title": "Playing Haptics on Game Controllers",
        "url": "https://developer.apple.com/documentation/CoreHaptics/playing-haptics-on-game-controllers"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2020/10614/4/E368D3E8-DCFB-445D-9ADC-E97C82AEE886/wwdc2020_10614_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2020/10614/4/E368D3E8-DCFB-445D-9ADC-E97C82AEE886/wwdc2020_10614_sd.mp4?dl=1"
  },
  "relatedVideos": [
    {
      "id": "10123",
      "year": "2023",
      "title": "Bring your game to Mac, Part 1: Make a game plan",
      "url": "https://developer.apple.com/videos/play/wwdc2023/10123"
    },
    {
      "id": "10094",
      "year": "2023",
      "title": "Enhance your iPad and iPhone apps for the Shared Space",
      "url": "https://developer.apple.com/videos/play/wwdc2023/10094"
    },
    {
      "id": "10065",
      "year": "2022",
      "title": "Plug-in and play: Add Apple frameworks to your Unity game projects",
      "url": "https://developer.apple.com/videos/play/wwdc2022/10065"
    },
    {
      "id": "10056",
      "year": "2021",
      "title": "Qualities of great iPad and iPhone apps on Macs with M1",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10056"
    },
    {
      "id": "10081",
      "year": "2021",
      "title": "Tap into virtual and physical game controllers",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10081"
    },
    {
      "id": "10617",
      "year": "2020",
      "title": "Bring keyboard and mouse gaming to iPad",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10617"
    },
    {
      "id": "10145",
      "year": "2020",
      "title": "Design for Game Center",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10145"
    },
    {
      "id": "223",
      "year": "2019",
      "title": "Expanding the Sensory Experience with Core Haptics",
      "url": "https://developer.apple.com/videos/play/wwdc2019/223"
    },
    {
      "id": "616",
      "year": "2019",
      "title": "Supporting New Game Controllers",
      "url": "https://developer.apple.com/videos/play/wwdc2019/616"
    }
  ],
  "extractedAt": "2025-07-18T10:33:43.279Z"
}