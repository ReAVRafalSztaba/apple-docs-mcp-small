{
  "id": "10057",
  "year": "2021",
  "url": "https://developer.apple.com/videos/play/wwdc2021/10057/",
  "title": "Take your iPad apps to the next level",
  "speakers": [],
  "duration": "",
  "topics": [
    "Essentials"
  ],
  "hasTranscript": true,
  "hasCode": true,
  "transcript": {
    "fullText": "♪ Bass music playing ♪  ♪ Chris Donegan: Hi, I'm Chris, an engineer on UIKit.\n\nI'll be joined later by my colleagues Anant and Mohammed.\n\niPad is the primary device for many people due to its power and capabilities.\n\nIn this video, you'll learn about some exciting new features you should use to take your iPad app to the next level.\n\nFirst, I'll show you the latest advancements in multitasking and scenes.\n\nThen, Anant will walk you through the powerful changes to keyboard shortcuts.\n\nFinally, Mohammed will show you the latest enhancements to the system pointer.\n\nLet's get right into multitasking.\n\niPadOS 13 introduced the ability to run multiple instances of your app's UI.\n\nIn iPadOS 15, we're improving this experience with new APIs for scene presentation as well as enhanced state restoration.\n\nThese enhancements build upon the existing UIScene infrastructure.\n\nIf you haven't adopted UIScene, check out \"Introducing Multiple Windows on iPad.\" Let's briefly go over the key concepts.\n\nA scene represents a single instance of your app's UI.\n\nThe structure of a scene's components is defined by a scene configuration.\n\nAt a minimum, it defines the scene's role and delegate class.\n\nYou can also provide a name, storyboard, and scene subclass.\n\nScene configurations can either be declared in your Info.plist, or created at runtime using the UISceneConfiguration object.\n\nThe content of a scene is represented by an NSUserActivity.\n\nThese activities are used for requesting scenes as well as for state restoration.\n\nA scene is managed by a scene delegate.\n\nThe delegate is responsible for setting up the UI, responding to lifecycle events, as well as saving and restoring state.\n\nFinally, a scene is tracked by a scene session.\n\nThe scene itself can be disconnected and reconnected by the system when it's in the background.\n\nThe scene session tracks the scene regardless of its connection state and persists between launches.\n\nThe session can be thought of as the representation in the system app switcher.\n\nEach item in the switcher corresponds to a scene session.\n\nWhen requesting a scene from the system, you can provide an options object for customizing the request.\n\niPadOS 15 has a new options subclass specifically for window scenes.\n\nUsing this subclass allows you to specify a presentation style.\n\nWindow scene presentation styles influence how the scene is presented relative to other scenes in the workspace.\n\nThere are three possible values: prominent, standard, and automatic.\n\nThis is a scene using the prominent presentation style.\n\nIt's presented modally in the current workspace with the scenes behind it dimmed.\n\nBecause it's modal, it should provide Cancel, Close, or Done buttons.\n\nThis new style can be thought of as a staging ground for new scenes.\n\nIt can be repositioned like any other scene using the new multitasking controls, and it can also be moved into the app shelf for later.\n\nWhen considering if this style is appropriate for a scene, there are some guidelines to keep in mind.\n\nFirst, prominent scenes should be useful on their own.\n\nThey should not be used for providing options or tools for another scene.\n\nThey should provide a Done or Close button, and they should be dedicated to specific content within your app like a document or file.\n\nThis dedicated content scope must be defined in the scene's activation conditions.\n\nFor more information on activation conditions, check out \"Targeting Content with Multiple Windows.\" This example shows how Safari is opening a new scene using the standard style.\n\nThey are presented side by side, allowing interaction with each, and both provide the full functionality of the main scene.\n\nYou can also specify automatic as the style.\n\nThis value tells the system that it should choose the best style based on how it was requested.\n\niPadOS 15 not only provides a way to customize presentation using styles, it also makes it easier for people to open their content in new scenes.\n\nOn the Mac, it's common to find an Open in New Window item in context menus.\n\nYou should bring this familiar experience to your iPad app by using UIWindowScene.ActivationAction.\n\nIt's a new UIAction subclass for requesting scenes that can be used in menus, buttons, and bar button items.\n\nTo add this functionality to your app, start by initializing a UIWindowScene.ActivationAction.\n\nIt's initialized with a closure that is executed when the item is selected.\n\nThe closure should return an activation configuration with a user activity for the new scene's content.\n\nFinally, put the action in a menu and you're good to go.\n\nOn iPad and Mac Catalyst, the menu shows an Open in New Window item that, when selected, will present a new scene.\n\nOn iPhone, the item is automatically hidden because multiple scenes are not supported.\n\nIf you would rather show another item in its place, you can provide an alternate action.\n\nLet's update the previous example to offer one.\n\nTo do this, start by creating the alternate action.\n\nThe new action's title and image are shown when multiple windows are not available.\n\nThen, update the initializer of the scene activation action by passing the new action as the alternate.\n\nWith an alternate action provided, the menus on iPad and Mac Catalyst still show the Open in New Window item but on iPhone, the Show Details item is visible; all done without a single condition in your code.\n\nAdding these menu items is a clear and familiar way for people to open their content in new scenes.\n\nBut it's not the only way.\n\niPad is a touch-first device and it's easy to open scenes with a single gesture.\n\nIn the Notes app, pinching out on a cell opens the note in a new scene.\n\nThe scene interactively animates from the cell to its final position.\n\nThere are two ways of offering this functionality in your app.\n\nIf you're using a collection view, there's a new delegate method.\n\nFor other views, use UIWindowScene ActivationInteraction.\n\nBoth of these are only for presenting scenes with a prominent style.\n\nTo support this gesture in your collection view, implement the new delegate method named sceneActivationConfiguration ForItemAt indexPath.\n\nIt's very similar to the context menu example from earlier.\n\nCreate the user activity for the new scene's content, then return an activation configuration with that activity.\n\nYou may not want every cell to support opening a new scene.\n\nTo prevent the gesture from beginning, just return nil.\n\nTo support this gesture on other views, create a UIWindowScene .ActivationInteraction.\n\nIt's created with a closure that accepts two arguments: the interaction itself and the point of the interaction in the view's coordinate space.\n\nThese can be used to create specific user activities for different regions of the view.\n\nThe closure should return an activation configuration with the user activity.\n\nThe interaction also takes an error handler.\n\nWhile the interaction is disabled on platforms that don't support multiple scenes, errors can still occur due to configuration issues or a lack of system resources.\n\nYou've probably noticed that all of these ways of presenting window scenes use the same activation configuration object.\n\nIts only requirement is a user activity, but it also contains scene request options and a targeted preview.\n\nIf these are not provided, the system will do its best to create them for you.\n\nHowever, you can explicitly provide them to refine the experience.\n\nAs an example, these collection view cells have a thumbnail, title, and caption.\n\nWhen the cell is pinched out, a scene is presented which mainly displays the larger version of the thumbnail's content.\n\nNotice that the new scene is transitioning from the cell as a whole.\n\nIt would look better if it transitioned from just the thumbnail.\n\nTo achieve this effect, the activation configuration is created as before.\n\nThen, check if the cell is a thumbnail cell.\n\nIf so, use the cell's thumbnail view to create a targeted preview and set it on the configuration.\n\nBy providing a custom preview on the activation configuration, the transition is much more polished.\n\nLet's take a closer look.\n\nNow, rather than transitioning from the cell itself, it transitions from the thumbnail, leaving the rest of the cell in place.\n\nActivation configurations allow you to request any of your app's scenes.\n\nHowever, you may simply want to display a file without having to build a scene yourself.\n\niPadOS 15 makes this very easy.\n\nThere's a special subclass of UIWindowScene .ActivationConfiguration called \"QLPreviewScene ActivationConfiguration\".\n\nReturning a preview scene configuration requests a system-managed preview scene.\n\nThere's no scene delegate and no callbacks to worry about, but your app must declare support for multiple windows in the Info.plist.\n\nProviding polished and convenient ways for people to open content in new scenes is important.\n\nBut it's equally as important to save and restore the scene's state so returning to them later on is a seamless experience.\n\nWhen a scene moves to the background, the system will ask the scene's delegate for an NSUserActivity to represent its state.\n\nThis activity could be the root view controller's activity if it supports Handoff, or one created on the spot.\n\nHere, a user activity is created saving the contents of a text field in the activity's user info dictionary.\n\nTo give the best experience, the scene state should go beyond just the content.\n\nYou should also save the visual and interaction state like scroll position, cursor position, and first responder status.\n\nRather than saving each of these independently, UITextField and UITextView now have an interactionState property.\n\nThis property provides a single object containing all of the interaction state.\n\nThe object doesn't contain the content itself, it's additional information for you to save in the user activity.\n\nI've updated the previous example by saving the interaction state of the text field.\n\nNow, by saving both the content and the interaction state, the user activity contains enough information to be accurately restored.\n\nOn iPadOS 14, restoring state can be a little tricky.\n\nIf you tried to restore state when the scene was connecting, you'd notice that the storyboard and views weren't fully loaded.\n\nIf you restored later, when the scene was transitioning to the foreground, you had to track whether or not it was for the first time.\n\niPadOS 15 solves this problem with a new delegate method explicitly for restoring state.\n\nIt's called after the scene is connected and the storyboard has been loaded, but before the first transition to foreground.\n\nRegardless of whether your app uses storyboards, you should use this new callback for restoring state.\n\nRestoring state from the activity saved in the previous example starts with the system calling sceneRestoreInteractionState.\n\nThen, restoring the content of the text field.\n\nFinally, restoring its interaction state.\n\nIt's critical that the content be restored before the interaction state.\n\nLastly, synchronously restoring state can be complex.\n\nYou may need to access a database or load a file and don't want empty UI during that time.\n\nTo account for this, iPadOS 15 allows your app to request a short-term extension.\n\nDuring this extension, the launch image will remain visible while still allowing the main RunLoop to execute.\n\nOnce your content is loaded, the app should signal to complete the restoration.\n\nThis extension is short and not intended to be used for potentially long-running tasks like network access.\n\nIf your app fails to signal completion, or takes too long, it will be closed by the system.\n\nTo use extended state restoration, start by requesting an extension from the scene.\n\nThen, kick off your asynchronous work.\n\nOnce the content is loaded, restore it and tell the scene to complete restoration.\n\nThe scene will then display your freshly restored UI.\n\nSupporting multitasking in your app makes it shine, but to be a true next-level iPad app, there's more to do.\n\nAnd now, over to Anant.\n\nAnant Jain: Thank you, Chris! My name is Anant and I'm a UIKit engineer.\n\nPeople love that iPad is light enough to hold in their hands while still being able to attach to a physical keyboard at a moment's notice.\n\nThey expect your app to keep up with them by having great keyboard support.\n\niPadOS 15 introduces several new features to bring your app's keyboard shortcuts to the next level.\n\niPadOS 15 features a totally new interface for discovering keyboard shortcuts.\n\nIt structures each command into familiar categories, bringing increased parity between the iPad and Mac Catalyst versions of your app.\n\nThe menu offers a convenient search feature that can be brought up from anywhere across the system.\n\nYou can even tap on a shortcut to trigger it.\n\nIf you need a refresher on how to support keyboard shortcuts with UIKeyCommand, including how commands are dispatched to the responder chain, check out \"Support hardware keyboards in your app.\" On Mac Catalyst, apps each have a global menu called the main menu, which is displayed in the menu bar at the top of the screen.\n\nThe main menu consists of several category submenus, like File and Edit, and these category menus in turn contain further submenus with all the app's commands.\n\nOn iPadOS 15, we've brought the main menu system to iPad apps.\n\nThe new shortcut interface, which appears by holding down the Command key, displays this menu.\n\nNow, the main menu system is represented a bit differently on the iPad compared to the Mac.\n\nThe Mac displays the full submenu hierarchy within each category, whereas the iPad flattens those hierarchies.\n\nDisabled and non-performable commands appear grayed out on the Mac, whereas they are hidden on the iPad.\n\nFurthermore, the iPad shortcut menu is designed to help discover keyboard shortcuts in an app.\n\nIt won't display keyless commands like the Mac menu bar does.\n\nBy default, the main menu contains all the system category menus like File and Edit.\n\nThese include all the system commands, like Undo and Redo, Paste and Match Style, and so on.\n\niPadOS 15 adds the Print command to this list of system commands, which apps can get by adding the UIApplication SupportsPrintCommand key to their Info.plist.\n\nNow that iPad apps on iPadOS 15 support the main menu system, they can use the UIMenuBuilder API to customize it, just like Mac Catalyst apps.\n\nIn fact, if you already have a Mac Catalyst version of your app, you've already done most of the work.\n\nApps should use the builder to add all supported key commands to their main menus.\n\nThis is a change from how apps would previously declare keyboard shortcuts: by overriding the keyCommands property on UIResponder, or by calling addKeyCommand(_:) on a view controller.\n\nCommands defined this way do still work, but they'll appear in a separate uncategorized section of the new interface.\n\nApps should remove key command declarations like this and instead add them to the main menu.\n\nTo customize the main menu, override buildMenu(withbuilder:) in your AppDelegate.\n\nUIKit calls this method at app launch and passes in a UIMenuBuilder object.\n\nApps should check if the builder is modifying the main menu system.\n\nIf so, they can use the builder to make customizations.\n\nSuppose an app wants some key commands in the File menu for working with tabs.\n\nThe app simply creates a submenu using the UIMenu API and adds the desired key commands as that menu's children.\n\nThen the app calls the insertChild method on the builder object to insert the submenu into the File menu.\n\nTo reference an existing element in the main menu system -- like the File menu, in this case -- apps should specify the element's identifier.\n\nThe built-in system menu identifiers are defined as constants under UIMenu.Identifier.\n\nApps can easily create their own menu categories, too.\n\nHere, the app creates a Bookmarks menu -- once again, using the UIMenu API.\n\nThen, the app uses the builder to insert that menu into the root menu -- in this case, after the system View menu.\n\nThat's all it takes! Now, the builder can be used to make further insertions into the Bookmarks menu, just as it would with the File menu.\n\nJust pass in the new menu's identifier, which UIKit automatically generates.\n\nNow, I keep mentioning identifiers.\n\nUIMenuBuilder will enforce that each element in the main menu system has a unique identifier, including individual commands.\n\nSuppose an app inserts key commands to display content either as a list or as a grid.\n\nBoth commands share the same action: changeViewMode(_:).\n\nIn the main menu system, commands are implicitly identified by their actions, so both of these commands share the same identifier.\n\nUIMenuBuilder won't allow both commands to be inserted unless they have different identifiers.\n\nOne way to distinguish these commands is to give them different propertyList values.\n\nBut a better way is to simply give each command a unique action describing what it specifically does.\n\nThe builder also enforces that keyboard shortcut combinations in the main menu are unique.\n\nSuppose an app inserts a Get Info key command on Command-I.\n\nBecause the system Italic shortcut in the text style menu shares the same shortcut, this insertion will also fail.\n\nOnce again, there are two solutions.\n\nThe app can change the Get Info shortcut to something that doesn't collide with an existing shortcut, such as Control-Command-I.\n\nAlternatively, the app can tell the builder to remove the text style commands if they're not needed.\n\nIf an insertion includes a duplicate, then UIMenuBuilder fails that insertion and logs an error in the console showing either the duplicated key commands or the shared identifiers.\n\nIf you're finding your insertions aren't appearing, chances are there's a duplicate somewhere, so look for logs like this in the console.\n\nAfter the call to buildMenu(with builder:) finishes, the app's main menu appears in the Mac menu bar and the iPad shortcut overlay.\n\nThere is one problem, though.\n\nThe app added a submenu with commands to sort bookmarks either by name or by date.\n\nBut because the iPad shortcut overlay doesn't display the submenu hierarchy, it's not clear what these shortcuts do on iPadOS.\n\nFor situations like this, set a more descriptive discoverability title on the key commands.\n\niPadOS prefers the discoverability title over the regular title if both are provided.\n\nNow, I mentioned earlier that individual responders should avoid declaring keyboard shortcuts and instead declare them in the main menu system.\n\nHowever, responders should still implement action methods for main menu commands.\n\nWhen key commands are triggered, UIKit automatically dispatches the action to a responder.\n\nUIKit does this by traversing the app's responder chain.\n\nAs soon as it finds a responder that can perform the action, it calls that responder's action method.\n\nIf nothing in the chain can perform the action, then the key command isn't performable.\n\nIf you're new to UIResponder concepts, \"Support hardware keyboards in your app\" has a fantastic introduction to how it works.\n\n\"Qualities of a great Mac Catalyst app\" also dives into a bit more detail.\n\nWhen UIKit performs a responder search along the chain, it calls two useful UIResponder methods.\n\nApps can override these methods in their responders to improve their key commands.\n\nThe first is canPerformAction (_:withSender:), which UIKit uses to check if a responder can perform an action.\n\nBy default, this returns true if the responder implements that action method; otherwise, it returns false.\n\nResponders can override this to add custom logic.\n\nFor example, a web browser can tell UIKit that the closeTab command isn't performable if there are no open tabs.\n\nSince UIKit can't find a target responder for that action, the command will be non-performable and it won't be shown in the shortcut interface.\n\nNote that overrides for this method must call super for unhandled cases.\n\nThe other useful method is validate(_ command:).\n\nWhen UIKit finds a target responder for a key command, it calls this method on that responder and passes in a copy of the command.\n\nResponders can override validate(_ command:) to update the appearance of the command for the current state of the app.\n\nHere, the app updates the title of the toggleBookmark(_:) command based on whether or not the current page is bookmarked.\n\nThe title set in this method will reflect in the shortcut interface when it appears.\n\nIn iPadOS 15, UIKit is introducing a major change to the responder chain.\n\nWhen apps adopt keyboard navigation with the focus system, then responder traversal will begin at the focused item rather than the first responder.\n\nThis change plays incredibly well with key commands.\n\nPhotos, for example, allows users to work with their photo library using just the keyboard.\n\nWhen users focus a cell in the grid, they can hit the Space bar to view that photo.\n\nThey can even hit Command-C to copy that photo for pasting into another app.\n\nEach cell implements various key command actions, and since responder traversal starts at the focused item, then the key commands target the cell.\n\nIn short, the focus system levels up key commands and the responder chain.\n\nTake advantage of it to support powerful contextual shortcuts in your app.\n\nTo learn more, check out \"Focus on iPad keyboard navigation.\" Finally, iPadOS 15 and macOS 12 introduce keyboard shortcut localization.\n\nWhen you build your app with these SDKs, the system automatically localizes shortcut modifiers and inputs for each keyboard layout.\n\nTake the Command-backslash shortcut, for example.\n\nWhile the shortcut works on a US keyboard, it's impossible to perform on a Japanese keyboard, since that layout has no backslash key.\n\nSo the system will remap the shortcut for Japanese keyboards.\n\nThis means apps should not localize shortcut modifiers or inputs, and instead let the system do the work.\n\nApps can also opt out of automatic localization, either at the app-wide level or on a per-shortcut basis.\n\nWhen the system localizes shortcuts, it also mirrors them for right-to-left layouts.\n\nFor example, a shortcut to navigate backwards with Command-left bracket is flipped to Command-right bracket.\n\nIf a shortcut shouldn't be mirrored, set the command's allowsAutomaticMirroring property to false to disable mirroring without disabling automatic localization entirely.\n\niPadOS 15 is a huge release for keyboard shortcuts.\n\nThere's a ton of other enhancements on top of everything we've covered today.\n\nSo you've adopted all the new Multitasking features, and you've built great keyboard support.\n\nNow, Mohammed will give you a few pointers to take your iPad app to the highest level.\n\nMohammed Jisrawi: Thanks, Anant! Hi, I'm Mohammed.\n\nLet's talk about the improvements iPadOS 15 brings to the system pointer.\n\niPadOS 13.4 introduced an adaptive system pointer that bridges between the touch-based UI of the iPad and the precision of a mouse or trackpad.\n\nIf you're new to pointer interactions, take a moment to familiarize yourself with them and check out these previous videos.\n\n\"Build for the iPadOS pointer\" breaks down the pointer interaction APIs.\n\n\"Design for the iPadOS Pointer\" dives into the design philosophy behind them and discusses best practices when adopting them in your app.\n\niPadOS 15 brings over some familiar Mac user interactions in a way that's consistent with the iPad's design language.\n\nIt also introduces some new concepts that enhance usability and clarity.\n\nThe first of these additions is band selection, a new pointer-specific multiselection experience that should be familiar to anyone who's used a Mac.\n\nIn iPadOS 15, when you click and drag in a collection view, the pointer stretches into a rectangle, and the collection view selects the items that the rectangle encompasses.\n\nOf course this translates naturally to the familiar Mac UI on Mac Catalyst apps.\n\nThis interaction is built into non-list UICollectionViews.\n\nAny UICollectionView that supports the existing one- and two-finger multiselection gestures via the shouldBeginMultiple SelectionInteraction API gets this behavior automatically in iPadOS 15.\n\nFor anything other than a UICollectionView, the new UIBandSelectionInteraction API allows you to easily adopt this experience in your app.\n\nSince the selection logic is completely up to you, you're able to support custom selection behaviors and have your UI react to the changing selection in any way you choose.\n\nTo get started, instantiate the interaction with a selection handler to be called as the pointer moves and the interaction's state changes.\n\nOnce it's created, add the interaction to your view as you would any other UIInteraction.\n\nIn the handler, you can implement your custom selection logic by responding to changes in the interaction's state and selectionRect.\n\nHere we have a simple implementation that sets the selection to the items within the interaction's selectionRect while the pointer is moving.\n\nIt then finalizes the selection session when the primary mouse button is released and the interaction ends.\n\nIn addition to basic selection, UICollectionView's built-in band selection supports some common keyboard shortcuts out of the box.\n\nHolding Shift at the start of the drag, for example, causes items to be added to an existing selection rather than replacing the currently selected items.\n\nHolding Command toggles the selection state of items in the selection rect.\n\nThis can be implemented in custom UI using the interaction's initialModifierFlags property, which provides the keys held at the start of the drag.\n\nSince it's a set of all the pressed modifiers, you can respond to arbitrary key combinations to support custom or more advanced behavior that's specific to your app.\n\nThe second addition to the system pointer is the ability to attach accessories.\n\nAccessories communicate additional information and provide contextual hints by combining secondary shapes with the primary pointer.\n\nFor instance, in the example on the left, the two arrows indicate that this view can be dragged horizontally.\n\nIn the example on the right, the plus provides some additional context for this Add to Cart button.\n\nThere are a few key distinctions between accessories and using a custom pointer shape.\n\nAccessories are visually separate and secondary to the main pointer.\n\nThis is emphasized by the fact that they may be rendered with a different appearance and animate separately from the main pointer.\n\nThey are independent units which can be combined and positioned around the pointer to communicate different ideas.\n\nSince they are independent, they can be combined with any pointer style.\n\nHere's a demonstration of how the same set of accessories -- two arrows indicating draggability -- can be combined with different pointer styles.\n\nOn the left, they're combined with a lift effect where the pointer merges with the view and lifts it up.\n\nIn the middle, they're alongside a highlight effect, where the pointer turns into a rounded rectangle and goes under the view.\n\nOn the right, they appear with the default system pointer using the new UIPointerStyle.system() API.\n\nSo we're able to provide this additional context while still using the ideal effect for the situation, without sacrificing the liveliness of the pointer, and while still maintaining its deep relationship with the app's UI.\n\nJust like it animates between pointer styles, the system will automatically animate the appearance and disappearance of accessories.\n\nIt'll also seamlessly animate between accessory shapes and position.\n\nThe act of transitioning accessories while a given effect is active can be meaningful.\n\nSuch a transition can be used to communicate a change in state or behavior in the underlying UI.\n\nIn the example on the left, the transition from a plus to a no sign may indicate that an operation that was previously possible is no longer permitted.\n\nPointer accessories are composed of a UIPointerShape and a UIPointerAccessory.Position, which describes the desired position as an offset from the pointer's midpoint and an angle from the top.\n\nFor convenience, UIKit provides some predefined values for positions around the pointer.\n\nIf the predefined positions don't quite fit your needs, you can use them as a starting point and customize individual properties.\n\nThis example starts with the topRight position and customizes the offset.\n\nYou can also define entirely custom positions, as in this example, which creates a position with a custom offset and angle.\n\nTo set up the example we saw at the beginning of this segment, we'll create a UITargetedPreview with our view and use that to create a UIPointerStyle with a lift effect.\n\nThen we'll set the style's new accessories property to an array that contains our two arrow accessories.\n\nUIKit provides a premade arrow accessory, so we can just create two of those positioned on the left and right sides of the effect.\n\nSo now when the pointer hovers over this view, the two arrows animate out as the view lifts, hinting that it can be dragged.\n\nIf you've ever tried to implement this sort of interaction where a view with a pointer effect is draggable, you've probably noticed something like this.\n\nWhen the pointer reaches the edge of the pointer region, it disengages from the lifted view and the effect ends.\n\nThis is usually desirable, since it prevents the pointer from sticking to views as it moves around.\n\nHowever, in scenarios like this, the ideal experience would be for the pointer effect to remain stable and latch to the view and follow it along as it's dragged.\n\nTo better enable these sorts of interactions, iPadOS 15 introduces the concept of latchingAxes on UIPointerRegion.\n\nWhen a region latches along a given axis, its pointer effect follows the pointer along the axis when the primary mouse button is pressed.\n\nA horizontally latching region lets you drag freely along the x-axis while still rubberbanding along the y-axis.\n\nA vertically latching one lets you drag freely along the y-axis.\n\nAnd one that latches along both lets you drag freely along both axes.\n\nThese new tools can be used to build some really powerful new experiences.\n\nHere they are combined in a document editing app like Pages or Keynote.\n\nThis image can be selected using band selection.\n\nSelecting the image causes dragging indicators to appear, and when the pointer hovers over an indicator, accessories appear to hint at how the image will be resized if it's dragged.\n\nAnd finally, latching allows the pointer effect and accessories to follow the axis-locked resize gesture.\n\nThese are just some of the enhancements iPadOS 15 brings to the iPad.\n\nTake advantage of them where applicable to really maximize the utility of your app.\n\nAdopt prominent scenes to give people a focused, uninterrupted view of your app's content.\n\nEmpower them to achieve complex tasks quickly with the new keyboard shortcuts menu, and boost their productivity with the new pointer features.\n\nThanks for watching! ♪",
    "segments": []
  },
  "codeExamples": [
    {
      "timestamp": "4:56",
      "title": "Build an \"Open in New Window\" action",
      "language": "swift",
      "code": "let <#newSceneAction#> = UIWindowScene.ActivationAction({ _ in\n\n    // Create the user activity that represents the new scene content.\n    let userActivity = NSUserActivity(activityType: <#User Activity Type#>)\n\n    // Return the activation configuration.\n    return UIWindowScene.ActivationConfiguration(userActivity: userActivity)\n\n})"
    },
    {
      "timestamp": "5:43",
      "title": "Use an alternate action with UIWindowScene.ActivationAction",
      "language": "swift",
      "code": "// Create an action to use when multiple scenes are not available.\nlet alternateAction = UIAction(title: <#Alternate Action Title#>,\n                               image: <#Alternate Action Image#>,\n                             handler: { _ in\n    <#Perform Alternate Action#>\n})\n\n// Create the scene activation action with the alternate.\nlet newSceneAction = UIWindowScene.ActivationAction(alternate: alternateAction) { _ in\n\n    // Create the user activity that represents the new scene content.\n    let userActivity = NSUserActivity(activityType: <#Scene Activity Type#>)\n\n    // Return the activation configuration.\n    return UIWindowScene.ActivationConfiguration(userActivity: userActivity)\n}"
    },
    {
      "timestamp": "6:58",
      "title": "Present a scene from a collection view with a gesture",
      "language": "swift",
      "code": "func collectionView(_ collectionView: UICollectionView,\n                    sceneActivationConfigurationForItemAt indexPath: IndexPath,\n                    point: CGPoint) -> UIWindowScene.ActivationConfiguration? {\n\n    // Get the item's user activity.\n    guard let itemActivity = <#User Activity#> else {\n        // Return nil if item can’t be opened in a dedicated scene.\n        return nil\n    }\n\n    // Return the activation configuration.\n    return UIWindowScene.ActivationConfiguration(userActivity: itemActivity)\n}"
    },
    {
      "timestamp": "7:28",
      "title": "Present a scene from a custom view with a gesture",
      "language": "swift",
      "code": "// Create an activation interaction.\nlet newSceneInteraction = UIWindowScene.ActivationInteraction { interaction, point in\n    // Get the activity for specific point in view.\n    guard let userActivity = <#User Activity#> else { return nil }\n\n    // Return an activation configuration.\n    return UIWindowScene.ActivationConfiguration(userActivity: userActivity)\n\n} errorHandler: { error in\n    // Present the content in another manner.\n    <#Present Content#>\n}\n\n// Add interaction to the view.\n<#View#>.addInteraction(newSceneInteraction)"
    },
    {
      "timestamp": "8:53",
      "title": "Customize scene transition preview",
      "language": "swift",
      "code": "// Create the activation configuration.\nlet itemActivity = NSUserActivity(activityType: <#User Activity Type#>)\nlet configuration = UIWindowScene.ActivationConfiguration(userActivity: itemActivity)\n\n// If the cell has a subview to use as the preview, create the custom preview.\nif let cell = collectionView.cellForItem(at: indexPath) as? <#Expected Cell Class#> {\n    configuration.preview = UITargetedPreview(view: cell.<#Subview For Preview#>)\n}\n\n// Return the activation configuration.\nreturn configuration"
    },
    {
      "timestamp": "10:18",
      "title": "Save scene state",
      "language": "swift",
      "code": "func stateRestorationActivity(for scene: UIScene) -> NSUserActivity? {\n    guard let viewController = self.window?.rootViewController as? <#Expected View Controller Class#> else {\n        return nil\n    }\n\n    let stateActivity = NSUserActivity(activityType: <#State Restoration Activity Type#>)\n\n    stateActivity.addUserInfoEntries(from: [\n        // Save content of a text field.\n        <#Content Key#>: viewController.<#Text Field#>.text\n    ])\n\n    return stateActivity\n}"
    },
    {
      "timestamp": "11:16",
      "title": "Save scene state with interaction state",
      "language": "swift",
      "code": "func stateRestorationActivity(for scene: UIScene) -> NSUserActivity? {\n    guard let viewController = self.window?.rootViewController as? <#Expected View Controller Class#> else {\n        return nil\n    }\n\n    let stateActivity = NSUserActivity(activityType: <#State Restoration Activity Type#>)\n\n    stateActivity.addUserInfoEntries(from: [\n        // Save content of a text field.\n        <#Content Key#>: viewController.<#Text Field#>.text,\n\n        // Save interaction state of a text field.\n        <#Interaction State Key#>: viewController.<#Text Field#>.interactionState\n    ])\n\n    return stateActivity\n}"
    },
    {
      "timestamp": "12:13",
      "title": "Restore scene state",
      "language": "swift",
      "code": "func scene(_ scene: UIScene, restoreInteractionState stateRestorationActivity: NSUserActivity) {\n    guard let viewController = window?.rootViewController as? <#Expected View Controller Class#>,\n          let userInfo = stateRestorationActivity.userInfo\n    else { return }\n\n    if let content = userInfo[<#Content Key#>] as? String {\n        // Restore the content first.\n        viewController.<#Text Field#>.text = content\n\n        // Then, restore the text field’s interaction state.\n        if let interactionState = userInfo[<#Interaction State Key#>] {\n            viewController.<#Text Field#>.interactionState = interactionState\n        }\n    }\n}"
    },
    {
      "timestamp": "13:15",
      "title": "Restore scene state asynchronously",
      "language": "swift",
      "code": "func scene(_ scene: UIScene, restoreInteractionState stateRestorationActivity: NSUserActivity) {\n    guard let viewController = window?.rootViewController as? <#Expected View Controller Class#> else { return }\n\n    // Request an extension.\n    scene.extendStateRestoration()\n\n    // Fetch content asynchronously.\n    <#self.someAsyncFunction#> { result in\n        <#Restore Content#>\n\n        // Signal that state has been restored.\n        scene.completeStateRestoration()\n    }\n}"
    },
    {
      "timestamp": "17:15",
      "title": "Modify the main menu",
      "language": "swift",
      "code": "override func buildMenu(with builder: UIMenuBuilder) {\n    super.buildMenu(with: builder)\n    \n    // Ensure the builder is modifying the main menu.\n    guard builder.system == .main else { return }\n    \n    // Use the builder to modify the main menu...\n}"
    },
    {
      "timestamp": "17:37",
      "title": "Add key commands to the main menu",
      "language": "swift",
      "code": "// Create a menu with key commands.\nlet tabMenu = UIMenu(options: .displayInline, children: [\n    UIKeyCommand(title: NSLocalizedString(\"New Tab\", ...),\n                 action: #selector(BrowserViewController.newTab(_:)),\n                 input: \"t\",\n                 modifierFlags: .command),\n    UIKeyCommand(...)\n])\n\n// Insert tabMenu into the File menu.\nbuilder.insertChild(tabMenu, atStartOfMenu: .file)"
    },
    {
      "timestamp": "18:19",
      "title": "Add a custom menu category",
      "language": "swift",
      "code": "// Create a \"Bookmarks\" menu.\nlet bookmarksMenu = UIMenu(title: NSLocalizedString(\"Bookmarks\", ...),\n                           children: [...])\n\n// Insert the Bookmarks menu into the root menu, after View.\nbuilder.insertSibling(bookmarksMenu, afterMenu: .view)\n\n// Insert another menu into the Bookmarks menu.\nlet sortBookmarksMenu = UIMenu(...)\nbuilder.insertChild(sortBookmarksMenu, atEndOfMenu: bookmarksMenu.identifier)"
    },
    {
      "timestamp": "22:38",
      "title": "Customizing key command performability",
      "language": "swift",
      "code": "override func canPerformAction(_ action: Selector, withSender sender: Any?) -> Bool {\n    if action == #selector(closeTab(_:)) {\n        return !openTabs.isEmpty\n    } else {\n        return super.canPerformAction(action, withSender: sender)\n    }\n}"
    },
    {
      "timestamp": "23:26",
      "title": "Customizing key command appearance",
      "language": "swift",
      "code": "override func validate(_ command: UICommand) {\n    if command.action == #selector(toggleBookmark(_:)) {\n        if currentTab.isInBookmarks {\n            command.title = NSLocalizedString(\"Add to Bookmarks\", ...)\n        } else {\n            command.title = NSLocalizedString(\"Remove from Bookmarks\", ...)\n        }\n    } else {\n        return super.validate(command)\n    }\n}"
    },
    {
      "timestamp": "28:47",
      "title": "Supporting multi-selection using UIBandSelectionInteraction",
      "language": "swift",
      "code": "// Support multi-selection using UIBandSelectionInteraction.\n\nlet selectionInteraction = UIBandSelectionInteraction { [weak self] interaction in\n    guard let strongSelf = self else { return }\n            \n    // Handle selection by responding to interaction state.\n    if interaction.state == .selecting {\n        strongSelf.selectItemsInRect(interaction.selectionRect)\n    } \n    else if interaction.state == .ended {\n        strongSelf.finalizeSelection()\n    }\n}\n\nview.addInteraction(selectionInteraction)"
    },
    {
      "timestamp": "33:01",
      "title": "Customizing a predefined pointer accessory position",
      "language": "swift",
      "code": "var position = UIPointerAccessory.Position.topRight\nposition.offset = 40.0"
    },
    {
      "timestamp": "33:14",
      "title": "Creating a custom pointer accessory position",
      "language": "swift",
      "code": "let position = UIPointerAccessory.Position(offset: 23.0, angle: .pi * 1.25)"
    },
    {
      "timestamp": "33:27",
      "title": "Pointer Accessories",
      "language": "swift",
      "code": "// Attach two arrow accessories to a lift pointer effect.\n\nfunc pointerInteraction(_ interaction: UIPointerInteraction, styleFor region: UIPointerRegion) -> UIPointerStyle?\n{\n    let preview = UITargetedPreview(view: self)\n    let style = UIPointerStyle(effect: .lift(preview))\n\n    if #available(iOS 15.0, *) {\n        style.accessories = [\n            .arrow(.left),\n            .arrow(.right)\n        ]\n    }\n\n    return style\n}"
    }
  ],
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "Adding hardware keyboard support to your app",
        "url": "https://developer.apple.com/documentation/UIKit/adding-hardware-keyboard-support-to-your-app"
      },
      {
        "title": "Adding Menus and Shortcuts to the Menu Bar and User Interface",
        "url": "https://developer.apple.com/documentation/uikit/uicommand/adding_menus_and_shortcuts_to_the_menu_bar_and_user_interface"
      },
      {
        "title": "Enhancing your iPad app with pointer interactions",
        "url": "https://developer.apple.com/documentation/UIKit/enhancing-your-ipad-app-with-pointer-interactions"
      },
      {
        "title": "Human Interface Guidelines: Pointing devices",
        "url": "https://developer.apple.com/design/human-interface-guidelines/pointing-devices"
      },
      {
        "title": "UIKit",
        "url": "https://developer.apple.com/documentation/UIKit"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2021/10057/7/5399C1AB-B62F-4A83-8AA1-FCBFDAFFBF44/downloads/wwdc2021-10057_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2021/10057/7/5399C1AB-B62F-4A83-8AA1-FCBFDAFFBF44/downloads/wwdc2021-10057_sd.mp4?dl=1"
  },
  "relatedVideos": [
    {
      "id": "10260",
      "year": "2021",
      "title": "Focus on iPad keyboard navigation",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10260"
    },
    {
      "id": "10053",
      "year": "2021",
      "title": "Qualities of a great Mac Catalyst app",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10053"
    },
    {
      "id": "10056",
      "year": "2021",
      "title": "Qualities of great iPad and iPhone apps on Macs with M1",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10056"
    },
    {
      "id": "10059",
      "year": "2021",
      "title": "What's new in UIKit",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10059"
    },
    {
      "id": "10093",
      "year": "2020",
      "title": "Build for the iPadOS pointer",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10093"
    },
    {
      "id": "10640",
      "year": "2020",
      "title": "Design for the iPadOS pointer",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10640"
    },
    {
      "id": "10109",
      "year": "2020",
      "title": "Support hardware keyboards in your app",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10109"
    },
    {
      "id": "212",
      "year": "2019",
      "title": "Introducing Multiple Windows on iPad",
      "url": "https://developer.apple.com/videos/play/wwdc2019/212"
    },
    {
      "id": "259",
      "year": "2019",
      "title": "Targeting Content with Multiple Windows",
      "url": "https://developer.apple.com/videos/play/wwdc2019/259"
    }
  ],
  "extractedAt": "2025-07-18T10:25:16.227Z"
}