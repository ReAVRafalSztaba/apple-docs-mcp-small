{
  "id": "10216",
  "year": "2024",
  "url": "https://developer.apple.com/videos/play/wwdc2024/10216/",
  "title": "Explore the Swift on Server ecosystem",
  "speakers": [],
  "duration": "",
  "topics": [
    "Swift"
  ],
  "hasTranscript": true,
  "hasCode": true,
  "transcript": {
    "fullText": "Hi, I'm Franz from the Swift on Server Team at Apple. Today, we are going to explore the Swift on Server ecosystem. First, we will talk about why Swift is such a great language for developing server applications. Then we are going to build a service with some popular packages from the ecosystem. Finally, we will explore how the ecosystem operates and where to learn more. Let's get started on what makes Swift great for server applications. Swift let's you achieve C-like performance with a low memory footprint due to automatic reference counting instead of garbage collection. Making it a perfect fit for modern cloud services which require a predictable resource consumption and fast startup time. Swift is an expressive and safe language, which eliminates a range of bugs at compile time, allowing developers to write robust and reliable distributed systems. Features such as strong-typing, optionals and memory safety make Swift services less prone to crashes and security vulnerabilities. Cloud services often have to handle highly concurrent workloads. Swift's first class concurrency features allow developers to write scalable and responsive server applications while eliminating a common source of bugs due to data races. All these properties make Swift an excellent choice for writing server applications. In fact, Swift powers many critical features across Apple's cloud services such as iCloud Keychain, Photos and Notes. Other use cases include, the App Store processing pipelines and SharePlay file sharing. Lastly, our brand new Private Cloud Compute service is built using Swift on Server. Across Apple's services this amounts to millions of requests per second being handled by applications using Swift on Server.\n\nOutside of Apple's platforms, the Server ecosystem was one of the earliest users of Swift. In fact, the Swift Server workgroup was founded in 2016, just one year after the open sourcing of Swift. Making it the oldest workgroup. The workgroup consists of members representing companies using Swift on Server and individual contributors of the ecosystem. It is focused on promoting the use of Swift for developing and deploying server applications. The workgroup's responsibilities include: defining and prioritising efforts to address the needs of the server community; running an incubation process for packages to reduce duplication of effort, increase compatibility and promote best practices. The workgroup also channels feedback from the server ecosystem back to the other groups of the Swift project. Now, let's use some of the popular packages from the server ecosystem to build a service. My colleagues and I are planning to attend a lot of events this year. To organise ourselves we wanted to implement an event service that keeps track of who is attending which event. The service should support two operations. One to list all events to show who is planning to attend what event. And since I can't miss going to the Oktoberfest we need another operation to create a new event. To work on Swift packages you can use different editors such as Xcode, VS Code, Neovim, or any other editor that supports the language server protocol. For today's demo, we are going to use VS Code to work on our package. During the demo we are going to use the built-in terminals from VS Code at the bottom to see the outputs from our service and send requests to it. I already prepared a package for us to get started on the event service. Let's go check it out. The package depends on the OpenAPI generator and uses Vapor as the server transport for OpenAPI.\n\nThe package has two targets. The EventAPI target, which has the OpenAPIGenerator plugin configured and the EventService executableTarget which contains the implementation of our service. Swift OpenAPI Generator allows us to document our service in YAML and generate code for servers and clients. If you are new or want to review OpenAPI feel free to watch \"Meet Swift OpenAPI Generator\" from last year. Let's review the OpenAPI document. It defines both of our operations in the events path The first operation is a get method called listEvents.\n\nThe operation returns a success response containing an array of events.\n\nThe second operation is a post method called createEvent.\n\nThis operation takes a JSON body of an event and depending if the creation was successful the operation returns a 201 or a 400 status code.\n\nOur Service contains the main entry point. We first create a Vapor application.\n\nThen we create the OpenAPI VaporTransport with the application.\n\nNext, we create an instance of our Service and register it on the transport.\n\nAnd lastly, we execute the Vapor application, which will start an HTTP server and listen for incoming connections.\n\nOur Service also implements the generated APIProtocol.\n\nThe listEvents method returns a hard coded array of events.\n\nThe createEvent method is currently returning a not implemented status code.\n\nLet's go ahead and start our service.\n\nThis is going to build our service and attach a debugger to it. At the bottom in the terminal we can see that the server started. Now we can list all events by querying our service in another terminal using curl.\n\nGreat, our service returned a JSON array containing the hard coded list of events. However, we want to dynamically add new events and persist them in a database, so let's take a look at database drivers. There are many different database drivers in the open source ecosystem for databases like PostgreSQL, MySQL, Cassandra, MongoDB and many more.\n\nToday we are going to use a Postgres database for persistence. PostgresNIO is an open source database driver for Postgres maintained by Vapor and Apple. New in PostgresNIO 1.21 is the PostgresClient. The PostgresClient provides a completely new asynchronous interface and comes with a built-in connection pool which leverages structured concurrency, making it resilient against intermittent networking failures to the database. Additionally, the connection pool improves throughput by distributing queries over multiple connections and prewarming connections for faster query execution. Let's go ahead and use PostgresNIO to connect our EventService to a database. We'll start by adding a dependency to PostgresNIO in our package and import it in our service. Then we are going to use the PostgresClient to query our database in the listEvents method. Lastly, we are going to implement the createEvent method to insert the new event into the database. Let's start by adding the dependency to PostgresNIO in our package manifest.\n\nThen we can add a dependency to our EventService target.\n\nNow we can import PostgresNIO in our Service.\n\nNext we are going add a PostgresClient property to our service.\n\nWe'll use the client to query the database in the listEvents method The query method returns an AsyncSequence of rows. To replace the hard coded list of events we'll iterate over the rows, decode the fields and create an event for each row.\n\nThe AsyncSequence returned by the query method will automatically prefetch rows from the database to speed up performance. Before we can run our service again we have to create a PostgresClient and pass it to our Service.\n\nFirst, we create a PostgresClient to connect to a database that I already started locally.\n\nNext we are going to pass the PostgresClient to our service.\n\nTo start the client we need to call its run method, which is going to take over the current task until it is finished. Since we want to run both the Vapor application and the PostgresClient concurrently we are going to use a task group. We'll create a discarding task group and add a child task that runs the PostgresClient.\n\nThen we move the Vapor application execution into a separate child task.\n\nLet's run our service again.\n\nThe restart button is going to stop the current process, rebuild the service and start it again.\n\nThe terminal at the bottom shows it's running. Let's list all events again.\n\nOur database appears to be empty. To add new events to the database we'll implement the createEvent method next.\n\nFirst, we have to switch over the input and extract the JSON event.\n\nThen we are going to query the database to insert the new event.\n\nLastly, we have to return that we created the event.\n\nSeeing this code might set off alarms for some people since in other languages this is a common vector for SQL injection vulnerabilities. Even though this looks like a string it isn't a string, but uses Swift's String interpolation feature to transform the string query into a parameterised query with value binding. Making it completely safe from SQL injection attacks. This is a great example of Swift's commitment to making things ergonomic while guaranteeing the safety of the code. We are going to restart our service.\n\nOnce the service is running again we are going to use curl to create two events.\n\nLooks like the event creation was successful. Let's check if the events have been stored in our database by listing all events again.\n\nPerfect, all events were saved in the database. Gus just send me a message that he wanted to bring a friend and asked if I can add another event entry under his name. Let's go ahead and create another event for Gus.\n\nLooks like something went wrong when trying to add another event entry under Gus's name. In the terminal at the bottom we can see a long error message; however, the error isn't telling us exactly what went wrong. The only information that we see is that the operation couldn't be completed and that the thrown error was of the type PSQLError. The description of PSQLError intentionally omits detailed information to prevent accidental leakage of database information such as the schemas of your table. In cases like this, adding additional observability to your service helps troubleshooting. Observability consists of three pillars logging, metrics and tracing. Logging helps you understand exactly what a service did and lets you dig into the details while troubleshooting problems. Metrics allow you to get a high level overview of the health of your service at a glance. While logs and metrics help you understand what a single service does modern cloud systems are often a collection of distributed systems. This is where tracing helps you understand what path a single request took through your system. The Swift ecosystem offers API packages for all three pillars that allow code to emit observability events. Let's take a look how we could instrument our listEvents method. First, we can use swift-log to emit a log when we start to handle a new listEvents request. swift-log supports structured logging by adding metadata to log messages providing additional context when troubleshooting problems. Next, we can add a counter from swift-metrics that we increment on each request to track how many requests our service has processed. Lastly, we can add swift-distributed-tracing to create a span around our database query, which can help while troubleshooting a request end to end through our system. If you want to learn more about how distributed tracing in Swift works check out last year's session \"Beyond the basics of structured concurrency\". We have just instrumented our listEvents method with logging, metrics and tracing. The APIs we used are observability backend agnostic leaving the choice to the service author where to send the data. The Swift on Server ecosystem contains many different backends for logging, metrics and distributed tracing. Choosing the backends is done by calling the bootstrapping methods of the three libraries. Bootstrapping should only be done in executables and should happen as early as possible to ensure no observability event is lost. Additionally, it is recommended to bootstrap your LoggingSystem first, then your MetricsSystem, and lastly your InstrumentationSystem. This is because metrics and instrumentation systems might want to emit logs about their status. With just a couple of lines of code we were able to emit logs to the terminal, metrics to Prometheus and traces to Open Telemetry. Let's add logging to our createEvent method to understand what exactly goes wrong when we try to add another event under Gus' name. First, we have to add swift-log as a dependency to our package and our EventService target.\n\nThen we can import the Logging module in our Service.\n\nNext, we'll catch the errors thrown by the query method.\n\nThe query method throws a PSQLError in the case something went wrong when executing the query.\n\nLet's create a logger so that we can emit a log event containing the error message sent by the Postgres server.\n\nNext, we are going to extract the error message and emit the log. The PSQLError contains detailed information about what went wrong in the serverInfo property.\n\nLast, we'll return a badRequest response to indicate something went wrong while adding the event to the database.\n\nLet's restart our service and see if we can get more details about the error.\n\nBy default swift-log will emit logs to the terminal. This is perfect for debugging our application. We'll run the same curl command to create the event again.\n\nThis time we didn't get the same error since we returned the badRequest status code. So let's checkout the logs from our service to see what went wrong. In the terminal at the bottom we can see the log message. The error message metadata field tells us that the error was due to a duplicate key violation. Our database table only allows a single entry for a combination of name, date and attendee. Adding logging helped us troubleshoot the concrete problem. I'll let my colleague fix that bug later.\n\nThis was just a short glimpse at some of the libraries of the Swift on Server ecosystem that you can use to build a service. There are many more libraries for various use cases such as networking, database drivers, observability, message streaming, and much more. If you are interested in finding more libraries go to the swift.org packages section and explore the server category. You can also use the swift package index to find more server libraries. Another great resource to find packages is the incubation list of the Swift Server Workgroup. The workgroup runs an incubation process for packages to create a robust and stable ecosystem. Packages in the incubation process transition through maturity levels from Sandbox, to Incubating, to Graduated. Each level has different requirements aligned with the package's production readiness and usage. You can find the list of incubated packages on swift.org I hope this session excited you about the Swift on Server ecosystem. We talked about why Swift is such a great language for server applications and how it is powering a lot of critical features across Apple's cloud services. We also explored some of the packages and how the Swift Server Workgroup helps to grow a healthy ecosystem. Thank you for watching! Servus and see you at the Oktoberfest!",
    "segments": []
  },
  "codeExamples": [
    {
      "timestamp": "3:23",
      "title": "EventService Package.swift",
      "language": "swift",
      "code": "// swift-tools-version:5.9\nimport PackageDescription\n\nlet package = Package(\n  name: \"EventService\",\n  platforms: [.macOS(.v14)],\n  dependencies: [\n    .package(\n      url: \"https://github.com/apple/swift-openapi-generator\",\n      from: \"1.2.1\"\n    ),\n    .package(\n      url: \"https://github.com/apple/swift-openapi-runtime\",\n      from: \"1.4.0\"\n    ),\n    .package(\n      url: \"https://github.com/vapor/vapor\",\n      from: \"4.99.2\"\n    ),\n    .package(\n      url: \"https://github.com/swift-server/swift-openapi-vapor\",\n      from: \"1.0.1\"\n    ),\n  ],\n  targets: [\n    .target(\n      name: \"EventAPI\",\n      dependencies: [\n        .product(\n          name: \"OpenAPIRuntime\",\n          package: \"swift-openapi-runtime\"\n        ),\n      ],\n      plugins: [\n        .plugin(\n          name: \"OpenAPIGenerator\",\n          package: \"swift-openapi-generator\"\n        )\n      ]\n    ),\n    .executableTarget(\n      name: \"EventService\",\n      dependencies: [\n        \"EventAPI\",\n        .product(\n          name: \"OpenAPIRuntime\",\n          package: \"swift-openapi-runtime\"\n        ),\n        .product(\n          name: \"OpenAPIVapor\",\n          package: \"swift-openapi-vapor\"\n        ),\n        .product(\n          name: \"Vapor\",\n          package: \"vapor\"\n        ),\n      ]\n    ),\n  ]\n)"
    },
    {
      "timestamp": "4:05",
      "title": "EventService openapi.yaml",
      "language": "swift",
      "code": "openapi: \"3.1.0\"\ninfo:\n  title: \"EventService\"\n  version: \"1.0.0\"\nservers:\n  - url: \"https://localhost:8080/api\"\n    description: \"Example service deployment.\"\npaths:\n  /events:\n    get:\n      operationId: \"listEvents\"\n      responses:\n        \"200\":\n          description: \"A success response with all events.\"\n          content:\n            application/json:\n              schema:\n                type: \"array\"\n                items:\n                  $ref: \"#/components/schemas/Event\"\n    post:\n      operationId: \"createEvent\"\n      requestBody:\n        description: \"The event to create.\"\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/Event'\n      responses:\n        '201':\n          description: \"A success indicating the event was created.\"\n        '400':\n          description: \"A failure indicating the event wasn't created.\"\ncomponents:\n  schemas:\n    Event:\n      type: \"object\"\n      description: \"An event.\"\n      properties:\n        name:\n          type: \"string\"\n          description: \"The event's name.\"\n        date:\n          type: \"string\"\n          format: \"date\"\n          description: \"The day of the event.\"\n        attendee:\n          type: \"string\"\n          description: \"The name of the person attending the event.\"\n      required:\n        - \"name\"\n        - \"date\"\n        - \"attendee\""
    },
    {
      "timestamp": "4:35",
      "title": "EventService initial implementation",
      "language": "swift",
      "code": "import OpenAPIRuntime\nimport OpenAPIVapor\nimport Vapor\nimport EventAPI\n\n@main\nstruct Service {\n  static func main() async throws {\n    let application = try await Vapor.Application.make()\n    let transport = VaporTransport(routesBuilder: application)\n\n    let service = Service()\n    try service.registerHandlers(\n      on: transport,\n      serverURL: URL(string: \"/api\")!\n    )\n\n    try await application.execute()\n  }\n}\n\nextension Service: APIProtocol {\n  func listEvents(\n    _ input: Operations.listEvents.Input\n  ) async throws -> Operations.listEvents.Output {\n    let events: [Components.Schemas.Event] = [\n      .init(name: \"Server-Side Swift Conference\", date: \"26.09.2024\", attendee: \"Gus\"),\n      .init(name: \"Oktoberfest\", date: \"21.09.2024\", attendee: \"Werner\"),\n    ]\n\n    return .ok(.init(body: .json(events)))\n  }\n\n  func createEvent(\n    _ input: Operations.createEvent.Input\n  ) async throws -> Operations.createEvent.Output {\n    return .undocumented(statusCode: 501, .init())\n  }\n}"
    },
    {
      "timestamp": "6:56",
      "title": "EventService Package.swift",
      "language": "swift",
      "code": "// swift-tools-version:5.9\nimport PackageDescription\n\nlet package = Package(\n  name: \"EventService\",\n  platforms: [.macOS(.v14)],\n  dependencies: [\n    .package(\n      url: \"https://github.com/apple/swift-openapi-generator\",\n      from: \"1.2.1\"\n    ),\n    .package(\n      url: \"https://github.com/apple/swift-openapi-runtime\",\n      from: \"1.4.0\"\n    ),\n    .package(\n      url: \"https://github.com/vapor/vapor\",\n      from: \"4.99.2\"\n    ),\n    .package(\n      url: \"https://github.com/swift-server/swift-openapi-vapor\",\n      from: \"1.0.1\"\n    ),\n    .package(\n      url: \"https://github.com/vapor/postgres-nio\",\n      from: \"1.19.1\"\n    ),\n  ],\n  targets: [\n    .target(\n      name: \"EventAPI\",\n      dependencies: [\n        .product(\n          name: \"OpenAPIRuntime\",\n          package: \"swift-openapi-runtime\"\n        ),\n      ],\n      plugins: [\n        .plugin(\n          name: \"OpenAPIGenerator\",\n          package: \"swift-openapi-generator\"\n        )\n      ]\n    ),\n    .executableTarget(\n      name: \"EventService\",\n      dependencies: [\n        \"EventAPI\",\n        .product(\n          name: \"OpenAPIRuntime\",\n          package: \"swift-openapi-runtime\"\n        ),\n        .product(\n          name: \"OpenAPIVapor\",\n          package: \"swift-openapi-vapor\"\n        ),\n        .product(\n          name: \"Vapor\",\n          package: \"vapor\"\n        ),\n        .product(\n            name: \"PostgresNIO\",\n          package: \"postgres-nio\"\n        ),\n      ]\n    ),\n  ]\n)"
    },
    {
      "timestamp": "7:08",
      "title": "Implementing the listEvents method",
      "language": "swift",
      "code": "import OpenAPIRuntime\nimport OpenAPIVapor\nimport Vapor\nimport EventAPI\nimport PostgresNIO\n\n@main\nstruct Service {\n  let postgresClient: PostgresClient\n  \n  static func main() async throws {\n    let application = try await Vapor.Application.make()\n    let transport = VaporTransport(routesBuilder: application)\n\n    let postgresClient = PostgresClient(\n      configuration: .init(\n        host: \"localhost\",\n        username: \"postgres\",\n        password: nil,\n        database: nil,\n        tls: .disable\n      )\n    )\n    let service = Service(postgresClient: postgresClient)\n    try service.registerHandlers(\n      on: transport,\n      serverURL: URL(string: \"/api\")!\n    )\n\n    try await withThrowingDiscardingTaskGroup { group in\n      group.addTask {\n        await postgresClient.run()\n      }\n\n      group.addTask {\n        try await application.execute()\n      }\n    }\n  }\n}\n\nextension Service: APIProtocol {\n  func listEvents(\n    _ input: Operations.listEvents.Input\n  ) async throws -> Operations.listEvents.Output {\n    let rows = try await self.postgresClient.query(\"SELECT name, date, attendee FROM events\")\n\n    var events = [Components.Schemas.Event]()\n    for try await (name, date, attendee) in rows.decode((String, String, String).self) {\n      events.append(.init(name: name, date: date, attendee: attendee))\n    }\n\n    return .ok(.init(body: .json(events)))\n  }\n\n  func createEvent(\n    _ input: Operations.createEvent.Input\n  ) async throws -> Operations.createEvent.Output {\n    return .undocumented(statusCode: 501, .init())\n  }\n}"
    },
    {
      "timestamp": "9:02",
      "title": "Implementing the createEvent method",
      "language": "swift",
      "code": "func createEvent(\n  _ input: Operations.createEvent.Input\n) async throws -> Operations.createEvent.Output {\n  switch input.body {\n  case .json(let event):\n    try await self.postgresClient.query(\n      \"\"\"\n      INSERT INTO events (name, date, attendee)\n      VALUES (\\(event.name), \\(event.date), \\(event.attendee))\n      \"\"\"\n    )\n    return .created(.init())\n  }\n}"
    },
    {
      "timestamp": "11:34",
      "title": "Instrumenting the listEvents method",
      "language": "swift",
      "code": "func listEvents(\n  _ input: Operations.listEvents.Input\n) async throws -> Operations.listEvents.Output {\n  let logger = Logger(label: \"ListEvents\")\n  logger.info(\"Handling request\", metadata: [\"operation\": \"\\(Operations.listEvents.id)\"])\n\n  Counter(label: \"list.events.counter\").increment()\n\n  return try await withSpan(\"database query\") { span in\n    let rows = try await postgresClient.query(\"SELECT name, date, attendee FROM events\")\n    return try await .ok(.init(body: .json(decodeEvents(rows))))\n  }\n}"
    },
    {
      "timestamp": "13:14",
      "title": "EventService Package.swift",
      "language": "swift",
      "code": "// swift-tools-version:5.9\nimport PackageDescription\n\nlet package = Package(\n  name: \"EventService\",\n  platforms: [.macOS(.v14)],\n  dependencies: [\n    .package(\n      url: \"https://github.com/apple/swift-openapi-generator\",\n      from: \"1.2.1\"\n    ),\n    .package(\n      url: \"https://github.com/apple/swift-openapi-runtime\",\n      from: \"1.4.0\"\n    ),\n    .package(\n      url: \"https://github.com/vapor/vapor\",\n      from: \"4.99.2\"\n    ),\n    .package(\n      url: \"https://github.com/swift-server/swift-openapi-vapor\",\n      from: \"1.0.1\"\n    ),\n    .package(\n      url: \"https://github.com/vapor/postgres-nio\",\n      from: \"1.19.1\"\n    ),\n    .package(\n        url: \"https://github.com/apple/swift-log\",\n        from: \"1.5.4\"\n    ),\n  ],\n  targets: [\n    .target(\n      name: \"EventAPI\",\n      dependencies: [\n        .product(\n          name: \"OpenAPIRuntime\",\n          package: \"swift-openapi-runtime\"\n        ),\n      ],\n      plugins: [\n        .plugin(\n          name: \"OpenAPIGenerator\",\n          package: \"swift-openapi-generator\"\n        )\n      ]\n    ),\n    .executableTarget(\n      name: \"EventService\",\n      dependencies: [\n        \"EventAPI\",\n        .product(\n          name: \"OpenAPIRuntime\",\n          package: \"swift-openapi-runtime\"\n        ),\n        .product(\n          name: \"OpenAPIVapor\",\n          package: \"swift-openapi-vapor\"\n        ),\n        .product(\n          name: \"Vapor\",\n          package: \"vapor\"\n        ),\n        .product(\n            name: \"PostgresNIO\",\n          package: \"postgres-nio\"\n        ),\n        .product(\n            name: \"Logging\",\n            package: \"swift-log\"\n        ),\n      ]\n    ),\n  ]\n)"
    },
    {
      "timestamp": "13:38",
      "title": "Adding logging to the createEvent method",
      "language": "swift",
      "code": "func createEvent(\n  _ input: Operations.createEvent.Input\n) async throws -> Operations.createEvent.Output {\n  switch input.body {\n  case .json(let event):\n    do {\n      try await self.postgresClient.query(\n        \"\"\"\n        INSERT INTO events (name, date, attendee)\n        VALUES (\\(event.name), \\(event.date), \\(event.attendee))\n        \"\"\"\n      )\n      return .created(.init())\n    } catch let error as PSQLError {\n      let logger = Logger(label: \"CreateEvent\")\n\n      if let message = error.serverInfo?[.message] {\n        logger.info(\n          \"Failed to create event\",\n          metadata: [\"error.message\": \"\\(message)\"]\n        )\n      }\n      \n      return .badRequest(.init())\n    }\n  }\n}"
    }
  ],
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "Forum: Programming Languages",
        "url": "https://developer.apple.com/forums/topics/programming-languages-topic?cid=vf-a-0010"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2024/10216/4/DB423F7B-5B55-47AE-958F-68C8BF6077A6/downloads/wwdc2024-10216_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2024/10216/4/DB423F7B-5B55-47AE-958F-68C8BF6077A6/downloads/wwdc2024-10216_sd.mp4?dl=1"
  },
  "relatedVideos": [
    {
      "id": "10170",
      "year": "2023",
      "title": "Beyond the basics of structured concurrency",
      "url": "https://developer.apple.com/videos/play/wwdc2023/10170"
    },
    {
      "id": "10171",
      "year": "2023",
      "title": "Meet Swift OpenAPI Generator",
      "url": "https://developer.apple.com/videos/play/wwdc2023/10171"
    }
  ],
  "extractedAt": "2025-07-18T10:47:30.738Z"
}