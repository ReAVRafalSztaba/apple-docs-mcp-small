{
  "id": "10157",
  "year": "2023",
  "url": "https://developer.apple.com/videos/play/wwdc2023/10157/",
  "title": "Wind your way through advanced animations in SwiftUI",
  "speakers": [],
  "duration": "",
  "topics": [
    "SwiftUI & UI Frameworks"
  ],
  "hasTranscript": true,
  "hasCode": true,
  "transcript": {
    "fullText": "♪ ♪ Person: Hello, and welcome to Wind your way through advanced animations in SwiftUI. I’m Tim, a member of the SwiftUI team.\n\nSwiftUI comes with a powerful set of animation tools that make your app shine, with animations that are interruptible, physics-based for believable motion, and deeply integrated throughout the framework.\n\nToday we’re going to talk about some exciting new tools that let you take animation in your app to the next level. Before we begin, let’s do a quick review of the animation tools that you already know in SwiftUI.\n\nYou might have seen this app that allows you to vote for your favorite kind of pet in other sessions.\n\nTo simplify this demo, I went ahead and removed all of the other options, because cats are clearly the best choice.\n\nAdding animation to your app is as easy as using \"withAnimation\" or adding an \"animation\" modifier, which gives you great behavior out of the box.\n\nAfter the state of your application changes, SwiftUI applies animations that interpolate from the previous state to the new state.\n\nBut with animation, as with life, sometimes the most rewarding experiences are found when you aren’t so focused on where you came from or where you’re going.\n\nSometimes you have to get off of the beaten path and focus on the journey itself to make something special. And some animations don’t simply animate from a previous state into a new state.\n\nToday, I’ll talk about some powerful new tools for building complex, multistep animations.\n\nRather than animating between two states, these animations can define multiple steps that happen in sequence. And they are especially great in two situations: repeating animations, that loop continuously while a view is visible... and event-driven animations, such as a view that pulses when an event occurs.\n\nIn this talk, I’m going to introduce a new family of APIs that makes animations like these even easier to build.\n\nI’ll start by introducing you to animation phases, which let SwiftUI automatically advance through a set of pre-planned states that make up your animation.\n\nNext, I’ll demonstrate how to take animations even further with keyframes. And finally, I’ll show some advanced tips and tricks to get the most out of this API. I think we’re ready to go. Let’s jump right in.\n\nWhen I’m not writing Swift, I like to get out trail running.\n\nTrail races can be very long. Ultramarathons can take a whole day, or even multiple days to finish, so I’ve been building an app to plan for upcoming events, and to help me remember important details during a run.\n\nNutrition is super important when you’re on the trail.\n\nUnfortunately, it can be easy to forget to eat late in a race as exhaustion sets in.\n\nI’ve added a feature to my app that reminds me to eat at the right times.\n\nHere, the reminder at the bottom of the screen is letting me know that I’m overdue for a meal. But there’s a problem.\n\nLater in a race, I can get so tired that I could miss a subtle indicator like this.\n\nI really don’t want to accidentally skip a meal, so I’ll add some motion to make this reminder stand out.\n\nLet’s focus on this one view. We want to give it an animated highlight effect to make it extra visible.\n\nTo make this view animate, we will apply the \".phaseAnimator\" modifier.\n\nWhen you use the phase animator modifier, you provide a sequence of states that define the individual steps in a multipart animation.\n\nSwiftUI then animates between these states automatically.\n\nIn this case, we’ll just be animating between two states: highlighted, and not highlighted, so we can simply use boolean values.\n\nNext, we’ll apply some modifiers to change the appearance of the view depending on the current phase.\n\nWe’ll start with an opacity modifier: we’ll make the view fully opaque when highlighted, and 50% transparent otherwise.\n\nAnd right away, the view starts animating. Let’s talk about what SwiftUI is doing on your behalf.\n\nIn our view, we provided two phases to the phase animator modifier: false, and true.\n\nWhen the view first appears, the first phase is active, causing the view to be 50% transparent.\n\nSwiftUI then immediately begins an animated transition to the next phase, where the view is fully opaque.\n\nThen when that animation is finished, SwiftUI advances again. We only have two phases, so we loop around to the beginning.\n\nThis causes our animation to cycle between the two states. Of course, you can also define animations that include more than two phases, and any number of additional view modifiers, which I'll demonstrate later on.\n\nNow while the view is animating, the effect is really subtle.\n\nInstead of changing the opacity, let’s try changing the foreground style.\n\nWe’ll use red when highlighted, and otherwise fall back to the primary foreground style.\n\nAnd that’s much more visible. The animations are a bit abrupt, though.\n\nBy default, SwiftUI uses a spring animation.\n\nAnd while springs are great for handling dynamic state changes, in this case we want a smoother, more consistent animation.\n\nWe can change the animation by adding a trailing \"animation\" closure.\n\nThe phase that is being animated to is passed in, in case we want to use a different animation for each phase. But in this case, I always want to use the same ease in out animation with a custom duration, to slow things down.\n\nNow, you wouldn’t typically use an animation with a duration of a full second for an interactive state change because you wouldn’t want to make people wait for an animation to finish.\n\nBut in this case, we are building an ambient effect, so it’s ok for things to move a bit slower, just like my pace if I miss that meal.\n\nNow that we’ve solved the urgent problem of mid-race nutrition, let’s look at one more way to use animation phases: animations that are triggered by events.\n\nI’ve been working on my app for a while, and I’ve added the ability to see which races my friends have run.\n\nThe emoji show reactions left by others.\n\nEvery runner sometimes asks themselves: why do I do this? Why did I sign up to run so many miles? And the least that our app can do is to feed the need for external validation by adding some excitement when someone else likes a race.\n\nWe’ll add an animation that plays every time someone adds a reaction.\n\nThe first thing that we will do is define the phases of our animation.\n\nUnlike in the previous example that simply alternated between two states, we want a more complex animation. An enum is a great way to define a list of steps for the animation.\n\nWe’ve added three cases: a case for the initial appearance, then cases to move the view up, and scale up the view.\n\nTo simplify our view body, we will add computed properties to this enum that define the different effects that we will apply. I want the view to jump up during the animation, so I’ve added a computed vertical offset property.\n\nI switch over the enum to return the right offset for each case.\n\nLikewise, I’ve added two additional computed properties to determine the view’s scale and foreground style.\n\nI won’t show the implementations here, but they also use a switch statement, just like the vertical offset property. Now, let’s get back to our view and add the animation.\n\nWe add the phaseAnimator modifier, but this time, we give it a \"trigger\" value.\n\nWhen we give the phase animator modifier a trigger value, it observes the value that you specify for changes.\n\nAnd when a change occurs, it begins animating through the phases that you specify.\n\nUsing the computed properties that we defined on the phase type, we apply modifiers to the view.\n\nAnd this animation technically does the right thing, but it doesn’t feel great.\n\nIt’s a bit sluggish.\n\nWe’ll customize the animation for each transition to get the effect that we want, including a couple of different spring animations.\n\nAnd this looks much better! But what if we want to take this animation even further? When someone has finished 50 or 100 miles on the trail, we want to give them an animation that leaves no doubt in their mind that all of those miles were worth it when they receive some well-deserved kudos. When you need even more control, there’s another powerful tool: keyframes. Next, I’ll show you how to use keyframes to define complex, coordinated animations with complete control over timing and movement. First, let’s talk about how keyframes are different from the phases that we have used so far.\n\nPhases define discrete states that are provided to your view one at a time.\n\nAnd SwiftUI animates between those states, using the same animation types that you already know, and this works really well for animations that can be modeled as discrete states.\n\nWhen a state transition occurs, all of the properties are animated at the same time.\n\nAnd then, when that animation is finished, SwiftUI animates to the next state.\n\nAnd this continues across all of the phases of the animation.\n\nBut what if we want to animate each property independently? That’s where keyframes come in.\n\nKeyframes let you define values at specific times within an animation. To demonstrate, I’ll animate this view, starting with a rotation effect.\n\nThe dots here indicate keyframes: angles to use at each point during the animation.\n\nWhen the animation plays back, SwiftUI interpolates values in between these keyframes, which we can then use to apply modifiers to the view.\n\nAnd keyframes allow you to independently animate multiple effects at the same time by defining separate tracks, each with their own unique timing.\n\nThis is really powerful, because you can use keyframes to drive any modifier in SwiftUI.\n\nIn this example, we are using keyframes to drive several other tracks, including vertical stretch, scale, and translation.\n\nLet’s get back to our view and see what this looks like in code.\n\nI already have an idea of the animation that I want to build, so my first step is to define the properties that will drive the animation. To do this, I’ll create a new struct containing all of the different properties that will be independently animated.\n\nKeyframes can animate any value conforming to the \"Animatable\" protocol.\n\nNotice that several properties use \"Double\", which now conforms to \"Animatable.\" Unlike phases, in which you model separate, discrete states, keyframes generate interpolated values of the type that you specify.\n\nWhile an animation is in progress, SwiftUI will provide you with a value of this type on every frame so that you can update the view.\n\nNext, we add the keyframeAnimator modifier.\n\nThis modifier is similar to the phase animator that we used earlier, but accepts keyframes.\n\nNotice that we provide an instance of our struct to use as the initial value.\n\nThe keyframes that we define will apply animations onto this value. Next, we’ll apply modifiers to our view for each of the properties on the struct.\n\nAnd finally, we’ll start defining keyframes.\n\nAs I mentioned, keyframes let you build sophisticated animations with different keyframes for different properties. To make this possible, keyframes are organized into tracks. Each track controls a different property of the type that you are animating, which is specified by the key path that you provide when creating the track. Here, we are adding keyframes for the scale property.\n\nWe first add a linear keyframe, repeating the initial scale value and holding it for 0.36 seconds. And if you’re wondering how I settled on 0.36, I found that duration by trying out different values to change the feel of the animation, and that’s an important point about keyframes. Making an animation that suits your app can take some experimentation.\n\nPreviews in Xcode can be a great way to fine-tune your animations. Next, we add a \"SpringKeyframe.\" This uses a spring function to pull the value toward the target.\n\nAnd we’ve specified a duration.\n\nFor a spring keyframe with a set duration, this means that the spring function will only animate the value for that duration.\n\nAfter that, interpolation will begin to the next keyframe. Finally, I’ll add another spring keyframe that animates the scale back to 1.0. The different kinds of keyframes control how values are interpolated. Alrighty, we’ve seen LinearKeyframe and SpringKeyframe.\n\nThere are actually four different types of keyframes. I’ll explain how they are different: LinearKeyframe interpolates linearly in vector space from the previous keyframe.\n\nSpringKeyframe, as its name suggests, uses a spring function to interpolate to the target value from the previous keyframe. CubicKeyframe uses a cubic Bézier curve to interpolate between keyframes. If you combine multiple cubic keyframes in sequence, the resulting curve is equivalent to a Catmull-Rom spline.\n\nAnd finally, MoveKeyframe immediately jumps to a value without interpolation. Each kind of keyframe supports customization to give you full control, and you can mix and match different kinds of keyframes within an animation.\n\nSwiftUI maintains velocity between keyframes to make sure your animation remains continuous.\n\nComing back to our view, we’re ready to add the next track.\n\nHere, we’ve used linear and spring keyframes to animate the vertical translation.\n\nRight before the view jumps up, it pulls back in anticipation.\n\nWe have modeled that with a spring keyframe that pulls the view down briefly before it moves up. This is looking good, but we still have two more properties to animate: vertical stretch, and rotation.\n\nWe’ll start with vertical stretch, and for this, we will use cubic keyframes. Again, this can take some trial and error to get right, but don’t hesitate to experiment with different ways to model animations using keyframes.\n\nThe squash and stretch really gives this animation a lot more energy.\n\nFinally, we’ll animate the rotation as well. And this is looking great.\n\nAnd those curves that we saw earlier? Those are a visualization of the animation that we just built. You can add additional tracks to apply any SwiftUI modifier.\n\nI’ve had a lot of fun exploring different combinations.\n\nlet’s take a moment to review the model of keyframes. Keyframes are predefined animations.\n\nThat means that they are not a replacement for normal SwiftUI animations in situations where the UI should be fluid and interactive.\n\nInstead, think of keyframes like video clips that can be played. They give you a ton of control, but there’s a tradeoff.\n\nBecause you specify exactly how an animation should progress, keyframe animations can’t gracefully retarget the way that springs can, so it’s generally best to avoid changing keyframes mid-animation.\n\nKeyframes animate a value of the type that you define, which you then use to apply modifiers to the view. You can use a single keyframe track to drive a single modifier, or a combination of different modifiers.\n\nIt’s up to you.\n\nAnd because the animation happens in terms of the value that you define, updates happen on every frame, so you should avoid performing any expensive operations while applying a keyframe animation to the view.\n\nFinally, I’ll demonstrate how how you can do even more with keyframes.\n\nMy app includes a race map, showing the route that each leg takes.\n\nI want to add an animation that automatically zooms in and follows the course.\n\nThankfully, MapKit now allows me to use keyframes to move the camera. Here, I’m using a \"Map\" view to show the course.\n\nMy view already has a route, which is a model that contains all of the coordinates along one leg of the race.\n\nTo build our tour, we’ll add a state property and a button to change it.\n\nFinally, we use the new \"mapCameraKeyframeAnimator\" modifier. We give it the trigger value, then add keyframes, just like we used for the heart icon in the previous example.\n\nEvery time the trigger value changes, maps will use these keyframes to animate.\n\nThe final value of the keyframes determines the camera value that is used at the end of the animation.\n\nFinally, we hit the button, and the tour starts.\n\nIf the user performs a gesture while animating, the animation will be removed and the user will have full control over the camera.\n\nBy independently animating the center coordinate, heading, and distance, we’re able to smoothly animate along this course then zoom back out for a bird’s-eye view.\n\nFinally, I’d like to demonstrate how keyframes can be manually evaluated to drive any kind of effect that you can think of.\n\nWe’ve seen the \"keyframeAnimator\" modifier. Outside of the modifier, you can use the \"KeyframeTimeline\" type to capture a set of keyframes and tracks. You initialize this type with an initial value, and the keyframe tracks that define your animation, just like with the view modifier.\n\nKeyframeTimeline provides API that gives you the duration, which is equal to the duration of the longest track.\n\nAnd you can calculate values for any time within the range of the animation.\n\nThis makes it easy to visualize keyframes with Swift Charts, which I used for the curve visualizations that I showed earlier. This also means that you can use keyframe-defined curves however you want, or to creatively combine keyframes with other APIs, for example, with a geometry proxy to scrub keyframe-driven effects using scroll position, or with a \"TimelineView\" to update based on time.\n\nAnd if you’re not sure when you would use this, that’s ok, it’s an advanced tool, and most developers will want to stick to the view modifier.\n\nBut it’s here as a building block, and I’m excited to see what creative ways you find to integrate it into your app. That completes our journey.\n\nI hope you’re excited to use this new family of API.\n\nRemember: use phases for chained animations.\n\nThey use all of the existing animation types that you already know, so you can get up and running quickly.\n\nUse keyframes for more complex animations where you need complete control.\n\nAnd finally: have fun exploring.\n\nThe world of animation is exciting, and I hope these new tools lead you, and your app, somewhere new.\n\nThanks! ♪ ♪",
    "segments": []
  },
  "codeExamples": [
    {
      "timestamp": "0:42",
      "title": "Scale Animation",
      "language": "swift",
      "code": "struct Avatar: View {\n    var petImage: Image\n    @State private var selected: Bool = false\n\n    var body: some View {\n        petImage\n            .scaleEffect(selected ? 1.5 : 1.0)\n            .onTapGesture {\n                withAnimation {\n                    selected.toggle()\n                }\n            }\n    }\n}"
    },
    {
      "timestamp": "3:13",
      "title": "Boolean Phases",
      "language": "swift",
      "code": "OverdueReminderView()\n            .phaseAnimator([false, true]) { content, value in\n                content\n                    .foregroundStyle(value ? .red : .primary)\n            } animation: { _ in\n                .easeInOut(duration: 1.0)\n            }"
    },
    {
      "timestamp": "6:20",
      "title": "Custom Phases",
      "language": "swift",
      "code": "ReactionView()\n    .phaseAnimator(\n        Phase.allCases, \n        trigger: reactionCount\n    ) { content, phase in\n        content\n            .scaleEffect(phase.scale)\n            .offset(y: phase.verticalOffset)\n    } animation: { phase in\n        switch phase {\n        case .initial: .smooth\n        case .move: .easeInOut(duration: 0.3)\n        case .scale: .spring(\n            duration: 0.3, bounce: 0.7)\n        } \n    }\n\nenum Phase: CaseIterable {\n    case initial\n    case move\n    case scale\n\n    var verticalOffset: Double {\n        switch self {\n        case .initial: 0\n        case .move, .scale: -64\n        }\n    }\n\n    var scale: Double {\n        switch self {\n        case .initial: 1.0\n        case .move: 1.1\n        case .scale: 1.8\n        }\n    }\n}"
    },
    {
      "timestamp": "9:48",
      "title": "Keyframes",
      "language": "swift",
      "code": "ReactionView()\n    .keyframeAnimator(initialValue: AnimationValues()) { content, value in\n        content\n            .foregroundStyle(.red)\n            .rotationEffect(value.angle)\n            .scaleEffect(value.scale)\n            .scaleEffect(y: value.verticalStretch)\n            .offset(y: value.verticalTranslation)\n        } keyframes: { _ in\n            KeyframeTrack(\\.angle) {\n                CubicKeyframe(.zero, duration: 0.58)\n                CubicKeyframe(.degrees(16), duration: 0.125)\n                CubicKeyframe(.degrees(-16), duration: 0.125)\n                CubicKeyframe(.degrees(16), duration: 0.125)\n                CubicKeyframe(.zero, duration: 0.125)\n            }\n\n            KeyframeTrack(\\.verticalStretch) {\n                CubicKeyframe(1.0, duration: 0.1)\n                CubicKeyframe(0.6, duration: 0.15)\n                CubicKeyframe(1.5, duration: 0.1)\n                CubicKeyframe(1.05, duration: 0.15)\n                CubicKeyframe(1.0, duration: 0.88)\n                CubicKeyframe(0.8, duration: 0.1)\n                CubicKeyframe(1.04, duration: 0.4)\n                CubicKeyframe(1.0, duration: 0.22)\n            }\n            \n            KeyframeTrack(\\.scale) {\n                LinearKeyframe(1.0, duration: 0.36)\n                SpringKeyframe(1.5, duration: 0.8, spring: .bouncy)\n                SpringKeyframe(1.0, spring: .bouncy)\n            }\n\n            KeyframeTrack(\\.verticalTranslation) {\n                LinearKeyframe(0.0, duration: 0.1)\n                SpringKeyframe(20.0, duration: 0.15, spring: .bouncy)\n                SpringKeyframe(-60.0, duration: 1.0, spring: .bouncy)\n                SpringKeyframe(0.0, spring: .bouncy)\n            }\n        }\n\nstruct AnimationValues {\n    var scale = 1.0\n    var verticalStretch = 1.0\n    var verticalTranslation = 0.0\n    var angle = Angle.zero\n}"
    },
    {
      "timestamp": "15:22",
      "title": "Map Keyframes",
      "language": "swift",
      "code": "struct RaceMap: View {\n    let route: Route\n\n    @State private var trigger = false\n\n    var body: some View {\n        Map(initialPosition: .rect(route.rect)) {\n            MapPolyline(coordinates: route.coordinates)\n                .stroke(.orange, lineWidth: 4.0)\n            Marker(\"Start\", coordinate: route.start)\n                .tint(.green)\n            Marker(\"End\", coordinate: route.end)\n                .tint(.red)\n        }\n        .toolbar {\n            Button(\"Tour\") { trigger.toggle() }\n        }\n        .mapCameraKeyframeAnimation(trigger: playTrigger) { initialCamera in\n            KeyframeTrack(\\MapCamera.centerCoordinate) {\n                let points = route.points\n                for point in points {\n                    CubicKeyframe(point.coordinate, duration: 16.0 / Double(points.count))\n                }\n                CubicKeyframe(initialCamera.centerCoordinate, duration: 4.0)\n            }\n            KeyframeTrack(\\.heading) {\n                CubicKeyframe(heading(from: route.start.coordinate, to: route.end.coordinate), duration: 6.0)\n                CubicKeyframe(heading(from: route.end.coordinate, to: route.end.coordinate), duration: 8.0)\n                CubicKeyframe(initialCamera.heading, duration: 6.0)\n            }\n            KeyframeTrack(\\.distance) {\n                CubicKeyframe(24000, duration: 4)\n                CubicKeyframe(18000, duration: 12)\n                CubicKeyframe(initialCamera.distance, duration: 4)\n            }\n        }\n    }\n}"
    },
    {
      "timestamp": "16:26",
      "title": "KeyframeTimeline",
      "language": "swift",
      "code": "// Keyframes\nlet myKeyframes = KeyframeTimeline(initialValue: CGPoint.zero) {\n    KeyframeTrack(\\.x) {...}\n    KeyframeTrack(\\.y) {...}\n}\n\n// Duration in seconds\nlet duration: TimeInterval = myKeyframes.duration\n\n// Value for time\nlet value = myKeyframes.value(time: 1.2)"
    }
  ],
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2023/10157/4/11302D30-B890-47AB-B8B0-CA3D4A8F136F/downloads/wwdc2023-10157_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2023/10157/4/11302D30-B890-47AB-B8B0-CA3D4A8F136F/downloads/wwdc2023-10157_sd.mp4?dl=1"
  },
  "relatedVideos": [
    {
      "id": "10156",
      "year": "2023",
      "title": "Explore SwiftUI animation",
      "url": "https://developer.apple.com/videos/play/wwdc2023/10156"
    },
    {
      "id": "10148",
      "year": "2023",
      "title": "What’s new in SwiftUI",
      "url": "https://developer.apple.com/videos/play/wwdc2023/10148"
    }
  ],
  "extractedAt": "2025-07-18T10:53:03.871Z"
}