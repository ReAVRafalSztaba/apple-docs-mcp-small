{
  "id": "232",
  "year": "2025",
  "url": "https://developer.apple.com/videos/play/wwdc2025/232/",
  "title": "Verify identity documents on the web",
  "speakers": [],
  "duration": "",
  "topics": [
    "App Services"
  ],
  "hasTranscript": true,
  "hasCode": false,
  "transcript": {
    "fullText": "Hello! My name is Erik, and I am an engineer on the Wallet & Apple Pay team. Hi, I am Marcos, a standards engineer on the WebKit team. Today, we are here to show you how you can streamline online identity verification flows using digital identity documents. Whether you are a website developer who is looking to enhance their identity verification flows, an app developer who wants to enable their app to provide proof of identity, or just someone interested in digital identity, this session is for you.\n\nDigital Identity Documents are becoming increasingly common for being able to represent a wide range of identification documents, including driver’s licenses and other government issued IDs. These Digital Identity Documents come with the promise of some key benefits over physical documents: one being that they are easier to use online.\n\nToday, if I need to prove my identity online I often need to upload photos of my physical ID.\n\nThis is not a great solution for either the user or the business that is attempting to verify the ID. For the user, this is a poor experience.\n\nThey need to first locate their physical ID. Then, they need find a suitable background to take a photo against, while also ensuring that this photo is legible and not blurry. On the other hand, the business needs to build a complex solution that is able to process these photos and determine if they are authentic. This is a difficult problem to solve.\n\nMobile documents, or “mdocs”, are one such example of a digital identity document format that aims to solve this problem. Mdocs come with some unique properties: For one, they are defined in the ISO 18013-5 standard. This enables them to be interoperable across different platforms.\n\nThey also offer a more private user experience. If a requestor only needs to verify my name and age, then that is the only information that I should need to share with them. With mdocs, this is possible.\n\nAnd finally, they offer greater security features than a physical ID that make them more trustworthy. For example, the information in an mdoc is cryptographically signed by its issuer, so a business can trust that the information they receive is legitimate.\n\nIDs in Apple Wallet are examples of documents that are built on the mdoc format and accompanying ISO 18013 standards.\n\nToday, people can present their ID in Apple Wallet in person at select airport security checkpoints in the U.S., at select businesses and venues, and at Apple Store locations across the U.S. People are also able to use their ID in select apps that leverage our Verify with Wallet API. If you have an app and would like to adopt the Verify with Wallet API to perform identity verification, check out the “What’s new in Wallet and Apple Pay” session from WWDC 22.\n\nWe have also seen some jurisdictions build document provider apps on the mdoc format. These apps allow users to store and use their identity documents in person. To mimic a local driving authority, we’ve built a demo app which manages driver’s licenses. We’ve aptly named it: Local Driving Authority.\n\nThis year, we are excited to announce some enhancements for this class of document provider apps, as well as ID in Wallet.\n\nStarting in our upcoming releases, we are introducing support for the W3C’s Digital Credentials API to request mdocs from Safari and WebKit. Let me walk you through how it works.\n\nLet’s say I am trying to rent a spaceship from Spaceship Rentals. I’m in Safari, and I’ve already selected my spaceship and travel itinerary through their website. Now I am on the step where they need to verify my identity. I will go ahead and tap the “Verify Identity” button. This button triggers the JavaScript Digital Credentials API. I have my Driver’s License stored in two apps: the Local Driving Authority app and Apple Wallet. This app selector UI allows me to pick which app I would like to use for identity verification.\n\nFor now, I will use Apple Wallet.\n\nWe now see the consent sheet that appears for me to review. I can see who is requesting to see details from my ID through the brand icon and name. And, I can also see the particular elements they are requesting and whether they intend to store this information or not.\n\nI will go ahead and approve this identity verification by authorizing with Face ID. And now we see the information has been presented back to the Spaceship Rentals website. Isn’t that cool? Hey Erik, that worked great from an iPhone. But what if I was on a Mac? Excellent question. Let me show you.\n\nHere I am again in Safari, but this time on my Mac. I am on the same Spaceship Rentals website I used before.\n\nI’ll go ahead and click the Verify Identity button. I get prompted to continue on my nearby iPhone.\n\nA notification then appears on my iPhone that allows me to complete my identity verification. I will tap it, and see the same option to pick which app I want to use. I will use Apple Wallet again. And the same consent sheet appears: where I can see who is making this request, which elements they are requesting, and whether they will store this information. I’m good with this, so I will confirm with Face ID.\n\nAwesome. We now see that the document information has been sent back to Spaceship Rentals on my Mac.\n\nNot only did we implement support for Safari on the Mac, but we also implemented standardized support for cross-platform identity verification to other operating systems and browsers. So, even if I am renting my spaceship from another platform or browser, I can still use my ID from iPhone. I’ll do so by scanning the QR code that the browser presents.\n\nThe flows you just saw were built on a set of standards. It uses the W3C’s Digital Credentials API, specifically with the request profile defined in ISO 18013-7 Annex C and ISO 18013-5.\n\nThe FIDO CTAP protocol is used for the cross platform flow. This means that any code that a website writes to integrate with Apple platforms can work with other browsers and apps that choose to adopt these same standards.\n\nThe experience is built to be cross-platform from the ground up. This includes support for iPhone, iPad and Mac, as well as other browsers and operating systems.\n\nNo matter where a user is browsing on the internet, they can use the documents on their iPhone for identity verification.\n\nAnd finally, we built a set of Document Provider APIs for Apple platforms. These APIs allow apps such as the Local Driving Authority app to surface as an option during an identity verification flow.\n\nLet me break down the demos you just saw, and explain how it works under the hood.\n\nmdoc verification on the web starts with a user visiting a website through a browser.\n\nThe website then reaches out to its server, for it to build and sign an mdoc request.\n\nOnce the website has its request, it is ready to use the Digital Credentials API. When the user performs an action to begin identity verification, the website will call the Digital Credentials API with the request.\n\nThe browser will then forward that request to the underlying operating system. The OS uses a combination of the request and user interaction to determine a document source to respond to the request.\n\nThis could be a document provider app installed locally on the device, or potentially even another device altogether.\n\nOnce decided, the request is passed off to the appropriate document source for handling. The user will then authorize the release of their document.\n\nThen an encrypted response is returned from the document source, all the way back to the requesting website. Finally, the website then sends this response to its server, for decryption and validation.\n\nZooming out a bit, we can get a clearer picture of the various components that make up an online mdoc verification on Apple platforms. There are two distinct entry points for those of you who wish to participate in this flow. If you are a developer for a document provider app on iOS, then you may be interested in the Document Provider API. This API will allow your iOS app to be surfaced as an option to complete an online mdoc verification.\n\nIf you are a website interested in performing identity verifications online, you will want to implement the W3C’s Digital Credentials API, and associated request and response handling logic. Let me take some time to dive into this flow.\n\nAt a high level, there are three steps a website must take in order to request an mdoc.\n\nOne, when the user visits the website for identity verification, it must ask its server to build and sign a document request.\n\nTwo, once the user is ready to perform ID verification, it must pass the request to the browser through the W3C’s Digital Credentials API.\n\nAnd finally, upon receiving a response, the website must send the encrypted response to its server for decryption and validation.\n\nMarcos, you look like an eager Full Stack developer. Why don’t you walk us through how the Spaceship Rentals website can integrate an Identity Verification step into their checkout flow? I’d love to.\n\nFirst, let me show you how to build and sign a request using the W3C’s Digital Credentials API.\n\nThe request we will build will conform to what is standardized in ISO 18013-7, Annex C.\n\nThe request can be broken up into two parts: A Device Request and the Encryption Information. Let’s dive into each one. The Device Request contains two crucial pieces of information. It contains a list of Document Requests, which is where I can declare which document I want to request from the user. Spaceship Rentals wants to verify a Driver’s License, so I’ll put in the docType string for mobile driver’s licenses into the structure. Next, I add the particular properties of the driver’s license I want to request. This is done through a standardized set of namespaces and element identifiers. In this case, I’ll request the given and family name, if the person is over 21, the user’s portrait photo, and their driving privileges.\n\nThe other important parameter in the device request is what is called the “Reader Authentication All” list. This is where the website signs the request. We will use this property in a bit, so I will leave it empty for now. The second part of the request is the Encryption Information. This is where I can place the parameters that are used by the Document Provider to encrypt the Response.\n\nI will need to generate a nonce to be used in encryption. The nonce is an important security feature that helps protect us against replay attacks. I will also generate a recipient encryption key-pair. This key pair will be used in the encryption of the document response. I’ll place the recipient public key in the Encryption Information Structure, and I’ll hold onto the recipient private key to use for later. This will allow me to eventually decrypt the document response, so it is important that I keep it safe on my server. Together that makes up a full request.\n\nNow that I built the request I can move onto signing it. Different document provider apps may have different requirements for signing the request. I want Spaceship Rentals to accept an ID in Apple Wallet, so I will first start with signing the request for Wallet.\n\nBefore I can sign the request, I need to get a signing certificate from Apple Business Connect. This is done by first generating a signing-key-pair, and then submitting a Certificate Signing Request to Apple Business Connect. With the certificate in hand, I can now move on to what I need to do at runtime.\n\nNext, I need to generate a Session Transcript using two pieces of information: the origin URL of my website, and the Encryption Information structure I generated earlier. This Session Transcript is used for later operations as well. Once I have the session transcript, I am ready to sign. To do that, I will use the signing key pair and signing-certificate that I received from Apple Business Connect.\n\nThe result is a Signed Authentication Structure.\n\nI can then place this signed authentication structure for Wallet into the Reader Authentication All list. This is a mechanism defined in ISO 18013-5.\n\nNote that other document provider apps may have slightly different requirements when it comes to signing the request. I want to accept documents from within the Local Driving Authority app, but they require that I sign the request with a completely different certificate that they issued to me.\n\nHowever, as the Reader Authentication All list is a list, I can sign my request multiple times. So, I have created a new signed authentication structure using the certificate from the Local Driving Authority. I can insert it alongside the signed authentication structure for Wallet.\n\nNow that I have the request, the next step is to pass it to the browser via the W3C’s Digital Credentials API in JavaScript.\n\nWe can now take the request data that we build on the server and put it in into the request dictionary. Note I also define that this is an “mdoc” request through the “protocol” property using the standardized “org-iso-mdoc” string. We are now ready to call the navigator.credentials.get method and await its response. This method call causes the browser to present the system UI from where a user can select a digital credential.\n\nNote that calling the get method must be done through a user gesture, such as a mouse click or a button press. Once we receive the response, we can send it back to the server for decryption. Responses are JSON-serializable, so they can be easily sent back to the server using either the Fetch API or XHR. Finally, if anything goes wrong, the W3C’s Digital Credentials API provides a rich set of exceptions to help your program recover. Alternatively, you may choose to fallback to an existing identity verification method, such as an ID image scan uploaded via a HTML form.\n\nAlright, awesome! Let’s test out our code to make sure that it works.\n\nFantastic! When I press the “Verify Identity” button, I can see the system UI appear. That means our request is working. And, I see both Wallet and the Local Driving Authority app as an option for the user to pick from. What do you think, Erik? This looks great so far Marcos. Before we move onto the next step, let me talk about the security of this flow.\n\nWhen handling information as sensitive as ID data, it is important to ensure that you have the right security protections in place. You may be asking some of the following questions: Who is requesting the ID data? Is that ID data protected? Is it authentic? Or, has it been copied? Let me go over each of the security protections that exist within the standards to help answer these questions.\n\nYou’ve already seen request authentication. This is how the requesting website can identify themselves, and how the document provider apps can help users understand who is performing the request. This is done through a certificate that is used to sign the request.\n\nNext is response encryption. The response is encrypted end to end using a key generated by the requesting website’s server. This prevents other parties from being able to read the identity data, including the browser and the operating system.\n\nIssuer authentication is used to prove the authenticity of the identity data. This allows the requesting website to determine who issued the data, and whether they should be trusted.\n\nIt also prevents modification of the data that is returned.\n\nAnd finally, mdoc authentication prevents duplication of the data. This allows the requesting website to verify that the mdoc they received is from the same device that it was issued to. This prevents the possibility of duplicating the mdoc across multiple devices.\n\nMarcos, why don’t you show us how these security properties come into play when handling the response? Sure! Let’s do it.\n\nThe last thing I need to do to finish the Spaceship Rentals implementation is to handle the response coming back from the Document Provider. As with the request, the JavaScript response format is defined in ISO 18013-7, Annex C. The response also contains two properties. One is the ciphertext that I need to decrypt. And the other is the key that the Document Provider App generated as part of its encryption process. The ciphertext is encrypted using hybrid public key encryption, or HPKE, which is defined in RFC-9180.\n\nThe inputs for the decryption include both the ciphertext and the sender’s public key from the response.\n\nIt also includes the recipient’s private key that we generated earlier on the server when building the request. And the final input is the same session transcript that we generated earlier for signing the request. The result of this operation is a decrypted Device Response.\n\nEach document in the response contains a Mobile Security Object. This object is immutable and is signed by the issuer. And it contains information that is crucial for validating that the returned data is authentic. The Mobile Security Object is authenticated through the Issuer Authentication structure.\n\nThis structure contains a Document Signer Certificate that first needs to be validated. This is done by chaining it up to a Trusted Issuing Authority root certificate that the issuer publishes. The Spaceship Rentals server maintains a list of trusted Issuing Authority root certificates to determine which mdocs to accept. If a Document Signer Certificate is not trusted, then we should discard the response. After verifying the certificate, I now need to validate the signature. Once the Issuer’s Authentication Structure is validated, I can then move on to validating the Mobile Security Object. There are a number of validations to be done here, and most importantly I need to validate the authenticity of the elements that were returned. These returned elements can be found in the “Issuer Namespaces”.\n\nFor example, here we can see that the given name of “Kelly” was returned. But before I can use it, I need to prove that this element has not been tampered with. To do that, we compute a hash digest on the entire element information structure. And then we compare the digest against a particular digest that exists in the Mobile Security Object. I can find which digest to compare against by using the digest identifier provided in the element structure. Once the digests are successfully compared, I can be confident that the data is authentic. Finally, I need to validate the mdoc’s authentication. The Mobile Security Object contains a Device Public Key. That key is unique to the device that the document was issued to. I will then use that key to validate the Device Authentication structure. Doing so confirms that the document came from the device it was issued to. And that wraps up the handling of the response.\n\nWhat we've covered here is an overview of the work required to validate the response. For the precise validation procedure you need to perform, refer to the ISO 18013-5 standard. Now I will test the rest of the flow.\n\nI will select Wallet to respond to the Spaceship Rentals request, and then authenticate.\n\nWe now see that the flow works, and the information has been decrypted and validated by Spaceship Rentals. We can now take our rented spaceship out for a spin! Erik, what did you think? Nice work! Let me recap with some key benefits that were highlighted during this implementation. First, the Digital Credentials API offers the best in class experience for users who need to verify their identity on the web, hands down. Integrating with the API means your website gets access to user friendly platform features such as the cross device flows.\n\nSecond, websites requesting mdocs are implementing a common set of standards. This means the code you write can work across any browser that supports those same standards, enabling broader interoperability.\n\nAnd finally, the API is simply more secure. In addition to the protections we mentioned earlier, this API enables document provider apps to perform domain validation on the requesting website. This makes phishing attacks more difficult to perform.\n\nAnd that wraps up the implementation required to integrate with the W3C’s Digital Credentials API. We built and signed a request, sent it via the Digital Credentials API, and handled the encrypted response.\n\nLet me shift gears away from the work the website needs to do to request an mdoc, and next focus on the Document Provider API that we’ve built to enable apps to participate in online mdoc verification.\n\nWhile I was performing identity verification with Spaceship Rentals before, I had the option to use a second app: the Local Driving Authority app. This is that sample app that we built that can store my driver’s license.\n\nIf I go ahead and pick the Local Driving Authority app, we can see this authorization UI appear.\n\nThis UI is provided by a UI App Extension that the app implements. If you already have an iOS app that provides documents, you will be able to easily add this extension to your app to enable online identity verification.\n\nThis experience is powered by the addition of a new framework focused around identity documents: IdentityDocumentServices. Let me go over how it works.\n\nThe first step happens outside of your app extension. Whenever your app provisions an identity document that can be presented, you will register that document with iOS. This makes it available to be shown in the selection UI. When you register your document, you will provide the type of that document, and which certificate authorities you trust to authorize the requesting website.\n\niOS will then persist this document registration locally on the device.\n\nNext comes the identity verification flow. The user will trigger this flow.\n\niOS then uses the stored document registrations to determine which apps can respond to the request.\n\nThen, it displays that selection UI we saw earlier.\n\nThe user then selects which app they would like to use.\n\nAnd then, iOS sends a partial request over to the document provider app to use.\n\nYou might be asking yourself: “what’s a partial request?”.\n\nWell, the incoming ISO 18013 device request contains a number of properties that contain raw, parseable data blobs. These are encoded as such in order to allow document providers to accurately compute and validate signatures.\n\nHowever, parsing a raw data blob from a website without any guaranteed user interaction could pose a threat for OS components responsible for user data.\n\nIn order to mitigate this, the system instead parses a portion of this request from within a secure sandbox.\n\nBefore parsing the request, the OS validates the signatures in the request first. The result is a partial request that contains information necessary to build a UI, such as the document requests and the authentication certificates.\n\nYour app will receive this partial request, which you can use to build UI to be displayed in your app extension.\n\nThen, once the user has authorized for the release of their document, the full ISO 18013 device request is released to the document provider app for use.\n\nAt this point, the document provider app compares the two requests to make sure they are consistent, then, it validates the signatures in the ISO 18013 device request.\n\nOnce validated, the app can build its document response, and encrypt it to the requesting website.\n\nThe response is then sent back to iOS, which forwards it along to the website.\n\nMarcos, do you know any Swift? I know enough to be dangerous. Great. Our Local Driving Authority needs some help with their app, can you help them integrate the Document Provider APIs? Absolutely. Let’s do this.\n\nOk! The first thing we need to implement is the registration step. This step should happen once the Local Driving Authority app has created an mdoc. All registration actions happen through the IdentityDocumentProviderRegistrationStore type, so I will first initialize a store.\n\nNext I will instantiate a MobileDocumentRegistration object. This object contains the information for registering an mdoc. Local Driving Authority issues driver’s licenses, so I will put the standardized document type string for mobile driver’s licenses. You can see that by the “mDL” mobileDocumentType string. Next, I can indicate which authority key identifiers I trust. This allows my app to be surfaced at the appropriate moments. If a request comes in that is not signed by one of these certificate authorities, then my app will be hidden in the selection sheet. Next I can provide a document identifier. This identifier can easily link back to the storage I have for my mdoc in my app.\n\nOnce my registration object has been created, I can call the addRegistration() method to register it with iOS.\n\nI’ve given users in my app the ability to remove their driver’s licenses. If they remove their driver’s license, I want to ensure that my app is no longer shown as an option. I can accomplish this by removing the registration that matches the deleted driver’s license.\n\nThis is done through the removeRegistration() method. I will pass the document identifier that matches the mdoc’s registration that I created previously.\n\nThere may be instances where my app needs to query the registrations that are currently stored by the system. The registrations property allows me to do just that. I can then iterate through the returned list of registrations to inspect them.\n\nNext comes adding the UI App Extension to my app.\n\nI can do this by adding a new target to my Xcode project, and selecting the “Identity Document Provider” template.\n\nThis will generate the extension for me to implement. There are two places where code can be filled in. The performRegistrationUpdates() method is called when a user authorizes Local Driving Authority app to perform an online identity verification. This method should check all mdocs that are stored in my app’s storage, and make sure that they are registered with iOS. The other place to implement is the `ISO 18013 Mobile Document Request Scene` content. This is where I can build the authorization UI that is shown when the user selects my app. To implement the UI, I will define a RequestAuthorizationView and pass the context I receive into it.\n\nLet’s see the implementation of this new view.\n\nThe view takes in an ISO18013MobileDocumentRequestContext, which is provided by the app extension. This type contains the request information and the callback method required to send a response.\n\nWhen implementing the body of this view, there are three main pieces of the UI.\n\nI need to build a view that contains information about who is performing the request and what they are requesting. For this, I’ll define a RequestInfoView that takes the request I receive from the context object. That’s the partial request that Erik spoke about earlier.\n\nNext I need to implement the button for the user to “Accept” the identity verification. This involves calling an acceptVerification() method that I defined on my view. Let's implement that.\n\nWhen I am ready to accept the verification, I will call the sendResponse() method on the request context object. This method accepts a closure. The closure receives a rawRequest parameter. This is where the ISO 18013 Device Request comes in.\n\nOnce the device request is received, I need to compare it against the partial request from the request context object.\n\nNow I need to validate the signature of the raw request.\n\nThis is to help me confirm that the website is the one that my app trusts.\n\nOnce the request looks good, I will build and encrypt the document response. And finally, I will return the resulting response data from the closure. This returned response is then sent back to the requesting website.\n\nThat wraps up the implementation of the acceptVerification() method.\n\nThe last thing we need to complete our UI is a “Decline” button. To implement this, we just have to call the request context’s cancel method.\n\nAnd that’s the basic implementation of the Local Driving Authority app, Erik. Thanks Marcos.\n\nSo that’s our tour of the online mdoc verification flow. The two APIs we covered provide plenty of flexibility to enable a wide range of identity verification experiences on your websites. We think it is the best solution for identity verification on the web.\n\nBefore you head out, here are some next steps for you to begin integrating with the Digital Credentials API.\n\nIf you are a website developer interested in requesting identity information from IDs in Wallet, consider registering with Apple Business Connect and receive a certificate. If you want to request identity information from other apps, such as a local government’s app, check with them on additional onboarding requirements. Instead, if you are an app developer interested in providing identity documents, implement the Identity Document Provider app extension within your app. And regardless of which API you are using, check out the various standards we have discussed throughout this session. These are your sources of truth, and will help you understand the nitty gritty of the implementation process.\n\nThank you very much for watching our session and have a great WWDC!",
    "segments": []
  },
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "Implementing as an identity document provider",
        "url": "https://developer.apple.com/documentation/IdentityDocumentServices/Implenting-as-an-identity-document-provider"
      },
      {
        "title": "Requesting a mobile document on the web",
        "url": "https://developer.apple.com/documentation/IdentityDocumentServices/Requesting-a-mobile-document-on-the-web"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2025/232/4/c1386ee3-b8b0-4086-99fe-9f05e4b1cd17/downloads/wwdc2025-232_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2025/232/4/c1386ee3-b8b0-4086-99fe-9f05e4b1cd17/downloads/wwdc2025-232_sd.mp4?dl=1"
  },
  "relatedVideos": [
    {
      "id": "235",
      "year": "2025",
      "title": "Learn more about Declarative Web Push",
      "url": "https://developer.apple.com/videos/play/wwdc2025/235"
    },
    {
      "id": "233",
      "year": "2025",
      "title": "What’s new in Safari and WebKit",
      "url": "https://developer.apple.com/videos/play/wwdc2025/233"
    },
    {
      "id": "10041",
      "year": "2022",
      "title": "What’s new in Wallet and Apple Pay",
      "url": "https://developer.apple.com/videos/play/wwdc2022/10041"
    }
  ],
  "extractedAt": "2025-07-18T09:10:54.760Z"
}