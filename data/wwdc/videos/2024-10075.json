{
  "id": "10075",
  "year": "2024",
  "url": "https://developer.apple.com/videos/play/wwdc2024/10075/",
  "title": "Track model changes with SwiftData history",
  "speakers": [],
  "duration": "",
  "topics": [
    "App Services"
  ],
  "hasTranscript": true,
  "hasCode": true,
  "transcript": {
    "fullText": "Salutations! My name is David, and I’m an engineer on the SwiftData team. SwiftData History is a new technology that lets your app track modifications to its data. You can use History to build features that need to process these changes, like syncing with your server, or responding to changes from an app extension. In this video, I’ll cover the fundamentals of SwiftData History, and build a new feature in my sample app using History transactions and changes.\n\nFinally, I’ll cover some considerations for supporting History with a custom data store.\n\nLet’s talk about what SwiftData History is, and why you might want to use it.\n\nAs people use an app, the content stored by SwiftData changes over time. For example, when the app launches, it may create some models, or insert models fetched from a remote server.\n\nWhen the model context is saved, all pending changes are saved into the data store.\n\nOver time, some of these models may change, or be deleted as someone uses and interacts with your app, and its different functions.\n\nAt any time, your app can query the data in the store. However, a query’s results represent what’s currently in the data store. Without history or manual diffing, there’s no way to know from a query which models may have been added, deleted, or updated since a previous one. SwiftData History provides an easy and efficient way to track the changes in your data store over time.\n\nYou can use this to build a number of different features. For example, you may want to have a time-ordered log of changes that occur when the app is offline. Later, these changes can be efficiently synced with a remote server.\n\nYou may want to discover changes in the data that occurred in a different process, like a widget extension, so that you can reflect those changes properly in your app.\n\nOr, you may simply want an efficient way to know which models were inserted or deleted since a previous query, in order to update some state at runtime. Let’s explore how it works.\n\nSwiftData History lets your app query and process changes in the order that they occurred.\n\nEach time your model is saved, it records a transaction, which contains metadata about all of the changes.\n\nSwiftData History is composed of Transactions and Changes. Transactions group together all of the changes that occurred in the data store on a boundary, such as on a ModelContext save. Transactions are ordered by when they occurred.\n\nWithin a transaction, the set of changes it contains also preserve the order in which each change occurred. Each change represents a model that has been inserted, updated, or deleted and are parameterized by a PersistentModel. This allows references to properties of the PersistentModel using KeyPaths.\n\nSwiftData History uses the concept of a token, which acts as a bookmark for transactions in History. A token can help your app keep track of the last transaction it processed in the stream of History.\n\nTokens are only valid for the data stores they are associated with. In SwiftData, history information can be deleted through the model context.\n\nWhen that happens, tokens from deleted parts of history become expired and cannot be used for fetches.\n\nSwiftData History operations involving an expired token will throw a historyTokenExpired error. If this happens, discard the token, as it is no longer valid and fetch a new one.\n\nWhen models are deleted, the data in the model is discarded. This means that essential data like identifiers might be lost and don’t provide enough information to your app when processing history information. To address this, SwiftData History lets you preserve specific attributes on a model. When the model is deleted, these attributes are preserved as tombstone values, and let you process the history information for the deleted models.\n\nAttributes in a PersistentModel that have been marked with the modifier .preserveValueOnDeletion are preserved in the tombstone. Tombstones are also parameterized by a PersistentModel, so that their KeyPaths can be used to retrieve the tombstone values or iterated as desired.\n\nHistory in SwiftData is easy to consume and built on the rich type system of Swift. Let’s explore how to use it in an app. To see it in action, I’m going to work on a new feature for the SampleTrips app. This app lets me record all of my favorite trips, to help me plan my next vacation.\n\nI want to add a new feature where Trips that have unread changes are badged for my review. This can happen outside the app in the context of a sync from a remote server or in the app’s widget.\n\nIn the widget, I am going to add the capability to confirm a given living accommodation right from my Home Screen. Using SwiftData History, I can build this feature by finding out when this data changed, who changed it and update the UI.\n\nTo do this, I am going to break the task into three steps: Fetch SwiftData History, process the changes by inspecting the properties on the change, and finally, update my user interface. To start, I’ll build a function that fetches transactions in the data store based on a token parameter and author. In this case, the token is of type DefaultHistoryToken, because the app uses the DefaultStore in SwiftData.\n\nNext, I’ll create a HistoryDescriptor, which lets me configure constraints for my request.\n\nI’ll build a predicate that constrains the transaction to have occurred after the provided token.\n\nSince I want this function to only surface changes from my widget, I’ll also add a constraint to fetch changes authored by a specified author. If I’m calling this function without a token, I’ll just fetch all of the available history.\n\nNext, I’ll create an array that will contain all of the transactions that need to be processed. And I’ll call fetchHistory on the ModelContext using the descriptor. This will provide a set of DefaultHistoryTransactions that I can then iterate through. Now that I am able to retrieve the transactions I care about, I'm going to define another function for processing them. This function will accept an array of transactions and return a set of Trips that need to be badged having unread changes and a token. Each time the function runs, it will return a new token that I can use the next time I want to find changes.\n\nI’ll begin by defining a ModelContext and a set that will store my trips with unread changes.\n\nFor each transaction and change in a transaction, the History API provides the persistent model id. To get the model instance for the Trip, I’ll build a fetch descriptor for LivingAccommodation using that persistent model id. Then, I’ll fetch that model from the model context and store the trip associated with the LivingAccommodation.\n\nTo determine if a change in a transaction represents an insert, update, or deletion, I’ll use a switch statement to check its type.\n\nIn the app, I want to apply a badge in the UI if my widget inserts, changes, or deletes a LivingAccommodation model. To do that, I’ll start by checking for changes of type DefaultHistoryInsert for LivingAccommodation. If this case matches, it represents an insert of a LivingAccommodation, so add this trip to the set. Again, notice that the type is called DefaultHistoryInsert because in this case, I’m using the DefaultStore for this model. I’ll also check for updates by adding a case for the type DefaultHistoryUpdate of a LivingAccommodation. If this change is an update, I’ll update the trip in the set.\n\nIf the trip is deleted, there’s nothing I need to do in the app’s interface. To handle this, I’ll add a case for the type DefaultHistoryDelete of a LivingAccommodation and remove it from my set.\n\nFinally, I’ll return the last token along with my set of trips, so that future calls to this function return only the changes that have occurred after that transaction.\n\nUsing SwiftData History, the app can now discover which Trips were changed from the widget since the last time the app checked for changes. Now, I need to store this token, so that it only considers changes since the last time changes were discovered. To do this, I’ll define a third function and use UserDefaults to store the most recent token. In my function findUnreadTrips, I’ll fetch the token, if there’s one available, and decode it from JSON, before calling my findTransactions function with that token. The author I want to specify is the widget so, in the widget, I’ve set the .author property on a ModelContext equal to TransactionAuthor.widget.\n\nAfter calling findTrips I’ll store the returned token back into UserDefaults. Now, each time I call findUnreadTrips, it will only return Trips which need to be badged since the last time it was called.\n\nMy feature is almost ready. There’s just two more pieces I need to add: One, when the app is opened, I’ll check for unread trips and two, when a trip is tapped on, I’ll remove it from the set of unread trips, so that the badge disappears. On my SwiftUI view, I’ll call findUnreadTripIdentifiers any time the scene phase becomes active. This will update the interface with the new trips that need to be badged.\n\nThen, when a trip is selected, I’ll remove its identifier from the unreadTripIdentifiers set, so that the badge disappears.\n\nFinally, I’ll add the badge to any Trip that is contained within the unreadTripIdentifiers set.\n\nNow that all the required code is implemented, I’ll build and run the app. There is already a trip entered in the app and I want to confirm the living accommodations in my widget right on the home screen.\n\nI’ll tap Accommodation and the UI will change to indicate it is confirmed. The next time I launch the trips app, the trip to the formation flyover will have a blue unread badge indicating there's been changes to that trip. After reviewing the trip, the badge is removed.\n\nFor those of you building custom data stores with SwiftData, your custom store can also support history. If your underlying model supports it, you can support these same workflows with your store implementation as well. To add history to your custom data store, you’ll need to implement your own types to represent the fundamental elements of the SwiftData History API for your data store. This includes transactions, each type of change, and a token, to act as a bookmark between transactions. In addition, your custom data store will need to conform to HistoryProviding.\n\nThe boundaries of a transaction will need to be well-defined because write operations in your data store need to be coalesced and ordered In the default store, all of the changes to model instances on the ModelContext at save time are grouped as a single transaction.\n\nWhen you create your transaction type, you’ll need to define a way to uniquely identify a transaction within your persistence back end. Similarly to transactions, what defines the boundaries of a change must be well-defined. In the DefaultStore, the boundaries of a change are scoped to an individual model instance.\n\nPick an identifier that can track the granular nature of these changes.\n\nIt’s possible that your app may not need all of the existing change types, or, it may need different change types. For example, if your app only ever inserts models as a time-series log you may not need update and delete change types. An additional consideration, is if your app will need to support preserving values on deletion and how the deleted values will be stored.\n\nThe custom store will need to implement the HistoryProviding protocol to vend history. This will require being able to pull together rows from the store that define the transaction and changes.\n\nAfter identifying which rows are part of a transaction, you’ll need to build the specific sets of models.\n\nThe default data store manages the time to live of history records. As a custom provider, you’ll need to decide when to delete history. While SwiftData History is robust, and can handle a large amount of history data, in some specific cases, you may want to delete history. For example, if you remove models from your app, there may be history data about those models that you would never use going forward. In that case, you might like to delete this history from the data store.\n\nFinally, when adding history support to your custom store, you’ll need to create a custom type of token. HistoryToken is the base protocol for a token. The state is needed to uniquely identify your position in the stream of transactions.\n\nConsider if your app uses multiple, related stores. Your custom token should include the state of all the stores used in the transaction.\n\nHistory is a powerful feature that lets you query for changes, like discovering the update from the widget in Trips. SwiftData uses Swift’s expressive type system to make it easy to understand how each model change gets used in your app. You can build delightful experiences in your app with SwiftData History. For those of you using co-existence with Core Data to benefit from persistent history, you can now migrate to SwiftData History instead. And if you’re building a custom store, you can support all of the features of history tracking by creating your own history types. Thanks for watching.",
    "segments": []
  },
  "codeExamples": [
    {
      "timestamp": "4:57",
      "title": "Preserve values in history on deletion",
      "language": "swift",
      "code": "// Add .preserveValueOnDeletion to capture unique columns\nimport SwiftData\n\n@Model \nclass Trip {\n    #Unique<Trip>([\\.name, \\.startDate, \\.endDate])\n    \n    @Attribute(.preserveValueOnDeletion)\n    var name: String\n    var destination: String\n\n    @Attribute(.preserveValueOnDeletion)\n    var startDate: Date\n\n    @Attribute(.preserveValueOnDeletion)\n    var endDate: Date\n    \n    var bucketList: [BucketListItem] = [BucketListItem]()\n    var livingAccommodation: LivingAccommodation?\n}"
    },
    {
      "timestamp": "6:26",
      "title": "Fetch transactions from history",
      "language": "swift",
      "code": "private func findTransactions(after token: DefaultHistoryToken?, author: String) -> [DefaultHistoryTransaction] {\n    var historyDescriptor = HistoryDescriptor<DefaultHistoryTransaction>() \n    if let token {\n        historyDescriptor.predicate = #Predicate { transaction in\n            (transaction.token > token) && (transaction.author == author)\n        }\n    }\n    \n    var transactions: [DefaultHistoryTransaction] = []\n    let taskContext = ModelContext(modelContainer)\n    do {\n        transactions = try taskContext.fetchHistory(historyDescriptor)\n    } catch let error {\n        print(error)\n    }\n\n    return transactions\n}"
    },
    {
      "timestamp": "7:34",
      "title": "Process history changes",
      "language": "swift",
      "code": "private func findTrips(in transactions: [DefaultHistoryTransaction]) -> (Set<Trip>, DefaultHistoryToken?) {\n        let taskContext = ModelContext(modelContainer)\n        var resultTrips: Set<Trip> = []\n        for transaction in transactions {\n            for change in transaction.changes {\n                let modelID = change.changedPersistentIdentifier\n                let fetchDescriptor = FetchDescriptor<Trip>(predicate: #Predicate { trip in\n                    trip.livingAccommodation?.persistentModelID == modelID\n                })\n                let fetchResults = try? taskContext.fetch(fetchDescriptor)\n                guard let matchedTrip = fetchResults?.first else {\n                    continue\n                }\n                switch change {\n                case .insert(_ as DefaultHistoryInsert<LivingAccommodation>):\n                    resultTrips.insert(matchedTrip)\n                case .update(_ as DefaultHistoryUpdate<LivingAccommodation>):\n                    resultTrips.update(with: matchedTrip)\n                case .delete(_ as DefaultHistoryDelete<LivingAccommodation>):\n                    resultTrips.remove(matchedTrip)\n                default: break\n                }\n            }\n        }\n        return (resultTrips, transactions.last?.token)\n    }"
    },
    {
      "timestamp": "10:19",
      "title": "Save and use a history token",
      "language": "swift",
      "code": "private func findUnreadTrips() -> Set<Trip> {\n    let tokenData = UserDefaults.standard.data(forKey: UserDefaultsKey.historyToken)\n    \n    var historyToken: DefaultHistoryToken? = nil\n    if let tokenData {\n        historyToken = try? JSONDecoder().decode(DefaultHistoryToken.self, from: tokenData)\n    }\n    let transactions = findTransactions(after: historyToken, author: TransactionAuthor.widget)\n    let (unreadTrips, newToken) = findTrips(in: transactions)\n    \n    if let newToken {\n        let newTokenData = try? JSONEncoder().encode(newToken)\n        UserDefaults.standard.set(newTokenData, forKey: UserDefaultsKey.historyToken)\n    }\n    return unreadTrips\n}"
    },
    {
      "timestamp": "11:30",
      "title": "Update the user interface",
      "language": "swift",
      "code": "struct ContentView: View {\n    @Environment(\\.scenePhase) private var scenePhase\n    @State private var showAddTrip = false\n    @State private var selection: Trip?\n    @State private var searchText: String = \"\"\n    @State private var tripCount = 0\n    @State private var unreadTripIdentifiers: [PersistentIdentifier] = []\n\n    var body: some View {\n        NavigationSplitView {\n            TripListView(selection: $selection, tripCount: $tripCount,\n                         unreadTripIdentifiers: $unreadTripIdentifiers,\n                         searchText: searchText)\n            .toolbar {\n                ToolbarItem(placement: .topBarLeading) {\n                    EditButton()\n                        .disabled(tripCount == 0)\n                }\n                ToolbarItemGroup(placement: .topBarTrailing) {\n                    Spacer()\n                    Button {\n                        showAddTrip = true\n                    } label: {\n                        Label(\"Add trip\", systemImage: \"plus\")\n                    }\n                }\n            }\n        } detail: {\n            if let selection = selection {\n                NavigationStack {\n                    TripDetailView(trip: selection)\n                }\n            }\n        }\n        .task {\n            unreadTripIdentifiers = await DataModel.shared.unreadTripIdentifiersInUserDefaults\n        }\n        .searchable(text: $searchText, placement: .sidebar)\n        .sheet(isPresented: $showAddTrip) {\n            NavigationStack {\n                AddTripView()\n            }\n            .presentationDetents([.medium, .large])\n        }\n        .onChange(of: selection) { _, newValue in\n            if let newSelection = newValue {\n                if let index = unreadTripIdentifiers.firstIndex(where: {\n                    $0 == newSelection.persistentModelID\n                }) {\n                    unreadTripIdentifiers.remove(at: index)\n                }\n            }\n        }\n        .onChange(of: scenePhase) { _, newValue in\n            Task {\n                if newValue == .active {\n                    unreadTripIdentifiers += await DataModel.shared.findUnreadTripIdentifiers()\n                } else {\n                    // Persist the unread trip names for the next launch session.\n                    await DataModel.shared.setUnreadTripIdentifiersInUserDefaults(unreadTripIdentifiers)\n                }\n            }\n        }\n        #if os(macOS)\n        .onReceive(NotificationCenter.default.publisher(for: NSApplication.didBecomeActiveNotification)) { _ in\n            Task {\n                unreadTripIdentifiers += await DataModel.shared.findUnreadTripIdentifiers()\n            }\n        }\n        .onReceive(NotificationCenter.default.publisher(for: NSApplication.willTerminateNotification)) { _ in\n            Task {\n                await DataModel.shared.setUnreadTripIdentifiersInUserDefaults(unreadTripIdentifiers)\n            }\n        }\n        #endif\n    }\n}"
    }
  ],
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "Fetching and filtering time-based model changes",
        "url": "https://developer.apple.com/documentation/SwiftData/Fetching-and-filtering-time-based-model-changes"
      },
      {
        "title": "Forum: Programming Languages",
        "url": "https://developer.apple.com/forums/topics/programming-languages-topic?cid=vf-a-0010"
      },
      {
        "title": "SwiftData",
        "url": "https://developer.apple.com/documentation/SwiftData"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2024/10075/4/0F3D64B6-B594-42E8-8B59-2088D1B251F8/downloads/wwdc2024-10075_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2024/10075/4/0F3D64B6-B594-42E8-8B59-2088D1B251F8/downloads/wwdc2024-10075_sd.mp4?dl=1"
  },
  "relatedVideos": [
    {
      "id": "10138",
      "year": "2024",
      "title": "Create a custom data store with SwiftData",
      "url": "https://developer.apple.com/videos/play/wwdc2024/10138"
    }
  ],
  "extractedAt": "2025-07-18T09:11:37.590Z"
}