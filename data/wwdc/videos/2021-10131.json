{
  "id": "10131",
  "year": "2021",
  "url": "https://developer.apple.com/videos/play/wwdc2021/10131/",
  "title": "Meet declarative device management",
  "speakers": [],
  "duration": "",
  "topics": [
    "App Store, Distribution & Marketing",
    "Business & Education"
  ],
  "hasTranscript": true,
  "hasCode": false,
  "transcript": {
    "fullText": "♪ Bass music playing ♪ ♪ Melissa Nierle: I'm Melissa Nierle, a software engineer on the Enterprise and Education Technologies team.\n\nAt Apple, we're always working to create the best device management features and functionality to equip our enterprise partners and education organizations with the tools they need to connect their team members and students.\n\nThe backbone of all of these management features is the MDM protocol itself.\n\nThe protocol is a well-established, heavily used solution provided directly within iOS, macOS, and tvOS and has become a standard across mobile device management.\n\nAnd while we add features to it each year, we also continually evaluate the protocol against our device management goals and evolve it to meet the dynamic needs of MDM solution developers, admins, and users.\n\nToday, our MDM protocol can be described as an imperative and reactive protocol.\n\nEach management workflow takes time and multiple round trips between the device and server.\n\nThen any performance challenge is compounded when you manage a large number of devices across an organization.\n\nThis is an example of where we want to ensure our protocol is as performant and scalable as possible.\n\nAnd to achieve optimal performance and scalability, we've reenvisioned the MDM protocol itself.\n\nThe future of device management is declarative management; a transformative update to the protocol which brings policy management to the device.\n\nDeclarative management allows the device to be autonomous and proactive, freeing up the server to be lightweight, reactive, and subscribe to updates without constant polling.\n\nAn autonomous device reacts to its own state changes and then applies management logic to itself without prompting from the server.\n\nA proactive device has a status channel asynchronously reporting to the server when important state changes occur, avoiding the need for servers to poll devices.\n\nEnabling devices to be both autonomous and proactive is the foundation of declarative management and allows for increased performance and scalability.\n\nAnd the best part is, while it's a new paradigm, it's not a new protocol.\n\nWe've built this new declarative functionality right into our existing MDM protocol, starting with iOS devices.\n\nWe'll take a deep dive into the data model that powers the new declarative paradigm.\n\nThen later, we'll talk about integration with MDM.\n\nWe'll go through a specific example and learn how to get yourself started.\n\nLet's begin with the declarative data model.\n\nThere are three pillars to the declarative data model.\n\nDeclarations, which are payloads that the server defines and sends to devices; the status channel, which is a new channel of communication where the device proactively updates the server with new information about itself; and extensibility, so that, as Apple introduces new features to declarative management, your devices and servers handle it seamlessly.\n\nUnderstanding these three pillars will prepare you to incorporate declarative management into your MDM solution.\n\nLet's start with declarations.\n\nDeclarations represent the policy an organization wants to enforce on devices -- for example, accounts, settings, and restrictions.\n\nDeclarations can be created for policy that is common to all users, as well as policy that is specific to a single user or device.\n\nLet's examine the makeup of declarations.\n\nThe data representation for declarations is similar to profiles, where a declaration is also a dictionary with a set of keys and standard types for values.\n\nDeclarations, however, are serialized as JSON objects when sent over the network, instead of plists.\n\nAll declarations have three required properties: Type, Identifier and ServerToken.\n\nType defines which policy a configuration represents.\n\nThe Identifier key has a value that uniquely identifies the declaration within the set of all declarations sent to the device.\n\nTypically, this will be a UUID represented as a string.\n\nThe device uses this value when synchronizing declarations with the server.\n\nThe ServerToken key represents a unique revision of the declaration based on the Identifier key.\n\nThis key is also used when synchronizing declarations with the server.\n\nThe value is a string that must be different for each revision.\n\nIt could be a simple counter or a UUID string, as shown in the example.\n\nThe payload is a data-specific piece of the declaration, containing the keys and values pertinent to the declaration type.\n\nJust like with profile payloads, some keys may be required, and others may be optional.\n\nValues can be strings, numbers, booleans, arrays, or dictionaries and may be constrained in range -- like numbers one through ten -- or to a specific set of values like a string enumeration.\n\nThere are four types of declarations: configurations, assets, activations, and management.\n\nThe first type of declaration is a configuration.\n\nConfigurations represent the policies to be applied to the device -- for example, accounts, settings, and restrictions.\n\nConfigurations are similar to MDM's existing profile payloads.\n\nHere is an example of a configuration declaration that applies restrictions to the device passcode.\n\nThe standard keys -- Type, Identifier, and ServerToken -- are present, as required for all declarations.\n\nThe value of the Type identifies this as a passcode configuration type of declaration.\n\nThe Payload key contains the passcode policy data for the configuration.\n\nThe next type of declaration is an asset.\n\nAssets represent references to ancillary data needed by configurations.\n\nThis can be a shared item of large data or a personalized one.\n\nFor large data items, the asset declaration contains a URL that the device uses to fetch the actual asset data from a server.\n\nThis server could be your MDM server, or it could be a separate content delivery network server.\n\nServing assets from a separate content delivery network shifts the burden of supporting large network bandwidth to a service better suited for it.\n\nAssets can also be used to represent data specific to a user, such as their name, email address, passwords for accounts, and certificates.\n\nThis takes the per-user customized data out of configurations and moves it into smaller, dedicated asset-type declarations.\n\nAssets have a one-to-many relationship with configurations.\n\nFor example, one credential asset can be referenced by several account configurations, avoiding the need to replicate the same user information in each account configuration.\n\nThen, if the user credential needs to be updated, only that asset needs to be updated.\n\nAll the configurations referencing that asset remain unchanged, and the device updates the policy accordingly.\n\nThe ability to do incremental updates like this, for many configurations at a time, will improve the overall responsiveness of the device management system.\n\nLet's examine the makeup of an asset declaration.\n\nHere is an example of an asset declaration that defines a user identity -- essentially the contact information for a user.\n\nThe three required standard keys are present, and the value of Type defines this as a user identity asset declaration.\n\nThe Payload key contains the user identity properties of this asset.\n\nThe next type of declaration is an activation.\n\nActivations represent sets of configurations that the device will atomically apply.\n\nThis means all configurations in the set, along with any referenced assets, must be valid in order for all of them to be applied.\n\nIf any are invalid, the activation will fail to apply the associated policy.\n\nHere is an example of a simple activation that contains two configurations.\n\nThe three required declaration keys are present, and the payload contains the set of configurations to be atomically applied by the activation.\n\nConfigurations are referenced by their identifier key.\n\nThere is a many-to-many relationship between activations and configurations.\n\nActivations can refer to multiple configurations, and a configuration can have multiple activations reference it.\n\nThis many-to-many relationship allows for complex business logic to be handled autonomously by the device.\n\nActivations can include a predicate that determines when the activation state is active or inactive on a device.\n\nThe device will only process the configurations referenced by an activation if the predicate evaluates to true.\n\nAs an example, a predicate can declare that the particular activation is only active on a specific device type, such as an iPad.\n\nAnother example is wanting a set of policies to apply only to a particular version of the OS.\n\nThis allows the server to send all the declarations for any device states and lets the device itself determine which ones to apply, making the device even more autonomous.\n\nAs the device state changes, the activation predicates are reevaluated without intervention from the server.\n\nPolicy associated with the new device state will be applied and any outdated policy removed.\n\nThe device here becomes increasingly proactive.\n\nIn the absence of a predicate, the device will always process the configurations referenced by the activation.\n\nHere we have the activation example from before, but now there's a predicate present, indicating that this activation should only have its policy applied when the device is an iPad.\n\nThe last type of declaration is a management declaration.\n\nManagement declarations are used to convey overall management state to the device.\n\nThis includes a declaration describing details about the organization as well as a declaration that describes the capabilities of the server.\n\nThese declarations are helpful for conveying static information to the device.\n\nAnd those are the four types of declarations for applying organization policy to your devices.\n\nThe second pillar of the new declarative management data model is the status channel.\n\nGiven the way that declarations work, the declared state of the device may not match the actual state of the device at any point in time.\n\nFor instance, any declaration that requires user interaction will not apply until that action is taken.\n\nA good example of this is a passcode policy, where the user has to take action to create a new policy-compliant passcode for the device.\n\nTo add visibility into this device state transition, we've created the status channel.\n\nUpdates of the device state are sent in a status report to the server.\n\nThe server can subscribe to specific status items, so it only receives updates for the changes it cares about.\n\nStatus items are identified by key-paths, which consist of period-separated string tokens.\n\nStatus items can be used as expressions in activation predicates, as shown in the earlier activation predicate example.\n\nThe server subscribes to specific status items using status subscription configurations.\n\nUpon receiving this configuration, the device will send an initial status report for the subscribed status items, and then send a report if a subscribed item changes.\n\nThe status reports are incremental, so only the changed items are reported.\n\nThe status of declarations -- whether they are applied or not -- is always reported to the server when changed, without the need for the server to subscribe.\n\nLet's inspect a configuration that subscribes to specific status item updates.\n\nThis configuration subscribes to three status items representing the device's operating system version, type, and model.\n\nWhen this configuration is activated on the device, it will send the initial status report for each of the newly subscribed status items.\n\nStatus items are represented as a JSON object, nested by the hierarchical components of that corresponding key-path.\n\nIn this case, the device reports it is on iOS 14.5.\n\nWhen the user updates the software to the latest iOS version, the device will report the status change for the operating-system version item.\n\nThe server now detects that the device has been upgraded to iOS 15.\n\nThe third pillar of the declarative data model is extensibility.\n\nGiven the long life cycle of Apple products, it is essential to maintain compatibility between different versions of your MDM solution with Apple devices, especially as software updates and new hardware models are released.\n\nWith declarative management, both the device and server now advertise supported capabilities to each other.\n\nEach knows when it can start taking advantage of new features without having to hardcode software version or hardware dependencies.\n\nThe capabilities that the server and client both advertise includes a list of supported features representing both minor and major protocol updates.\n\nThe client also advertises supported payloads, which lists the full set of declarations and status items supported by the client.\n\nThe server's capabilities are sent to the device via a management declaration.\n\nWhen the server is upgraded, it synchronizes all new capabilities to the device just as it would any other type of declaration.\n\nThe device is immediately able to take advantage of the server's new features.\n\nThe client's capabilities are sent to the server as a specific status item any time capabilities change.\n\nThis way, the server can immediately start taking advantage of the device's new features and payloads.\n\nBuilding extensibility into the declarative data model ensures that declarative management is built for the present and the future.\n\nNow that you understand the data model, let's dig into how declarative management is seamlessly integrated within the MDM protocol.\n\nExisting MDM vendors can use declarative management features starting today.\n\nDeclarative management is integrated into the MDM protocol and utilizes it for managing the enrollment and unenrollment process and for handling the HTTP transport and device and user authentication.\n\nExisting and mature MDM products can smoothly transition to declarative management without a disruptive change to adopt a new protocol or server infrastructure.\n\nDeclarations and the status channel coexist with your already in-use MDM commands and profiles in an extensible way.\n\nThis allows you to gradually adopt the different features of declarative management without having to update all of your MDM workflows at once.\n\nFor example, a server could choose to only implement status subscriptions, effectively adding a status channel to the MDM protocol without having to adopt all of declarative management.\n\nWhen the device is unenrolled from MDM, all declarations are removed, and the device state is adjusted accordingly.\n\nImportantly, declarative management does not impact existing MDM behavior at all.\n\nActually, declarative management leverages existing MDM behaviors using an MDM command for activation and an MDM CheckIn request for synchronization and status reports.\n\nLet's zoom in on each of these next.\n\nA DeclarativeManagement command has been added to MDM.\n\nThis command serves two purposes.\n\nFirst, it activates the declarative management features on the device.\n\nPlease note, once turned on, declarative management cannot be turned off.\n\nHowever, the server can remove all declarations to effectively disable declarative management.\n\nSecond, the command can include a payload containing synchronization tokens that will initiate a synchronization flow if needed.\n\nThere is also a new DeclarativeManagement CheckIn request type used by the device when synchronizing declarations and to send status reports to the server.\n\nHere is an example of the new CheckIn request type.\n\nThe MessageType key is set to the new DeclarativeManagement value.\n\nThe endpoint key is set to a value indicating that the client is making a request to retrieve the declaration manifest data from the server.\n\nSome requests -- such as this status report -- can also include Base64-encoded data.\n\nWhen using the CheckIn request to synchronize declarations, there will be a response from the server.\n\nThere are two types of responses: a manifest, which lists the identifier and server token properties of all declarations that the server defines; and single declarations for the device to apply.\n\nNow that you've learned how to activate declarative management and synchronize declarations with a CheckIn request, let's talk about how you can migrate your policies gradually from profiles to declarations.\n\nThere's a declaration type specifically for sending and installing profiles as configurations.\n\nThis enables you to utilize the full suite of MDM profiles to immediately take advantage of declarative management by shifting profile-based policy logic to the device.\n\nHere is an example of a profile configuration.\n\nThe profile is referenced via URL.\n\nWhen this configuration is activated, the profile is fetched from the URL and installed on the device.\n\nWe've taken these steps to make declarative management easy to adopt today with the iOS 15 beta.\n\nNow let's go through an example of how declarative management interacts with the server.\n\nFirst, we activate declarative management.\n\nThis starts with the device already enrolled in MDM.\n\nThe server sends a push notification to the device.\n\nThe device responds to the push in the usual way, by sending a ServerURL endpoint request with its status set to Idle.\n\nThe server then responds with the DeclarativeManagement command.\n\nUpon receipt, the device activates declarative management.\n\nAfter processing the DeclarativeManagement command, the device sends an Acknowledged status back to the server.\n\nThen if the server has no more commands, it will return an empty response.\n\nThe device then starts its declarative management synchronization process; let's go through that next.\n\nThe device first sends a CheckIn request with the endpoint key set to declaration-items.\n\nThe server responds with a manifest containing declaration metadata.\n\nThe device then compares the items in the manifest to the set of declarations it previously received from the server.\n\nThrough this comparison, the device can tell which declarations are new, which have changed, and which have been removed.\n\nFor each new or changed declaration, the device sends a CheckIn request.\n\nThis request's EndPoint key is set to a path uniquely identifying the declaration resource.\n\nThe server then responds with the JSON object representing that declaration.\n\nOnce all declarations have been fetched from the server, the device starts applying the policy changes represented by this updated state of declarations.\n\nOnce the policy changes have been applied, the device will send a status report to the server, with the corresponding updated status items.\n\nTo help get you started, let's go through what we are shipping in iOS 15.\n\nThe declarative management feature is supported on devices with iOS 15 and iPadOS 15.\n\nIt's also only available when the MDM enrollment type is a user enrollment -- either the new onboarding flow introduced with iOS 15, or the flow from iOS 13.\n\nFor configurations, we have account and passcode configurations that cover the equivalent set of MDM account and passcode profile payloads.\n\nWe also support profile configurations enabling you to start installing the full suite of MDM-supported profiles to your devices declaratively.\n\nStatus subscription configurations are also available today and are used for the server to declare the specific status item updates it wants to receive.\n\nThere is one type of activation available today.\n\nThis simple activation defines a list of configurations that must be applied atomically and may include an optional predicate.\n\nFor asset declarations, there are two types available: user identity assets, which represent a user's contact information; and user credential assets, which contain user IDs and passwords for user accounts.\n\nFor management declarations, we are supporting two types: organization details and server capabilities.\n\nNext, here are the status items available today.\n\nEach declaration has its own status item that is automatically sent to the server from the device.\n\nAlso available are a set of status items that cover basic properties of the device, like details about a device's hardware model and its operating system.\n\nFor more detail on these declarations and status items, check out Apple's Device Management developer documentation.\n\nToday we covered the new paradigm of declarative management and its functionality, discovering how declarative management empowers you to make devices more autonomous and proactive.\n\nWe learned how to integrate declarative management into your MDM solution.\n\nWe went through an example showing how declarative management works and reviewed how declarative management is ready for you to start using today.\n\nWe can't wait to find out how you'll reinvent MDM solutions with declarative management.\n\nThanks for joining me and have a great WWDC.\n\n♪",
    "segments": []
  },
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "Device Management",
        "url": "https://developer.apple.com/documentation/DeviceManagement"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2021/10131/4/E2547688-09E1-4213-B74C-BA8E1EE3D32A/downloads/wwdc2021-10131_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2021/10131/4/E2547688-09E1-4213-B74C-BA8E1EE3D32A/downloads/wwdc2021-10131_sd.mp4?dl=1"
  },
  "relatedVideos": [
    {
      "id": "10041",
      "year": "2023",
      "title": "Explore advances in declarative device management",
      "url": "https://developer.apple.com/videos/play/wwdc2023/10041"
    },
    {
      "id": "10046",
      "year": "2022",
      "title": "Adopt declarative device management",
      "url": "https://developer.apple.com/videos/play/wwdc2022/10046"
    },
    {
      "id": "10130",
      "year": "2021",
      "title": "What’s new in managing Apple devices",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10130"
    }
  ],
  "extractedAt": "2025-07-18T09:19:32.991Z"
}