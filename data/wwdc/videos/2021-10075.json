{
  "id": "10075",
  "year": "2021",
  "url": "https://developer.apple.com/videos/play/wwdc2021/10075/",
  "title": "Explore advanced rendering with RealityKit 2",
  "speakers": [],
  "duration": "",
  "topics": [
    "Graphics & Games"
  ],
  "hasTranscript": true,
  "hasCode": true,
  "transcript": {
    "fullText": "♪ Bass music playing ♪  ♪ Courtland Idstrom: Hello, my name is Courtland Idstrom, and I'm an engineer on the RealityKit team. In this video, I'm going to show you how to use the new rendering features in RealityKit 2. RealityKit is a framework designed to make building AR apps simple and intuitive. Rendering is a key piece of RealityKit, centered around highly realistic, physically based rendering. Since our first release in 2019, we've been working on your feedback and we're shipping a major update to RealityKit. In the \"Dive into Reality Kit 2\" session, we covered the evolution of RealityKit, providing many enhancements -- from updates to the ECS system, more evolved material and animation capabilities, and generating audio and texture resources at runtime. To showcase these improvements, we built an app that turns your living room into an underwater aquarium. In this talk, we'll show some of the new rendering features that went into the app. RealityKit 2 provides control and flexibility with how objects are rendered, allowing you to create even better AR experiences. This year we bring advancements to our material system, enabling you to add your own materials by authoring custom Metal shaders. Custom post effects allow you to augment RealityKit's post effects with your own. New mesh APIs allow mesh creation, inspection, and modifications at runtime. Let's start with the most requested feature in RealityKit 2, support for custom shaders. RealityKit's rendering centers around a physically based rendering model. Its built-in shaders make it easy to create models that look natural next to real objects across a range of lighting conditions. This year, we're building on these physically based shaders and exposing the ability for you to customize the geometry and surface of models using shaders. The first of our shader APIs is geometry modifier. A geometry modifier is a program, written in the Metal Shading Language, that gives you the opportunity to change the vertices of an object every frame as it's rendered on the GPU. This includes moving them and customizing their attributes, such as color, normal, or UVs. It's run inside of RealityKit's vertex shader, and is perfect for ambient animation, deformation, particle systems, and billboards. Our seaweed is a great example of ambient animation. The seaweed is moving slowly due to the movement of water around it. Let's take a closer look. Here you can see the wireframe of the seaweed as created by our artist; this shows the vertices and triangles comprising the mesh. We're going to write a shader program that executes on each vertex to create our motion. We'll use a sine wave, a simple periodic function, to create movement. We're simulating water currents so we want nearby vertices to behave similarly, regardless of their model's scale or orientation. For this reason, we use the vertex's world position as an input to the sine function. We include a time value as well, so that it moves over time. Our first sine wave is in the Y dimension to create up-down movement. To control the period of the motion, we'll add a spatial scale. And we can control the amount of its movement with an amplitude. We'll apply the same function to the X and Z dimensions so it moves in all three axes. Now, let's look at the model as a whole. One thing we haven't yet accounted for: vertices close to the base of the stalk have very little room for movement, while ones at the top have the highest freedom to move. To simulate this, we can use the vertex's y-coordinate relative to the object's origin as a scaling factor for all three axes, which gives us our final formula. Now that we have a plan for our shader, let's take a look at where to find these parameters. Geometry parameters are organized into a few categories. The first is uniforms, values that are the same for every vertex of the object within one frame. We need time for our seaweed. Textures contain all textures authored as part of the model, plus an additional custom slot, which you can use as you see fit. Material constants have any parameters, such as tint or opacity scale, authored with the object or set via code. Geometry contains some read-only values, such as the current vertex's model position or vertex ID. We need both model and world positions for our seaweed movement. Geometry also has read-write values, including normal, UVs, and model position offset. Once we have computed our offset, we'll store it here to move our vertices. Let's dive into Metal shader. We start out by including RealityKit.h. Now we declare a function with the visible function attribute. This instructs the compiler to make it available separately from other functions. The function takes a single parameter, which is RealityKit's geometry_parameters. We'll retrieve all values through this object. Using the geometry member of params, we'll ask for both the world position and model position. Next we calculate a phase offset, based on the world position at the vertex and time. Then we apply our formula to calculate this vertex's offset. We store the offset on geometry, which will get added to the vertex's model position. We have our geometry modifier, but it's not yet hooked up to our seaweed. Let's switch to our ARView subclass, written in Swift. We start by loading our app's default Metal library, which contains our shader. Next we construct a geometryModifier using our shader's name and library. For each material on the seaweed, we create a new custom material. We pass the existing material as the first parameter to CustomMaterial, so that it inherits the textures and material properties from the base material while adding our geometry modifier. It looks pretty nice! Since we're underwater, we've kept the animation pretty slow. By tweaking amplitude and phase, the same effect can be extended to grass, trees, or other foliage. Now that we've shown how to modify geometry, let's talk about shading. This is our octopus from the underwater scene, looking great with our built-in shader. As they do, our octopus transitions between multiple looks. The second look has a reddish color. Our artist has authored two base color textures, one for each look. In addition to the color change, the red octopus has a higher roughness value, making it less reflective. And, to make our octopus even more special, we wanted to create a nice transition between looks. Here you can see the transition in action. Mesmerizing. While each look can be described as a physically based material, for the transition itself, we need to write a surface shader. So what is a surface shader? A surface shader allows you to define the appearance of an object. It runs inside the fragment shader for every visible pixel of an object. In addition to color, this includes surface properties such as normal, specular, and roughness. You can write shaders that enhance an object's appearance or replace it entirely, creating new effects. We've seen the two base-color textures for our octopus. For the transition effect, our artist has encoded a special texture for us. This texture is actually a combination of three different layers. There's a noise layer on top creating localized transition patterns. We have a transition layer, which dictates the overall movement, starting at the head and moving towards the tentacles. And there's a mask layer for areas that we don't want to change color, such as the eye and underside of the tentacles. These three layers are combined into the red, green, and blue channels of our texture, which we assign to the custom texture slot. With our textures set up, let's look at how to access these from a surface shader. Similar to the geometry modifier, the surface shader has access to uniforms, textures, and material constants. Time is an input to our octopus transition. We'll sample textures authored with our model and read material constants, allowing our artist to make model-wide adjustments. Geometry -- such as position, normal, or UVs -- appear in a geometry structure. These are the interpolated outputs from the vertex shader. We'll use UV0 as our texture coordinate. A surface shader writes a surface structure. Properties start with default values, and we're free to calculate these values in any way we see fit. We'll be calculating base color and normal. Then, four surface parameters: roughness, metallic, ambient occlusion, and specular. Now that we know where our values live, let's start writing our shader. We'll do this in three steps. First calculate the transition value, where 0 is a fully purple octopus and 1 is fully red. Using the transition value, we'll calculate color and normal and then fine-tune by assigning material properties. Let's get started. First step: transition. We're building the octopus surface function, which takes a surface_parameters argument. Since we're using textures, we declare a sampler. On the right, you can see what our octopus looks like with an empty surface shader -- it's gray and a little bit shiny. RealityKit puts you in complete control of what does or does not contribute to your model's appearance. In order to compute color, there's a few things we need to do first. We'll store some convenience variables. We access our UV0, which we'll use as a texture coordinate. Metal and USD have different texture coordinate systems, so we'll invert the y-coordinate to match the textures loaded from USD. Now we'll sample our transition texture -- the three-layered texture our artist created. Our artist set up a small function that takes the mask value plus time, and returns 0 to 1 values for blend and colorBlend. Second step: color and normal. With our previously computed blend variable, we can now calculate the octopus's color and see the transition. To do this, we sample two textures: the base color and the secondary base color, which we've stored in emissive_color. Then we blend between the two colors using the previously computed colorBlend. We'll multiply by base_color_tint -- a value from the material -- and set our base color on the surface. Next we'll apply the normal map, which adds surface deviations, most noticeable on the head and tentacles. We sample the normal map texture, unpack its value, and then set on the surface object. Onto material properties. Here's our octopus so far, with color and normal. Let's see how surface properties affect its look. Roughness, which you'll see on the lower body; ambient occlusion, which will darken up the lower portions; and specular, which gives us a nice reflection on the eye and some additional definition on the body. Let's add these to our shader. We sample four textures on the model, one for each property. Next we scale these values with material settings. In addition, we're also increasing the roughness as we transition from purple to red. Then we set our four values on the surface. Similar to before, we need to apply the shader to our model. We assign this material to our model in our ARView subclass. First we load our two additional textures, then load our surface shader. Like before, we're constructing new materials from the object's base material, this time with a surface shader and our two additional textures. And we're done. So to recap, we've shown the seaweed animation using geometry modifiers and how to build an octopus transition with surface shaders. While we've demonstrated them separately, you can combine the two for even more interesting effects. Moving on to another highly requested feature, support for adding custom post processing effects. RealityKit comes with a rich suite of camera-matched post effects like motion blur, camera noise, and depth of field. These effects are all designed to make virtual and real objects feel like they're part of the same environment. These are available for you to customize on ARView. This year, we're also exposing the ability for you to create your own fullscreen effects. This allows you to leverage RealityKit for photo realism, and add new effects to tailor the result for your app. So what is a post process? A post process is a shader or series of shaders that execute after objects have been rendered and lit. It also occurs after any RealityKit post effects. Its inputs are two textures: color and a depth buffer. The depth buffer is displayed as greyscale here; it contains a distance value for each pixel relative to the camera. A post process writes its results to a target color texture. The simplest post effect would copy source color into target color. We can build these in a few ways. Apple's platforms come with a number of technologies that integrate well with post effects, such as Core Image, Metal Performance Shaders, and SpriteKit. You can also write your own with the Metal Shading Language. Let's start with some Core Image effects. Core Image is an Apple framework for image processing. It has hundreds of color-processing, stylization, and deformation effects that you can apply to images and video. Thermal is a neat effect -- something you might turn on for an underwater fish finder. Let's see how easy it is to integrate with RealityKit. All of our post effects will follow the same pattern. You set render callbacks, respond to prepare with device, and then post process will be called every frame. Render callbacks exist on RealityKit's ARView. We want both the prepareWithDevice and postProcess callbacks. Prepare with device will be called once with the MTLDevice. This is a good opportunity to create textures, load compute or render pipelines, and check device capabilities. This is where we create our Core Image context. The postProcess callback is invoked each frame. We'll create a CIImage, referencing our source color texture. Next we create our thermal filter. If you're using a different Core Image filter, this is where you'd configure its other parameters. Then we create a render destination, which targets our output color texture and utilizes the context's command buffer. We ask Core Image to preserve the image's orientation and start the task. That's it! With Core Image, we've unlocked hundreds of prebuilt effects that we can use. Now let's see how we can use Metal Performance Shaders to build new effects. Let's talk about bloom. Bloom is a screen space technique that creates a glow around brightly lit objects, simulating a real-world lens effect. Core Image contains a bloom effect, but we're going to build our own so we can control every step of the process. We'll build the effect with Metal Performance Shaders, a collection of highly optimized compute and graphics shaders. To build this shader, we're going to construct a graph of filters using color as the source. We first want to isolate the areas that are bright. To do this, we use an operation called \"threshold to zero.\" It converts color to luminance and sets every pixel below a certain brightness level to 0. We then blur the result using a Gaussian blur, spreading light onto adjacent areas. Efficient blurs can be challenging to implement and often require multiple stages. Metal Performance Shaders handles this for us. Then we add this blurred texture to the original color, adding a glow around bright areas. Let's implement this graph as a post effect. We start by creating an intermediate bloomTexture. Then execute our ThresholdToZero operation, reading from sourceColor and writing to bloomTexture. Then we perform a gaussianBlur in place. Finally, we add our original color and this bloomed color together. That's it! Now that we've seen a couple ways to create post effects, let's talk about a way to put effects on top of our output using SpriteKit. SpriteKit is Apple's framework for high performance, battery-efficient 2D games. It's perfect for adding some effects on top of our 3D view. We'll use it to add some bubbles on the screen as a post effect, using the same prepareWithDevice and postProcess callbacks. We have the same two steps as before. In prepareWithDevice, we'll create our SpriteKit renderer and load the scene containing our bubbles. Then in our postProcess callback, we'll copy our source color to target color, update our SpriteKit scene, and render on top of the 3D content. prepareWithDevice is pretty straightforward -- we create our renderer and load our scene from a file. We'll be drawing this over our AR scene, so we need our SpriteKit background to be transparent. In postProcess, we first blit the source color to the targetColorTexture; this will be the background that SpriteKit renders in front of. Then advance our SpriteKit scene to the new time so our bubbles move upward. Set up a RenderPassDescriptor and render onto it. And that's it! We've shown how to utilize existing frameworks to make post effects, but sometimes you really do need to make one from scratch. You can also author a full-screen effect by writing a compute shader. For our underwater demo, we needed a fog effect that applies to virtual objects and camera passthrough. Fog simulates the scattering of light through a medium; its intensity is proportional to the distance. To create this effect, we needed to know how far each pixel is from the device. Fortunately, ARKit and RealityKit both provide access to depth information. For LiDAR-enabled devices, ARKit provides access to sceneDepth, containing distances in meters from the camera. These values are extremely accurate at a lower resolution than the full screen. We could use this depth directly but it doesn't include virtual objects, so they wouldn't fog correctly. In our postProcess, RealityKit provides access to depth for virtual content and -- when scene understanding is enabled -- approximated meshes for real-world objects. The mesh builds progressively as you move, so it contains some holes where we haven't currently scanned. These holes would show fog as if they were infinitely far away. We'll combine data from these two depth textures to resolve this discrepancy. ARKit provides depth values as a texture. Each pixel is the distance, in meters, of the sampled point. Since the sensor is at a fixed orientation on your iPhone or iPad, we'll ask ARKit to construct a conversion from the sensor's orientation to the current screen orientation, and then invert the result. To read virtual content depth, we need a little bit of info about how RealityKit packs depth. You'll notice that, unlike ARKit's sceneDepth, brighter values are nearer to the camera. Values are stored in a 0 to 1 range, using an Infinite Reverse-Z Projection. This just means that 0 means infinitely far away, and 1 is at the camera's near plane. We can easily reverse this transform by dividing the near plane depth by the sampled depth. Let's write a helper function to do this. We have a Metal function taking the sample's depth and projection matrix. Pixels with no virtual content are exactly 0. We'll clamp to a small epsilon to prevent divide by zero. To undo the perspective division, we take the last column's z value and divide by our sampled depth. Great! Now that we have our two depth values, we can use the minimum of the two as an input to our fog function. Our fog has a few parameters: a maximum distance, a maximum intensity at that distance, and a power curve exponent. The exact values were chosen experimentally. They shape our depth value to achieve our desired fog density. Now we're ready to put the pieces together. We have our depth value from ARKit, a linearized depth value from RealityKit, and a function for our fog. Let's write our compute shader. For each pixel, we start by sampling both linear depth values. Then we apply our fog function using our tuning parameters, which turns linear depth into a 0 to 1 value. Then we blend between source color and the fog color, depending on fogBlend's value, storing the result in outColor. To recap, RealityKit's new post process API enables a wide range of post effects. With Core Image, we've unlocked hundreds of ready-built effects. You can easily build new ones with Metal Performance Shaders, add screen overlays with SpriteKit, and write your own from scratch with Metal. For more information about Core Image or Metal Performance Shaders, see the sessions listed. Now that we've covered rendering effects, let's move onto our next topic, dynamic meshes. In RealityKit, mesh resources store mesh data. Previously, this opaque type allowed you to assign meshes to entities. This year, we're providing the ability to inspect meshes, create, and update meshes at runtime. Let's look at how we can add special effects to the diver. In this demo, we want to show a spiral effect where the spiral contours around the diver. You can also see how the spiral is changing its mesh over time to animate its movement. Let's have a look at how to create this using our new mesh APIs. The effect boils down into three steps. We use mesh inspection to measure the model by examining its vertices. We then build a spiral, using the measurements as a guide. And finally, we can update the spiral over time. Starting with mesh inspection. To explain how meshes are stored, let's look at our diver model. In RealityKit, the Diver's mesh is represented as a mesh resource. With this year's release, MeshResource now contains a member called Contents. There is where all of the processed mesh geometry lives. Contents contains a list of instances and models. Models contain the raw vertex data, while instances reference them and add a transform. Instances allow the same geometry to be displayed multiple times without copying the data. A model can have multiple parts. A part is a group of geometry with one material. Finally, each part contains the vertex data we're interested in, such as positions, normals, texture coordinates, and indices. Let's first look at how we would access this data in code. We'll make an extension on MeshResource.Contents, which calls a closure with the position of each vertex. We start by going through all of the instances. Each of these instances map to a model. For each instance, we find its transform relative to the entity. We can then go into each of the model's parts and access the part's attributes. For this function, we're only interested in position. We can then transform the vertex to the entity space position and call our callback. Now that we can visit the vertices, let's look at how we want to use this data. We'll section our diver into horizontal slices. For each slice, we'll find the bounding radius of our model, and do this for every slice. To implement this, we'll start by creating a zero-filled array with numSlices elements. We then figure out the bounds of the mesh along the y-axis to create our slices. Using the function we just created, for each vertex in the model, we figure out which slice it goes in and we update the radius with the largest radius for that slice. Finally, we return a Slices object containing the radii and bounds. Now that we've analyzed our mesh to know how big it is, let's look at how to create the spiral mesh. The spiral is a dynamically generated mesh. To create this mesh, we need to describe our data to RealityKit. We do this with a mesh descriptor. The mesh descriptor contains the positions, normals, texture coordinates, primitives, and material indices. Once you have a mesh descriptor, you can generate a mesh resource. This invokes RealityKit's mesh processor, which optimizes your mesh. It will merge duplicate vertices, triangulate your quads and polygons, and represent the mesh in the most efficient format for rendering. The result of this processing gives us a mesh resource, which we can assign to an entity. Note that normals, texture coordinates, and materials are optional. Our mesh processor will automatically generate correct normals and populate them. As part of the optimization process, RealityKit will regenerate the topology of the mesh. If you need a specific topology, you can use MeshResource.Contents directly. Now that we know how creating a mesh works, let's look at how to create the spiral. To model the spiral, let's take a closer look at a section.\n\nA spiral is also known as a helix. We'll build this in evenly spaced segments. We can calculate each point using the mathematical definition of a helix and the radius from our analyzed mesh. Using this function for each segment on the helix, we can define four vertices. P0 and P1 are exactly the values that p() returns. To calculate P2 and P3, we can offset P0 and P1 vertically with our given thickness. We're creating triangles, so we need a diagonal. We'll make two triangles using these points. Time to put it all together. Our generateSpiral function needs to store positions and indices. Indices reference values in positions. For each segment, we'll calculate four positions and store their indices -- i0 is the index of p0 when it's added to the array. Then we add the four positions and six indices -- for two triangles -- to their arrays. Once you have your geometry, creating a mesh is simple. First, create a new MeshDescriptor. Then assign positions and primitives. We're using triangle primitives, but we could also choose quads or polygons. Once those two fields are populated, we have enough to generate a MeshResource. You can also provide other vertex attributes like normals, textureCoordinates, or material assignments. We've covered how to create the mesh. The last thing in our spiral example is mesh updates. We use mesh updates to get the spiral to move around the diver. To update the mesh, there's two ways. We could create a new MeshResource each frame using the MeshDescriptors API. But this is not an efficient route, as it will run through the mesh optimizer each frame. A more efficient route is to update the contents in the MeshResource. You can generate a new MeshContents and use it to replace the mesh. There is one caveat, however. If we created our original mesh using MeshDescriptor, RealityKit's mesh processor will have optimized the data. Topology is also reduced to triangles. As a result, make sure you know how your mesh is affected before applying any updates. Let's have a look at code for how you can update the spiral. We start by storing the contents of the existing spiral. Create a new model from the existing model. Then, for each part, we replace triangleIndices with a subset of indices. Finally, with the new contents, we can call replace on the existing MeshResource. And that's it for dynamic meshes. To summarize the key things about dynamic meshes, we've introduced a new Contents field in the MeshResource. This container allows you to inspect and modify a mesh's raw data. You can create new meshes using MeshDescriptor. This flexible route allows you to use triangles, quads, or even polygons, and RealityKit will generate an optimized mesh for rendering. Finally, to update meshes, we've provided the ability to update a MeshResource's contents, which is ideal for frequent updates. To wrap up, today we've shown off some of the new rendering features in RealityKit 2. Geometry modifiers let you move and modify vertices. Surface shaders allow you to define your model's surface appearance. You can use post effects to apply effects to the final frame, and dynamic meshes make it easy to create and modify meshes at runtime. To see more of this year's features, don't miss \"Dive into RealityKit 2.\" And for more information about RealityKit, watch \"Building Apps with RealityKit.\" We're very excited about this year's release, and can't wait to see the experiences you build with it. Thank you. ♪",
    "segments": []
  },
  "codeExamples": [
    {
      "timestamp": "4:52",
      "title": "Seaweed Shader",
      "language": "swift",
      "code": "#include <RealityKit/RealityKit.h>\n\n[[visible]]\nvoid seaweedGeometry(realitykit::geometry_parameters params)\n{\n    float spatialScale = 8.0;\n    float amplitude = 0.05;\n\n    float3 worldPos = params.geometry().world_position();\n    float3 modelPos = params.geometry().model_position();\n\n    float phaseOffset = 3.0 * dot(worldPos, float3(1.0, 0.5, 0.7));\n    float time = 0.1 * params.uniforms().time() + phaseOffset;\n\n    float3 maxOffset = float3(sin(spatialScale * 1.1 * (worldPos.x + time)),\n                              sin(spatialScale * 1.2 * (worldPos.y + time)),\n                              sin(spatialScale * 1.2 * (worldPos.z + time)));\n\n    float3 offset = maxOffset * amplitude * max(0.0, modelPos.y);\n\n    params.geometry().set_model_position_offset(offset);\n}"
    },
    {
      "timestamp": "5:43",
      "title": "Assign Seaweed Shader",
      "language": "swift",
      "code": "// Assign seaweed shader to model.\n\nfunc assignSeaweedShader(to seaweed: ModelEntity)\n{\n    let library = MTLCreateSystemDefaultDevice()!.makeDefaultLibrary()!\n\n    let geometryModifier = CustomMaterial.GeometryModifier(named: \"seaweedGeometry\",\n                                                           in: library)\n\n    seaweed.model!.materials = seaweed.model!.materials.map { baseMaterial in\n        try! CustomMaterial(from: baseMaterial, geometryModifier: geometryModifier)\n    }\n}"
    },
    {
      "timestamp": "9:21",
      "title": "Octopus Shader",
      "language": "swift",
      "code": "#include <RealityKit/RealityKit.h>\n\nvoid transitionBlend(float time,\n                     half3 masks,\n                     thread half &blend,\n                     thread half &colorBlend)\n{\n    half noise = masks.r;\n    half gradient = masks.g;\n    half mask = masks.b;\n\n    half transition = (sin(time * 1.0) + 1) / 2;\n    transition = saturate(transition);\n\n    blend = 2 * transition - (noise + gradient) / 2;\n    blend = 0.5 + 4.0 * (blend - 0.5); // more contrast\n    blend = saturate(blend);\n    blend = max(blend, mask);\n    blend = 1 - blend;\n\n    colorBlend = min(blend, mix(blend, 1 - transition, 0.8h));\n}\n\n[[visible]]\nvoid octopusSurface(realitykit::surface_parameters params)\n{\n    constexpr sampler bilinear(filter::linear);\n\n    auto tex = params.textures();\n    auto surface = params.surface();\n    auto material = params.material_constants();\n\n    // USD textures have an inverse y orientation.\n    float2 uv = params.geometry().uv0();\n    uv.y = 1.0 - uv.y;\n\n    half3 mask = tex.custom().sample(bilinear, uv).rgb;\n\n    half blend, colorBlend;\n    transitionBlend(params.uniforms().time(), mask, \n                    blend, colorBlend);\n  \n    // Sample both color textures.\n    half3 baseColor1, baseColor2;\n    baseColor1 = tex.base_color().sample(bilinear, uv).rgb;\n    baseColor2 = tex.emissive_color().sample(bilinear, uv).rgb;\n    \n    // Blend colors and multiply by the tint.\n    half3 blendedColor = mix(baseColor1, baseColor2, colorBlend);\n    blendedColor *= half3(material.base_color_tint());\n    \n    // Set on the surface.\n    surface.set_base_color(blendedColor);\n\n    // Sample the normal and unpack.\n    half3 texNormal = tex.normal().sample(bilinear, uv).rgb;\n    half3 normal = realitykit::unpack_normal(texNormal);\n\n    // Set on the surface.\n    surface.set_normal(float3(normal));\n\n    // Sample material textures.\n    half roughness = tex.roughness().sample(bilinear, uv).r;\n    half metallic = tex.metallic().sample(bilinear, uv).r;\n    half ao = tex.ambient_occlusion().sample(bilinear, uv).r;\n    half specular = tex.roughness().sample(bilinear, uv).r;\n\n    // Apply material scaling factors.\n    roughness *= material.roughness_scale();\n    metallic *= material.metallic_scale();\n    specular *= material.specular_scale();\n\n    // Increase roughness for the red octopus.\n    roughness *= (1 + blend);\n\n    // Set material properties on the surface.\n    surface.set_roughness(roughness);\n    surface.set_metallic(metallic);\n    surface.set_ambient_occlusion(ao);\n    surface.set_specular(specular);\n}"
    },
    {
      "timestamp": "11:41",
      "title": "Assign Octopus Shader",
      "language": "swift",
      "code": "// Apply the surface shader to the Octopus.\nfunc assignOctopusShader(to octopus: ModelEntity)\n{\n    // Load additional textures.\n    let color2 = try! TextureResource.load(named: \"Octopus/Octopus_bc2\")\n    let mask = try! TextureResource.load(named: \"Octopus/Octopus_mask\")\n\n    // Load the surface shader.\n    let surfaceShader = CustomMaterial.SurfaceShader(named: \"octopusSurface\",\n                                                     in: library)\n\n    // Construct a new material with the contents of an existing material.\n    octopus.model!.materials = octopus.model!.materials.map { baseMaterial in\n        let material = try! CustomMaterial(from: baseMaterial\n                                           surfaceShader: surfaceShader)\n        // Assign additional textures.\n        material.emissiveColor.texture = .init(color2)\n        material.custom.texture = .init(mask)\n        return material\n    }\n}"
    },
    {
      "timestamp": "14:13",
      "title": "CoreImage PostEffect",
      "language": "swift",
      "code": "// Add RenderCallbacks to the ARView.\n\nvar ciContext: CIContext?\n\nfunc initPostEffect(arView: ARView)\n{\n    arView.renderCallbacks.prepareWithDevice = { [weak self] device in\n        self?.prepareWithDevice(device)\n    }\n    arView.renderCallbacks.postProcess = { [weak self] context in\n        self?.postProcess(context)\n    }\n}\n\nfunc prepareWithDevice(_ device: MTLDevice) {\n    self.ciContext = CIContext(mtlDevice: device)\n}\n\n// The CoreImage thermal filter.\nfunc postProcess(_ context: ARView.PostProcessContext) {\n    // Create a CIImage for the input color.\n    let sourceColor = CIImage(mtlTexture: context.sourceColorTexture)!\n\n    // Create the thermal filter.\n    let thermal = CIFilter.thermal()\n    thermal.inputImage = sourceColor\n        \n    // Create the CIRenderDestination.\n    let destination = CIRenderDestination(mtlTexture: context.targetColorTexture,\n                                          commandBuffer: context.commandBuffer)\n\n    // Preserve the image orientation.\n    destination.isFlipped = false\n\n    // Instruct CoreImage to start our render task.\n    _ = try? self.ciContext?.startTask(toRender: thermal.outputImage!, to: destination)\n}"
    },
    {
      "timestamp": "16:15",
      "title": "Bloom Post Effect",
      "language": "swift",
      "code": "var device: MTLDevice!\n    var bloomTexture: MTLTexture!\n\n    func initPostEffect(arView: ARView) {\n        arView.renderCallbacks.prepareWithDevice = { [weak self] device in\n            self?.prepareWithDevice(device)\n        }\n        arView.renderCallbacks.postProcess = { [weak self] context in\n            self?.postProcess(context)\n        }\n    }\n\n    func prepareWithDevice(_ device: MTLDevice) {\n        self.device = device\n    }\n\n    func makeTexture(matching texture: MTLTexture) -> MTLTexture {\n        let descriptor = MTLTextureDescriptor()\n        descriptor.width = texture.width\n        descriptor.height = texture.height\n        descriptor.pixelFormat = texture.pixelFormat\n        descriptor.usage = [.shaderRead, .shaderWrite]\n\n        return device.makeTexture(descriptor: descriptor)!\n    }\n\n    func postProcess(_ context: ARView.PostProcessContext) {\n        if self.bloomTexture == nil {\n            self.bloomTexture = self.makeTexture(matching: context.sourceColorTexture)\n        }\n\n        // Reduce areas of 20% brightness or less to zero.\n        let brightness = MPSImageThresholdToZero(device: context.device,\n                                                 thresholdValue: 0.2,\n                                                 linearGrayColorTransform: nil)\n        brightness.encode(commandBuffer: context.commandBuffer,\n                          sourceTexture: context.sourceColorTexture,\n                          destinationTexture: bloomTexture!)\n\n        // Blur the remaining areas.\n        let gaussianBlur = MPSImageGaussianBlur(device: context.device, sigma: 9.0)\n        gaussianBlur.encode(commandBuffer: context.commandBuffer,\n                            inPlaceTexture: &bloomTexture!)\n\n        // Add color plus bloom, writing the result to targetColorTexture.\n        let add = MPSImageAdd(device: context.device)\n        add.encode(commandBuffer: context.commandBuffer,\n                   primaryTexture: context.sourceColorTexture,\n                   secondaryTexture: bloomTexture!,\n                   destinationTexture: context.targetColorTexture)\n    }"
    },
    {
      "timestamp": "17:15",
      "title": "SpriteKit Post Effect",
      "language": "swift",
      "code": "// Initialize the SpriteKit renderer.\n    \n    var skRenderer: SKRenderer!\n\n    func initPostEffect(arView: ARView) {\n        arView.renderCallbacks.prepareWithDevice = { [weak self] device in\n            self?.prepareWithDevice(device)\n        }\n        arView.renderCallbacks.postProcess = { [weak self] context in\n            self?.postProcess(context)\n        }\n    }\n    \n    func prepareWithDevice(_ device: MTLDevice)\n        self.skRenderer = SKRenderer(device: device)\n        self.skRenderer.scene = SKScene(fileNamed: \"GameScene\")\n        self.skRenderer.scene!.scaleMode = .aspectFill\n    \n        // Make the background transparent.\n        self.skRenderer.scene!.backgroundColor = .clear\n    }\n    \n    func postProcess(context: ARView.PostProcessContext) {\n        // Blit (Copy) sourceColorTexture onto targetColorTexture.\n        let blitEncoder = context.commandBuffer.makeBlitCommandEncoder()\n        blitEncoder?.copy(from: context.sourceColorTexture, to: context.targetColorTexture)\n        blitEncoder?.endEncoding()\n    \n        // Advance the scene to the new time.\n        self.skRenderer.update(atTime: context.time)\n    \n        // Create a RenderPass writing to the targetColorTexture.\n        let desc = MTLRenderPassDescriptor()\n        desc.colorAttachments[0].loadAction = .load\n        desc.colorAttachments[0].storeAction = .store\n        desc.colorAttachments[0].texture = context.targetColorTexture\n    \n        // Render!\n        self.skRenderer.render(withViewport: CGRect(x: 0, y: 0, \n                                 width: context.targetColorTexture.width, \n                                 height: context.targetColorTexture.height),\n                                 commandBuffer: context.commandBuffer,\n                                 renderPassDescriptor: desc)\n    }"
    },
    {
      "timestamp": "19:08",
      "title": "ARKit AR Depth",
      "language": "swift",
      "code": "let width = context.sourceColorTexture.width\nlet height = context.sourceColorTexture.height\n\nlet transform =   \n  arView.session.currentFrame!.displayTransform(\n    for: self.orientation,\n    viewportSize: CGSize(width: width, height: height)\n  ).inverted()"
    },
    {
      "timestamp": "20:01",
      "title": "Depth Fog Shader",
      "language": "swift",
      "code": "typedef struct\n{\n    simd_float4x4 viewMatrixInverse;\n    simd_float4x4 viewMatrix;\n\n    simd_float2x2 arTransform;\n    simd_float2 arOffset;\n\n    float fogMaxDistance;\n    float fogMaxIntensity;\n    float fogExponent;\n} DepthFogParams;\n\nfloat linearizeDepth(float sampleDepth, float4x4 viewMatrix)\n{\n    constexpr float kDepthEpsilon = 1e-5f;\n\n    float d = max(kDepthEpsilon, sampleDepth);\n\n    // linearize (we have reverse infinite projection);\n    d = abs(-viewMatrix[3].z / d);\n\n    return d;\n}\n\nconstexpr sampler textureSampler(address::clamp_to_edge, filter::linear);\n\nfloat getDepth(uint2 gid,\n               constant DepthFogParams &args,\n               texture2d<float, access::sample> inDepth,\n               depth2d<float, access::sample> arDepth)\n{\n    // normalized coordinates\n    float2 coords = float2(gid) / float2(inDepth.get_width(), inDepth.get_height());\n\n    float2 arDepthCoords = args.arTransform * coords + args.arOffset;\n\n    float realDepth = arDepth.sample(textureSampler, arDepthCoords);\n    float virtualDepth = linearizeDepth(inDepth.sample(textureSampler, coords)[0], args.viewMatrix);\n\n    return min(virtualDepth, realDepth);\n}\n\n[[kernel]]\nvoid depthFog(uint2 gid [[thread_position_in_grid]],\n              constant DepthFogParams& args [[buffer(0)]],\n              texture2d<half, access::sample> inColor [[texture(0)]],\n              texture2d<float, access::sample> inDepth [[texture(1)]],\n              texture2d<half, access::write> outColor [[texture(2)]],\n              depth2d<float, access::sample> arDepth [[texture(3)]]\n)\n{\n    const half4 fogColor = half4(0.5, 0.5, 0.5, 1.0);\n\n    float depth = getDepth(gid, args, inDepth, arDepth);\n\n    // Ignore depth values greater than the maximum fog distance.\n    float fogAmount = saturate(depth / args.fogMaxDistance);\n    float fogBlend = pow(fogAmount, args.fogExponent) * args.fogMaxIntensity;\n\n    half4 nearColor = inColor.read(gid);\n    half4 color = mix(nearColor, fogColor, fogBlend);\n\n    outColor.write(color, gid);\n}"
    },
    {
      "timestamp": "23:32",
      "title": "MeshResource.Contents extension",
      "language": "swift",
      "code": "// Examine each vertex in a mesh.\n\nextension MeshResource.Contents {\n    func forEachVertex(_ callback: (SIMD3<Float>) -> Void) {\n        for instance in self.instances {\n            guard let model = self.models[instance.model] else { continue }\n            let instanceToModel = instance.transform\n            for part in model.parts {\n                for position in part.positions {\n                    let vertex = instanceToModel * SIMD4<Float>(position, 1.0)\n                    callback([vertex.x, vertex.y, vertex.z])\n                }\n            }\n        }\n    }\n}"
    },
    {
      "timestamp": "24:20",
      "title": "Mesh Radii",
      "language": "swift",
      "code": "struct Slices {\n    var radii : [Float] = []\n    var range : ClosedRange<Float> = 0...0\n\n    var sliceHeight: Float {\n        return (range.upperBound - range.lowerBound) / Float(sliceCount)\n    }\n\n    var sliceCount: Int {\n        return radii.count\n    }\n\n    func heightAt(index: Int) -> Float {\n        return range.lowerBound + Float(index) * self.sliceHeight + self.sliceHeight * 0.5\n    }\n\n    func radiusAt(y: Float) -> Float {\n        let relativeY = y - heightAt(index: 0)\n        if relativeY < 0 {\n            return radii.first!\n        }\n\n        let slice = relativeY / sliceHeight\n        let sliceIndex = Int(slice)\n\n        if sliceIndex+1 >= sliceCount {\n            return radii.last!\n        }\n\n        // 0 to 1\n        let t = (slice - floor(slice))\n\n        // linearly interpolate between two closest values\n        let prev = radii[sliceIndex]\n        let next = radii[sliceIndex+1]\n\n        return mix(prev, next, t)\n    }\n\n    func radiusAtIndex(i: Float) -> Float {\n        let asFloat = i * Float(radii.count)\n        var prevIndex = Int(asFloat.rounded(.down))\n        var nextIndex = Int(asFloat.rounded(.up))\n\n        if prevIndex < 0 {\n            prevIndex = 0\n        }\n\n        if nextIndex >= radii.count {\n            nextIndex = radii.count - 1\n        }\n\n        let prev = radii[prevIndex]\n        let next = radii[nextIndex]\n\n        let remainder = asFloat - Float(prevIndex)\n        let lerped = mix(prev, next, remainder)\n\n        return lerped + 0.5\n    }\n}\n\nfunc meshRadii(for mesh: MeshResource, numSlices: Int) -> Slices {\n    var radiusForSlice: [Float] = .init(repeating: 0, count: numSlices)\n\n    let (minY, maxY) = (mesh.bounds.min.y, mesh.bounds.max.y)\n    mesh.contents.forEachVertex { modelPos in\n        let normalizedY = (modelPos.y - minY) / (maxY - minY)\n        let sliceY = min(Int(normalizedY * Float(numSlices)), numSlices - 1)\n\n        let radius = length(SIMD2<Float>(modelPos.x, modelPos.z))\n        radiusForSlice[sliceY] = max(radiusForSlice[sliceY], radius)\n    }\n\n    return Slices(radii: radiusForSlice, range: minY...maxY)\n}"
    },
    {
      "timestamp": "25:58",
      "title": "Spiral Point",
      "language": "swift",
      "code": "// The angle between two consecutive segments.\nlet theta = (2 * .pi) / Float(segmentsPerRevolution)\n\n// How far to step in the y direction per segment.\nlet yStep = height / Float(totalSegments)\n\nfunc p(_ i: Int, radius: Float = 1.0) \n     -> SIMD3<Float>\n{\n    let y = yStep * Float(i)\n\n    let x = radius * cos(Float(i) * theta)\n    let z = radius * sin(Float(i) * theta)\n\n    return SIMD3<Float>(x, y, z)\n}"
    },
    {
      "timestamp": "26:37",
      "title": "Generate Spiral",
      "language": "swift",
      "code": "extension MeshResource {\n    static func generateSpiral(\n        radiusAt: (Float)->Float,\n        radiusAtIndex: (Float)->Float,\n        thickness: Float,\n        height: Float,\n        revolutions: Int,\n        segmentsPerRevolution: Int) -> MeshResource\n    {\n        let totalSegments = revolutions * segmentsPerRevolution\n        let totalVertices = (totalSegments + 1) * 2\n\n        var positions: [SIMD3<Float>] = []\n        var normals: [SIMD3<Float>] = []\n        var indices: [UInt32] = []\n        var uvs: [SIMD2<Float>] = []\n\n        positions.reserveCapacity(totalVertices)\n        normals.reserveCapacity(totalVertices)\n        uvs.reserveCapacity(totalVertices)\n        indices.reserveCapacity(totalSegments * 4)\n\n        for i in 0..<totalSegments {\n            let theta = Float(i) / Float(segmentsPerRevolution) * 2 * .pi\n            let t = Float(i) / Float(totalSegments)\n            let segmentY = t * height\n\n            if i > 0 {\n                let base = UInt32(positions.count - 2)\n                let prevInner = base\n                let prevOuter = base + 1\n                let newInner = base + 2\n                let newOuter = base + 3\n\n                indices.append(contentsOf: [\n                    prevInner, newOuter, prevOuter, // first triangle\n                    prevInner, newInner, newOuter // second triangle\n                ])\n            }\n\n            let radialDirection = SIMD3<Float>(cos(theta), 0, sin(theta))\n            let radius = radiusAtIndex(t)\n\n            var position = radialDirection * radius\n            position.y = segmentY\n\n            positions.append(position)\n            positions.append(position + [0, thickness, 0])\n\n            normals.append(-radialDirection)\n            normals.append(-radialDirection)\n\n            // U = in/out\n            // V = distance along spiral\n            uvs.append(.init(0.0, t))\n            uvs.append(.init(1.0, t))\n        }\n\n        var mesh = MeshDescriptor()\n        mesh.positions = .init(positions)\n        mesh.normals = .init(normals)\n        mesh.primitives = .triangles(indices)\n        mesh.textureCoordinates = .init(uvs)\n\n        return try! MeshResource.generate(from: [mesh])\n    }\n}"
    },
    {
      "timestamp": "28:17",
      "title": "Update Spiral",
      "language": "swift",
      "code": "if var contents = spiralEntity?.model?.mesh.contents {\n    contents.models = .init(contents.models.map { model in\n        var newModel = model\n        newModel.parts = .init(model.parts.map { part in\n            let start = min(self.allIndices.count, max(0, numIndices - stripeSize))\n            let end = max(0, min(self.allIndices.count, numIndices))\n\n            var newPart = part\n            newPart.triangleIndices = .init(self.allIndices[start..<end])\n            return newPart\n        })\n        return newModel\n    })\n    try? spiralEntity?.model?.mesh.replace(with: contents)\n}"
    }
  ],
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "Building an Immersive Experience with RealityKit",
        "url": "https://developer.apple.com/documentation/realitykit/building_an_immersive_experience_with_realitykit"
      },
      {
        "title": "Creating a fog effect using scene depth",
        "url": "https://developer.apple.com/documentation/ARKit/creating-a-fog-effect-using-scene-depth"
      },
      {
        "title": "Displaying a point cloud using scene depth",
        "url": "https://developer.apple.com/documentation/ARKit/displaying-a-point-cloud-using-scene-depth"
      },
      {
        "title": "Explore the RealityKit Developer Forums",
        "url": "https://developer.apple.com/forums/tags/realitykit"
      },
      {
        "title": "RealityKit",
        "url": "https://developer.apple.com/documentation/RealityKit"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2021/10075/6/81A03814-3C6E-4B82-A5BB-92160CD0EF78/downloads/wwdc2021-10075_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2021/10075/6/81A03814-3C6E-4B82-A5BB-92160CD0EF78/downloads/wwdc2021-10075_sd.mp4?dl=1"
  },
  "relatedVideos": [
    {
      "id": "10128",
      "year": "2022",
      "title": "Bring your world into augmented reality",
      "url": "https://developer.apple.com/videos/play/wwdc2022/10128"
    },
    {
      "id": "10141",
      "year": "2022",
      "title": "Explore USD tools and rendering",
      "url": "https://developer.apple.com/videos/play/wwdc2022/10141"
    },
    {
      "id": "10074",
      "year": "2021",
      "title": "Dive into RealityKit 2",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10074"
    },
    {
      "id": "10612",
      "year": "2020",
      "title": "What's new in RealityKit",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10612"
    }
  ],
  "extractedAt": "2025-07-18T10:32:08.258Z"
}