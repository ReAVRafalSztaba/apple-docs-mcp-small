{
  "id": "10110",
  "year": "2024",
  "url": "https://developer.apple.com/videos/play/wwdc2024/10110/",
  "title": "Implement App Store Offers",
  "speakers": [],
  "duration": "",
  "topics": [
    "App Services",
    "App Store, Distribution & Marketing"
  ],
  "hasTranscript": true,
  "hasCode": true,
  "transcript": {
    "fullText": "Hello, and welcome to Implement App Store Offers. I'm Xiaolan, an engineer from App Store Connect. Hello, I'm Ricky, and I'm an engineer on the StoreKit team. Today, we are excited to share all the great updates to App Store offers, and how you can engage customers with these features. First, let's do a quick recap of App Store offers. For a business that is subscription-based, retaining customers is very important for long-term success. App Store offers are a great way to acquire, retain, and re-engage your customers. With App Store offers, you can give eligible customers a free or discounted price on subscriptions for a limited period of time.\n\nThere are three types of offers in the App Store: introductory offers, promotional offers, and offer codes.\n\nSetting up introductory offers give new subscribers an opportunity to try your subscription with a free trial or with a discounted price.\n\nPromotional offers are more flexible. You can create unique discounts, and define your own eligibility criteria based on your business requirements. And with offer codes, you can use the unique one-time-use codes that App Store generated for you or create your own custom codes, to distribute through your own marketing channels. We have a lot of enhancements for subscription offer StoreKit APIs, including a new offer member in Transaction and RenewalInfo, and new support for Offer Codes in macOS. There are some key APIs in StoreKit that make supporting offers in your app really straight-forward, and we have some improvements to share that make these APIs even better.\n\nTo start, we made enhancements to the Transaction and RenewalInfo APIs, in both StoreKit and the App Store server APIs. The Transaction structure is important for understanding purchases a customer makes in your app. The RenewalInfo structure tells you about the future of their subscription status.\n\nIn Transaction, a new member called offer is a new type containing all offer-related information: such as the ID of the offer, the type, the paymentMode, which tells you if the offer is a free trial, pay as you go, or pay up front.\n\nThe offer member is optional, which means that StoreKit includes it in the transaction only if a customer redeems an offer when they purchase a subscription.\n\nThis new API is available in StoreKit starting in iOS 17.2. The offer member is also available in the RenewalInfo API, starting in iOS 18.0. StoreKit will populate it if the subscription's next renewal period has an offer applied to it.\n\nIf you use App Store server APIs, the same offer data is available in three fields found in the JWSTransaction and JWSRenewalInfo APIs.\n\nThose fields are the offerIdentifier, and offerType, which are already present today. And the offerDiscountType field, which is new and is available for historical transactions as well.\n\nThe value of offerDiscountType is similar to the payment mode in the StoreKit APIs, and it tells you if the offer is a free trial, pay as you go, or pay up front.\n\nFor more information about the App Store server APIs, check out Explore App Store server APIs for In-App Purchase.\n\nNext, if your app uses StoreKit Views to merchandise subscriptions, there is a new view modifier that allows you to show a promotional offer in the UI of a SubscriptionStoreView.\n\nThe view modifier is called subscriptionPromotionalOffer.\n\nUse this new view modifier to decide whether your view should display a promotional offer.\n\nStoreKit provides you with the list of the promotional offers for this product, so you can focus your logic on deciding which offer to return.\n\nThen generate the signature for the offer you select, and return it. StoreKit takes care of displaying the details in the UI and adds the offer to the purchase if your customer chooses to subscribe.\n\nCheck the related documentation for this session for information about supporting promotional offers and generating a signature.\n\nLastly, macOS 15.0 now joins iOS and visionOS to support presenting the offer code redemption sheet.\n\nIn SwiftUI apps, you can present the offer code redemption sheet using the same API as iOS.\n\nThat covers our new StoreKit APIs for existing subscription offers. This year, we have a new offer type to re-gain previous subscribers. We are excited to introduce win-back offers, a way to make it easier for you to reach previous subscribers of your app. You can set up win-back offers using the customer eligibility criteria provided by App Store, and you are also able to take advantage of App Store-owned channels to promote your win-back offers. Win-back offers focus on re-engaging churned subscribers, when their subscription has expired and they disabled auto-renew.\n\nInstead of handling and verifying customer eligibility in your app, with win-back, you are able to segment your customers based on specific rules and criteria through the App Store. You can effectively build new offers that are more relevant to your customers.\n\nLike existing offers, you are able to promote win-back offers through your own marketing channels.\n\nWin-back offers automatically appear in their Subscriptions page, and you can promote win-back offers on the App Store. Here's an example. The App Store presents a new win-back offer in a card. A win-back offer card contains a description of the offer with its price details, and the information about the subscription the offer applies to.\n\nCustomers can discover win-back offers on your product page, where the App Store displays eligible offers.\n\nWhen a customer taps the offer card, a detailed page appears containing a longer description and a larger image. The detailed page give customers additional context about the offer.\n\nOur editorial team may feature your win-back offers when they build personalized recommendations for customers on the Today, Games, and Apps tabs.\n\nAnd lastly, customers can find eligible win-back offers on their Subscriptions page. Today, I will give a deep dive of win-back offers and guide you through App Store Connect configuration. Then Ricky will show you how to support and test win-back offers in your app with examples. And last, we'll talk about the streamlined purchasing experience, and how you can support it in your app.\n\nTo begin, let's take a closer look at win-back offers. Just like the existing offers, when creating a win-back offer, choose either pay-as-you-go, pay-up-front, or free trial. Based on different type and your subscription, you are able to select different duration for your offer. You have control when your win-back offer would be available to customers, and you have option to specify an offer end date. With the offer priority configuration, you can specify whether to display this offer ahead of normal priority events and offers. It is also one of the factors used to personalize win-back recommendations on the App Store. In addition, you can decide which specific countries and regions can receive this offer. Use the App Store Connect pricing tool to help you set a price for each country or region that you select.\n\nWin-back offers support different customer eligibility criteria including paid subscription duration, time since last subscribed, and wait between offers.\n\nPaid Subscription Duration refers to the amount of time that the customer had paid for your service. This allows you to offer discounts based on how long the customer has been subscribed.\n\nYou can specify a minimum value in months.\n\nOnly the most recent consecutive months of paid service are considered.\n\nThe duration includes the time that a customer subscribes to any subscription in a group. Upgrades and downgrades in the same subscription group don't affect the eligibility calculations.\n\nTime since last subscribed indicates the time that has passed since the most recent active subscription. It requires a minimum and maximum value in months. This enables you to apply different strategies to re-engage churned customers based how long they have been unsubscribed. Let me explain the detail with an example. Our Destination Video app has a subscription group called Streaming Pass. It offers two monthly plans, Basic and Premium.\n\nThis win-back offer that gives eligible customers one month of free access to the Basic subscription. In order for a customer to be eligible for this offer, the customer must have paid for the subscription for at least three months, the subscription must have been active between 2 and 24 months ago. And at least six months have passed since the customer last redeemed this offer.\n\nLet's look at this from a customer's perspective. First, the customer subscribed to the Premium plan.\n\nThen they downgraded to the Basic plan.\n\nFinally, two months later, the customer canceled the subscription. At this point, the customer has fulfilled the paid subscription duration eligibility requirement for this win-back offer.\n\nAfter this cancelation, we begin calculating the time since last subscribed.\n\nAfter two months, the customer is eligible for the win-back offer, because we set the minimum time since last subscribed to two months.\n\nNow let's talk about wait between offers. This is an optional requirement, which allows you to set the minimum amount of time that customer must wait before they can redeem the offer again.\n\nAfter the win-back offer period ends, the wait between offers begins.\n\nThen the customer renews the subscription.\n\nThe customer canceled the subscription after three months.\n\nTime since last subscribed calculation begins after the cancelation.\n\nTwo months after the cancelation, they meet the requirement of time since last subscribed. However, because the customer had redeemed the offer before and it requires at least six months of wait between offers, they would be eligible for the win-back offer six months after the offer ended.\n\nSo that's an overview of win-back offers and how customer eligibility criteria works. Now, let's go through setting up win-back offers in App Store Connect.\n\nTo create a win-back offer for an existing subscription, first navigate to the subscription pricing page.\n\nThere, you will find a new tab called Win-Back Offers. When you click on it for the first time, you are presented with a page like this one. Click the Create Offer button to start configuring a new win-back offer, and a modal view will appear. The first step is to enter your offer's reference name and offer identifier. Both fields need to be unique within your subscription group. Your app uses the offer identifier when it talks to the StoreKit APIs. And you cannot modify these fields after you create them. Use a consistent naming convention for your offers to make your development work easier. The next step is to select a start date and end date, the offer priority, and to define your customer eligibility criteria.\n\nA start date is required to publish your offer to the App Store.\n\nYou can adjust the offer priority at any time. And finally, specify the eligibility to choose when a customer can become eligible for the offer based on these criteria. You can adjust all of these settings before the offer is live, but they are locked after the offer start date.\n\nIn the next step, you select the countries and regions where the offer would be available. Then, choose if the offer should be a pay-as-you-go, pay-up-front, or free type. And, select the duration.\n\nIf this is a paid offer, also select a price based on your default currency from the drop down. Using your selected price, App Store Connect presents you with the best matching prices for each of the countries and regions you select for the offer. You can adjust them by clicking their respective drop-down menu. The offer price settings cannot be changed after the offer is created.\n\nAnd at last, you can review and confirm the win-back offer details. If you want to update the settings, click the back button to revisit previous steps.\n\nIf the configuration looks good, click Confirm to complete the creation of this new offer.\n\nNow that your win-back offer exists, you can promote this offer in your own marketing channels and on the App Store.\n\nHere, we also include an offer link.\n\nThis allows you to distribute the offer through your own marketing channels.\n\nIf you would like to promote your win-back offers on the App Store, there are a few setup details to configure for your subscription.\n\nOn the offer details page, there's a section called: Promote on the App Store If your subscription doesn't have an image, you will see this. Click the link to upload an image for your subscription.\n\nThen, go to your subscription details page to submit the image to App Review.\n\nOnce you have an approved image for your subscription, and you enabled App Store promotion for your offer, win-back offer is promoted automatically in the App Store once offer is live.\n\nIf your offer has not yet gone live, you can cancel it from being promoted on the App Store. However, once the win-back offer is live, you need to delete the win-back offer to make it no longer show up on the App Store.\n\nOn the App Store, a promoted win-back offer appears in the detail view as a new offer card. We combine your approved subscription image and your app icon to create a new image, like this one.\n\nAnd that's how you can set up win-back offers in App Store Connect for your subscription. App Store Connect API 3.6 provides resources to set up your win-back offers with your own custom flows.\n\nThe new WinBackOffers APIs include endpoints that create, read, update, and delete the win-back offer. You can easily manage your offer process using these APIs. We also added two new image resources for subscription and inAppPurchase. With this, we also deprecated the existing PromotedPurchaseImages resource. Now that you’re familiar with setting up win-back offers in App Store Connect, here’s Ricky to discuss supporting win-back offers with a StoreKit 2. Thank you Xiaolan for explaining how to configure win-back offers in App Store Connect. The next step is to use StoreKit 2 to add code in your app for supporting these new offers. First, let’s review how to distinguish a win-back offer from the other existing offer types. StoreKit 2 uses the OfferType model to identify a SubscriptionOffer type. The supported types are: introductory, promotional, and starting with iOS 18.0: Win-back. The pricing and duration of offers in the app can be found in the subscription info under the Product model, where there are members for each of the available offer types: an introductory offer, if there are any, a list of promotional offers, and a list of Win-back offers available starting in iOS 18.0. This information is important when building support for offers in your app, and you can use it to tell what kind of offer a SubscriptionOffer object is, and to fetch information of specific offer types configured for a subscription. Now, let’s review how to add support to merchandise and purchase subscriptions using win-back offers.\n\nThe StoreKit Message API is the fastest and easiest way to show a win-back offer to your customers. StoreKit views provides options to build great merchandising UI and display your subscription along with the details of any offer. And lastly, for those of you wanting more control over your subscription merchandising and UI, you can use the core StoreKit 2 APIs. You can choose one or more of these options depending on the level of customization you would like to achieve.\n\nWhen your app receives a winBackOffer message, StoreKit presents your customer a sheet like this one, detailing the subscription and the offer pricing, and they can choose to accept and re-subscribe to your service using the button below.\n\nTo support this, the Message API now features a new Reason called winBackOffer.\n\nYour app receives this message automatically when your customer is eligible for a win-back offer.\n\nMake sure you’re also listening for transaction updates in your app, so you can be notified of their purchase and grant them access to the content it unlocks.\n\nSoon you can test win-back offers in sandbox by navigating to your iOS sandbox account settings. Enable the Display Win-back Offers switch to receive a message in your app when you become eligible for a new offer.\n\nThat covers how to support win-back offers in your app in iOS 18.0 using StoreKit Message, and how to test it in sandbox.\n\nIf you want to have more customization in your merchandising UI, we showed you how to use StoreKit Views at WWDC23, which are beautiful, ready-to-use APIs to display and merchandise your in-app purchases. StoreKit views automatically supports displaying the pricing details for all subscription offers in SubscriptionStoreViews when your customers are eligible, including win-back offers. So there is no extra work needed. Sometimes, a customer can have more than one eligible offer available, and you may need to run some extra logic to decide which offer to display in your view. To achieve this, we have a new view modifier in StoreKit views called: preferredSubscriptionOffer.\n\nUse preferredSubscriptionOffer in combination with a SubscriptionStoreView to take control over which offer to use when there is more than one available, and StoreKit will handle fetching the offer metadata and setting up the purchase for you.\n\nHere’s how to use this new view modifier in a SubscriptionStoreView.\n\nI set up a SwiftUI view to merchandise my subscription plan in the Destination Video app using the subscription group ID for the Streaming Pass plan. The SubscriptionStoreView automatically displays the details of available offers, such as this monthly plan. Here you can see the pricing for the offer StoreKit chose automatically.\n\nI can add the preferredSubscriptionOffer modifier to check for any other available offers and decide which one to display.\n\nThe preferredSubscriptionOffer API takes a single parameter: a function that StoreKit calls for each subscription in the group. In this function, StoreKit provides you with: the product object, the subscription info, and a list of all offers that the customer is eligible for right now.\n\nThis is all the information you need from StoreKit to run your own logic and decide which offer to use. When you have one picked out, return the SubscriptionOffer object here.\n\nKeep in mind that if you return nil and the subscription has an introductory offer that the customer is eligible for, the app always displays the introductory offer in the view. In this example, I look for the offer that provides the longest free trial. If there is no free trial offer, I pick the first offer in the list instead. In your app, you may want to add more logic here based on the offer's price and duration. Since the customer is eligible for a three-month free trial offer for the monthly subscription, you can see the new pricing details reflected in the SwiftUI view.\n\nAnd that’s how to customize SubscriptionStoreViews to display different offers to your customers. If you need more control over the subscription's merchandising or want to create custom UI, you can use the core StoreKit APIs, and manage the offer merchandising yourself.\n\nEarlier I showed where you can find the offer details in the Product model, but there is also an eligibility aspect to win-back offers that is different from customer to customer. And Xiaolan showed you how to configure this eligibility in App Store Connect.\n\nTo simplify things and help you display the correct offers to customers, StoreKit provides a personalized list of eligible win-back offers for each customer via a new API called: eligibleWinBackOfferIDs.\n\nYou can find this new API in the RenewalInfo object of the subscription status model, and quickly access a list of IDs for win-back offers your customer can redeem immediately. Use this list to search for the corresponding offer in the subscription info, and display the pricing details in your view.\n\nI’ll demonstrate how to add support for win-back offers in Destination Video using these new APIs. I have existing logic in my app to check for the subscription status and the introductory offer eligibility, before I display any merchandising to a customer. To do that, I use this function to determine the customer’s current subscription status and if they are eligible for any offer. The function takes two parameters: the group ID of the subscription I want to check the status for, and a list of its product IDs.\n\nThe first thing I do is fetch the current status of the subscription.\n\nI then use a data structure I previously created to parse it and determine if the customer is entitled to the service and has auto-renewal enabled.\n\nWith this information, I can decide if I need to show any merchandising UI using this enum.\n\nIf the customer has auto-renewal enabled, I return a flag to not show any merchandising.\n\nIf the customer is not currently subscribed, then I can show my merchandising UI. In that case, I first load the products for the subscriptions I want to merchandise. Then, I need to make sure if the customer is eligible for an introductory offer, and if they are, return the subscription products and the offer to show in the view.\n\nIf they are not eligible for an introductory offer, I can look at a subscriptions status I previously retrieved to see if they are eligible for a win-back offer instead.\n\nSince win-back offers are only available for customers that are no longer subscribed to this product, I need to look at the status for a subscription they owned, as they might also have access to the service via Family Sharing.\n\nThe win-back offer eligibility can be found in the renewal info for that subscription status. With this information, I can look for the best win-back offer id, which is always the first object in the list, but you may want to look at the other available offers if there are more than one. If there is at least one win-back offer, I can return that along with its respective product for my customer to redeem. To have the offer details I need to create the view, I can search for the SubscriptionOffer object in the list of all offers in the subscription info.\n\nIf the list of eligible win-back offer IDs is empty, that means the customer is not eligible for any offer, so I can show the merchandising view with the regular subscription pricing.\n\nThat’s how to check if your customer is eligible for a win-back offer alongside your existing subscription status workflow. Once the customer chooses to redeem the offer, the last thing you need to do is add the win-back offer to the purchase.\n\nDoing so is straight-forward. In iOS 18.0 you can use the new PurchaseOption API called winBackOffer Use it to add the SubscriptionOffer object that represents a win-back offer to a purchase. Then pass the purchase options to the purchase API. The App Store checks if the customer is eligible for the offer, before StoreKit shows the payment sheet in the app.\n\nAnd that’s all for supporting win-back offers in your app! StoreKit Message is the quickest option to show a win-back offer to your customers. With StoreKit views, you might not need to add any code depending on your specific case, and you can also create gorgeous subscription merchandising UI. To learn more about other new features in StoreKit views, check out our 2024 session, \"What’s new in StoreKit and In-App Purchase.\" If you require creating custom workflows and UI for your app and subscription service, you can use the new StoreKit APIs in SubscriptionStatus and SubscriptionInfo to find the appropriate offer for your customer and display it in your own merchandising view.\n\nAfter adding code into your app for supporting win-back offers, you’ll need to test under different scenarios and with different subscription statuses. You can test all supported methods to implement win-back offers in sandbox, and I previously discussed how to test the win-back offer StoreKit Message.\n\nIf you decide to use either StoreKit views, the core StoreKit APIs, or a combination of both, those are also testable using StoreKit Testing in Xcode, which is also the quickest way to test offers while developing your app.\n\nHere’s what’s new in Xcode to help you test win-back offers in your app today.\n\nTo configure win-back offers in Xcode, first open the StoreKit configuration where you have setup you local in-app purchases. Then find your subscription under the Auto-Renewable Subscriptions heading and scroll down to the Win-back Offers section, where you’ll see a table.\n\nClick the plus (+) button to configure a new offer, and input the required details: a name for the offer, the offer ID, and as with all other offer types, the payment mode, duration, and price, if applicable.\n\nIn App Store Connect, you can configure the eligibility of a win-back offer based on different rules, states, and conditions your customers need to meet before they can redeem the offer. To test the outcome of the customer eligibility quickly and efficiently, we added a toggle in Xcode to change the eligibility per offer, so you don’t need to worry about subscription statuses, and other eligibility criteria.\n\nUse this customer eligibility toggle to decide if you should receive the win-back offer in your app when you churn from a subscription. And change it while debugging to test different scenarios of the customer’s offer eligibility to see how your app reacts to them.\n\nBy clicking save, I've now setup a new win-back offer for this subscription. To configure more offers, repeat these steps using different settings based on your testing needs.\n\nAnd that’s it, I am now ready to start testing win-back offers in my app. StoreKit Testing in Xcode is a great tool for testing subscription offers, and you can quickly test different settings and customer states for win-back offers. Thanks Ricky! The last topic is about a streamlined purchasing experience that we added to win-back offers. I already showed how you can promote win-back offers on the App Store. When you promote a win-back offer, customers can redeem the offer and subscribe to your service all at once on the App Store, using a feature called streamlined purchasing. Streamlined purchasing is enabled for your app by default. You can configure the setting through App Store Connect.\n\nIf you use streamlined purchasing for win-back offers in your app, when a customer taps the Subscribe button to redeem an offer, the App Store will present a payment sheet. Here, customers can review the subscription and offer details. Once the customer confirms and completes the purchase, and the customer opens the app, they will have access to the subscription service immediately. You might need certain customer actions to happen in your app before you can continue with the purchase and redeem the win-back offer. In that case, you can turn off the streamlined purchasing for your win-back offers, using a setting in App Store Connect. Go to your subscriptions page, where you can see a new section to configure Streamlined Purchasing under Billing Grace Period. Click the edit button, and you can choose to turn off streamlined purchasing.\n\nIf you turn off streamlined purchasing, the App Store sends the purchase directly to your app, where you can create a custom experience. To support this, you need to make some changes in your app.\n\nIf you decide to turn off streamlined purchasing, but still want to promote win-back offers on the App Store, you need to setup some code in your app to receive purchases that your customers initiated on the App Store. You can do this using the PurchaseIntent API we discussed at WWDC23. The App Store sends a purchase intent when a customer begins a purchase outside of your app, like a promoted in-app purchase, or a win-back offer. When you receive a new purchase intent you can either continue the purchase immediately and show the payment sheet, or store the intent for later use.\n\nPurchaseIntent can be used to receive win-back offers that your customers started to redeem on the App Store. To support this, a new member called offer is available in iOS 18.0 and macOS 15.0. This is an optional SubscriptionOffer type, and it is only populated for purchase intents that contain a win-back offer.\n\nWhen you receive a purchase intent with a win-back offer, use the provided offer information to show the complete offer details and merchandising to the customer. Then, start a purchase as normal, and add the selected offer to the purchase options.\n\nIn Xcode 16, use StoreKit Testing in Xcode to test your purchase intent listener and deferral logic. Check out the StoreKit session, “What’s new in StoreKit and In-App Purchase”, where Rudy will go into more detail.\n\nAnd that is all for streamlined purchasing for win-back offers, and how to handle these purchases in the app if you need to turn off this feature. And that’s all we have for today! We discussed new and updated subscription offer APIs in StoreKit. We also gave you an overview of win-back offers and demonstrated how you can configure them, with multiple ways to support this new offer type in your app. And lastly, we showed how to promote win-back offers on the App Store, and how customers can redeem the offers using streamlined purchasing.\n\nYou can start adding support and test win-back offers in your app today. We are looking forward to seeing the new experiences that you will create, and please share your feedback using Feedback Assistant. If you are interested in learning more, visit our developer website for documentation. There are many other great sessions you don’t want to miss, please check out “What’s new in StoreKit and In-App Purchase” and “What’s new in App Store Connect”! I hope this session inspired you to add offers into your app. Thank you for joining us.",
    "segments": []
  },
  "codeExamples": [
    {
      "timestamp": "4:25",
      "title": "Present offer code redemption sheet on macOS - SwiftUI API",
      "language": "swift",
      "code": "// Present offer code redemption sheet on macOS - SwiftUI API\n\nimport SwiftUI\nimport StoreKit\n\nstruct MyView: View {\n\n    @State var showOfferCodeRedemption: Bool = false\n\n    var body: some View {\n        Button(\"Redeem Code\") {\n            showOfferCodeRedemption = true\n        }\n        .offerCodeRedemption(isPresented: $showOfferCodeRedemption) { result in\n            // Handle result\n        }\n    }\n}"
    },
    {
      "timestamp": "20:15",
      "title": "Choose preferred offer in a SubscriptionStoreView",
      "language": "swift",
      "code": "// Choose preferred offer in a SubscriptionStoreView\n\nimport SwiftUI\nimport StoreKit\n\nstruct MyView: View {\n    let groupID: String\n    \n    var body: some View {\n        SubscriptionStoreView(groupID: groupID)\n            .preferredSubscriptionOffer { product, subscription, eligibleOffers in\n                let freeTrialOffer = eligibleOffers\n                    .filter { $0.paymentMode == .freeTrial }\n                    .max { lhs, rhs in\n                        lhs.period.value < rhs.period.value\n                    }\n                return freeTrialOffer ?? eligibleOffers.first\n            }\n    }\n}"
    },
    {
      "timestamp": "23:05",
      "title": "Check subscription entitlement and offer eligibility",
      "language": "swift",
      "code": "// Check subscription entitlement and offer eligibility\n\nimport StoreKit\n\nfunc shouldShowMerchandising(\n    for groupID: String,\n    productIDs: [Product.ID]\n) async throws -> MerchandisingVisibility {\n    // Get subscription status\n    let statuses = try await Product.SubscriptionInfo.status(for: groupID)\n    \n    // Check if the customer is already entitled to the subscription\n    let entitlement = SubscriptionEntitlement(for: statuses)\n    if entitlement.autoRenewalEnabled {\n        return .hidden\n    }\n    \n    // Check for offers to show in merchandising UI\n    let products = try await Product.products(for: productIDs)\n    \n    let isEligibleForIntroOffer = await Product.SubscriptionInfo.isEligibleForIntroOffer(for: groupID)\n    if isEligibleForIntroOffer {\n        let subscriptions = products.map {\n            ($0, $0.subscription?.introductoryOffer)\n        }\n        return .visible(subscriptions)\n    }\n    \n    // Check for eligible win-back offers\n    let purchasedStatus = statuses.first {\n        $0.transaction.unsafePayloadValue.ownershipType == .purchased\n    }\n    let renewalInfo = try purchasedStatus?.renewalInfo.payloadValue\n    let bestWinBackOfferID = renewalInfo?.eligibleWinBackOfferIDs.first\n    \n    // Return the product with the offer if there is one\n    if let bestWinBackOfferID {\n        let subscriptions: [(Product, Product.SubscriptionOffer?)] = products.map {\n            let winBackOffer = $0.subscription?.winBackOffers.first {\n                $0.id == bestWinBackOfferID\n            }\n            return ($0, winBackOffer)\n        }\n        return .visible(subscriptions)\n    }\n    \n    // Only return the product if there is no offer\n    return .visible(products.map { ($0, nil) })\n}\n\nstruct SubscriptionEntitlement {\n    let isEntitled: Bool\n    let autoRenewalEnabled: Bool\n    \n    init(for statuses: [Product.SubscriptionInfo.Status]) {\n        let entitledStatuses = statuses.filter {\n            $0.state == .subscribed || $0.state == .inBillingRetryPeriod || $0.state == .inGracePeriod\n        }\n        isEntitled = !entitledStatuses.isEmpty\n        autoRenewalEnabled = entitledStatuses.contains {\n            $0.renewalInfo.unsafePayloadValue.willAutoRenew\n        }\n    }\n}\n\nenum MerchandisingVisibility {\n    case hidden\n    case visible([(Product, Product.SubscriptionOffer?)])\n}"
    },
    {
      "timestamp": "25:26",
      "title": "Add a win-back offer to a purchase",
      "language": "swift",
      "code": "// Add a win-back offer to a purchase\n\nimport StoreKit\n\nfunc purchase(\n    _ product: Product,\n    with offer: Product.SubscriptionOffer?\n) async throws {\n    // Prepare the purchase options\n    var purchaseOptions: Set<Product.PurchaseOption> = []\n    \n    // Add win-back offer to the purchase\n    if let offer, offer.type == .winBack {\n        purchaseOptions.insert(.winBackOffer(offer))\n    }\n    \n    // Make the purchase\n    try await product.purchase(options: purchaseOptions)\n}"
    }
  ],
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "Forum: App Store Distribution & Marketing",
        "url": "https://developer.apple.com/forums/topics/app-store-distribution-and-marketing?cid=vf-a-0010"
      },
      {
        "title": "Generating a signature for promotional offers",
        "url": "https://developer.apple.com/documentation/StoreKit/generating-a-signature-for-promotional-offers"
      },
      {
        "title": "Merchandising win-back offers in your app",
        "url": "https://developer.apple.com/documentation/StoreKit/merchandising-win-back-offers-in-your-app"
      },
      {
        "title": "Message",
        "url": "https://developer.apple.com/documentation/StoreKit/Message"
      },
      {
        "title": "offer",
        "url": "https://developer.apple.com/documentation/StoreKit/Transaction/offer-swift.property"
      },
      {
        "title": "PurchaseIntent",
        "url": "https://developer.apple.com/documentation/StoreKit/PurchaseIntent"
      },
      {
        "title": "Setting up StoreKit Testing in Xcode",
        "url": "https://developer.apple.com/documentation/Xcode/setting-up-storekit-testing-in-xcode"
      },
      {
        "title": "StoreKit views",
        "url": "https://developer.apple.com/documentation/StoreKit/storekit-views"
      },
      {
        "title": "Supporting subscription offer codes in your app",
        "url": "https://developer.apple.com/documentation/StoreKit/supporting-subscription-offer-codes-in-your-app"
      },
      {
        "title": "Supporting win-back offers in your app",
        "url": "https://developer.apple.com/documentation/StoreKit/supporting-win-back-offers-in-your-app"
      },
      {
        "title": "Testing win-back offers in the sandbox environment",
        "url": "https://developer.apple.com/documentation/StoreKit/testing-win-back-offers-in-the-sandbox-environment"
      },
      {
        "title": "Testing win-back offers in Xcode",
        "url": "https://developer.apple.com/documentation/StoreKit/testing-win-back-offers-in-xcode"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2024/10110/4/D12EC56F-E036-4B66-BC08-8F01A5D49690/downloads/wwdc2024-10110_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2024/10110/4/D12EC56F-E036-4B66-BC08-8F01A5D49690/downloads/wwdc2024-10110_sd.mp4?dl=1"
  },
  "relatedVideos": [
    {
      "id": "10062",
      "year": "2024",
      "title": "Explore App Store server APIs for In-App Purchase",
      "url": "https://developer.apple.com/videos/play/wwdc2024/10062"
    },
    {
      "id": "10063",
      "year": "2024",
      "title": "What’s new in App Store Connect",
      "url": "https://developer.apple.com/videos/play/wwdc2024/10063"
    },
    {
      "id": "10061",
      "year": "2024",
      "title": "What’s new in StoreKit and In-App Purchase",
      "url": "https://developer.apple.com/videos/play/wwdc2024/10061"
    },
    {
      "id": "10013",
      "year": "2023",
      "title": "Meet StoreKit for SwiftUI",
      "url": "https://developer.apple.com/videos/play/wwdc2023/10013"
    },
    {
      "id": "10140",
      "year": "2023",
      "title": "What’s new in StoreKit 2 and StoreKit Testing in Xcode",
      "url": "https://developer.apple.com/videos/play/wwdc2023/10140"
    }
  ],
  "extractedAt": "2025-07-18T09:11:34.795Z"
}