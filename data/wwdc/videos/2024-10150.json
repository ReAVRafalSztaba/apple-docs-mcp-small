{
  "id": "10150",
  "year": "2024",
  "url": "https://developer.apple.com/videos/play/wwdc2024/10150/",
  "title": "SwiftUI essentials",
  "speakers": [],
  "duration": "",
  "topics": [
    "Essentials"
  ],
  "hasTranscript": true,
  "hasCode": true,
  "transcript": {
    "fullText": "Hi, my name is Taylor. Welcome to SwiftUI essentials! SwiftUI is Apple's declarative user interface framework, used to build apps across all of Apple's platforms. It's been adopted broadly within Apple as the basis for brand new apps and through incremental adoption within existing ones. And when you are building a new app or a new feature, SwiftUI is the right tool to use. There are a few reasons for this. SwiftUI comes with a wide range of features. These enable your apps to take advantage of the devices they run on, feel native on Apple's platforms, and add rich interactivity. And adding those features requires, less code. Enabling you to move from prototype to production faster, and empowering you to focus on what makes your app unique. SwiftUI embraces, incremental adoption, so you can take advantage of it, exactly where you need it.\n\nThere is no expectation that an entire app needs to be SwiftUI to be able to take advantage of it. These qualities makes it easy for anyone to learn how to build an app using SwiftUI. And understanding how SwiftUI enables these qualities can help you understand how to best take advantage of them. I'm going to start with explaining the very basics of how views work. Later on, I'll highlight some of the capabilities built-in to SwiftUI and how they work across Apple's platforms. And at the very end, I'll discuss SwiftUI's ability to integrate with other frameworks.\n\nBut before getting started, I have one more insight about SwiftUI and those working on it We love our pets, and we frequently debate which kind is best. I've decided to resolve this in the most objective way possible which pet can do the best tricks. And there is some tough competition.\n\nOver the course of this video, I'll be using SwiftUI to build an app for tracking our pets, their tricks, and how they stack up. But I need to start somewhere and in SwiftUI, that's going to be with a View.\n\nViews are the basic building blocks of user interfaces, and are important to everything you do in SwiftUI. Every pixel you see onscreen is in some way defined by a view. There are three qualities that make SwiftUI views special: they're declarative, compositional, and state-driven. Views are expressed declaratively.\n\nYou describe what view you want in your user interface, and SwiftUI produces the result. You can create text, Images using SF Symbols, and controls, like buttons.\n\nThis code creates a horizontal stack that consists of a label, which is a combination of an icon and title. A spacer and a text at the end. This declarative syntax applies to other containers such as scrollable lists.\n\nThis list is given a collection of pets and creates a horizontal stack for each one.\n\nNow, every pet isn't called Whiskers, so I'll update the views in the stack to use the properties of each pet instead.\n\nAt no point did I need to describe the actions necessary to produce this UI, such as adding and removing rows to the list.\n\nThis is the difference between declarative and imperative programming. Those of you who have taught a pet how to do tricks are familiar with imperative commands.\n\nLike with imperative programming, I can instruct Rufus here on each step of hitting a home run: Rufus, Come Rufus, Take Bat Rufus, Home Plate And so on, describing each step of the process.\n\nIn comparison, a declarative pet trick would be describing what you want to happen and letting a pre-prepared pup perform it for you. All you have to do is say what you want: seeing Rufus score a home run. And you can customize certain aspects of the trick, like bringing a custom made shirt for Rufus to wear.\n\nDeclarative and Imperative programming are not mutually exclusive. Declarative code enables you to focus on the expected result, instead of the steps to get there. And imperative code is great when making a change to state, or when there might not be an existing declarative component. And SwiftUI embraces both. A great example of this is Button. Buttons are added to the user interface declaratively, and part of its declaration is the action to perform when tapped. This action uses imperative code to make a change: in this case, adding a new pet to the list.\n\nSwiftUI views are descriptions of what the current state of the UI should be they are not long lived object instances that receive imperative commands over time. This is why SwiftUI views are value types, defined using structs instead of classes.\n\nSwiftUI takes these descriptions and creates an efficient data structure to represent them. It maintains this data structure behind the scenes. And it's used to produce different outputs, for example: what is shown on screen, the gestures and interactive aspects of the view And its accessibility representation. Because views are just declarative descriptions, breaking up one view into multiple doesn't hurt the performance of your app. You don't need to compromise organizing code the way you want, in order to get the best performance.\n\nComposition is used throughout SwiftUI, and is an essential part of every user interface. The HStack I built earlier is a container view for the purposes of layout, and it places its children in a horizontal stack. Rearranging and experimenting with container views is really easy in SwiftUI. The code itself resembles the hierarchy of views that it creates.\n\nA horizontal stack contains three views: an Image, Vertical Stack, and Spacer. The Vertical Stack itself contains two views of its own: the Label and Text This syntax uses a view builder closure, to declare the children of a container. In this example, I'm using HStack's initializer that has a ViewBuilder content parameter. This is a pattern used by all container views in SwiftUI.\n\nComposition plays an important role in another SwiftUI pattern called View modifiers.\n\nView modifiers apply modifications onto a base view and can change any aspect of that view. I'll start with Whisker's cute photo. First, clip it to a circle, add a shadow, and overlay a green border on top, that's her favorite color.\n\nSyntactically, this looks very different than container views, but it results in a similar hierarchical structure. The hierarchy and order of effect is defined based on the exact order of the modifiers. Chaining modifiers together makes it clear how a result is produced and how to customize that result; all in an easy to read syntax.\n\nView hierarchies can be encapsulated into custom views and view modifiers. A custom view conforms to the View protocol and has a body property to return the view it represents. The view returned from body, uses the same view building syntax I've shown so far enabling the same compositional features and quick iteration. You can create additional view properties to help keep your code organized as you'd like. I've refactored out the profile image construction into a private view property.\n\nThrough these kinds of incremental steps, I can continue to iterate and build a row view to be just how I want it.\n\nCustom views can have inputs that change how their body is created. I've added a property for the pet that this row will represent, and I've used that property in the views returned from body.\n\nWith this change, I can reuse the same view to display information about Whiskers, as well as Roofus and Bubbles.\n\nCustom views can be used like any other view. Here, I've used it in a List as the view to create for each pet.\n\nList is a great illustration, of the power of view composition. This List initializer has a collection parameter. It's a convenience for creating a ForEach view. ForEach generates views for each element in a collection and provides those to its container. This view-based List initializer enables creating more advanced constructions such as multiple collections of data organized into sections. One for my pets, and one for everyone else's.\n\nLists can also be customized through the use of view modifiers. For example, adding swipe actions to each row.\n\nThrough composition of additional containers and modifiers I can incrementally build up an entire app.\n\nThe third characteristic of views in SwiftUI is that they are state-driven. When your views' state changes over time SwiftUI automatically keeps your UI up to date eliminating both boilerplate and update bugs. SwiftUI is maintaining a representation of the user interface behind the scenes. As data changes, new view values are created and given to SwiftUI. SwiftUI uses those values to determine how to update its outputs. My app now has the list of pets and their tricks. But the most important part of a pet competition is rewarding the ones that I think have the best tricks. This is Sheldon, they love getting strawberries for their award. I'm well prepared after having added swipe actions on each row.\n\nWhen I tap on the Award button, its action is called. This modifies the associated pet object, and changes hasAward to now be true.\n\nSwiftUI keeps track of any views that depend on this pet, such as the row view.\n\nIt has a reference to the pet and in its body reads whether the pet has an award or not establishing a dependency.\n\nSwiftUI will call this view's body again with the updated pet.\n\nIt now returns a result that includes an Image to reflect Sheldon's award.\n\nSwiftUI updates the outputs based on this result to display the new image on screen.\n\nAny piece of data that a view uses in its body is a dependency of that view. In my app, I created an Observable pet class. SwiftUI creates dependencies to the specific properties used in view bodies. SwiftUI has several tools for state management. Two other important ones are State and Binding State creates a new internal source of data for a view. When you mark a view property as @State, SwiftUI manages its storage and provides it back for the view to read and write.\n\nA Binding creates a two-way reference to the state of some other view.\n\nI've written another view that makes use of these. This view allows me to rate my pet's tricks. It's using State to keep track of the current rating and change it over time. The value is displayed prominently in the middle, and it has two buttons to increment and decrement the value.\n\nSwiftUI maintains the value of this state behind the scenes.\n\nSimilar to the earlier example, the button's action is called when tapped. This time, it increments the internal State of the view.\n\nSwiftUI notices this change, and calls body on RatingView, which returns a new text value. The result is then updated on screen.\n\nI'm going to focus in on views in the body, where the state changes are being made.\n\nSo far the changes are being made immediately, without an animation. Animations in SwiftUI build on top of the same data-driven updates that I've discussed so far.\n\nWhen I wrap withAnimation around this state change, the resulting view updates are applied with a default animation.\n\nSwiftUI applied a default cross-fade transition to the text. But I can also customize the transition.\n\nIn this case, using a numeric text content transition fits this perfectly.\n\nWith state and animation, I've built an encapsulated view component that has the interaction I want. Ultimately, I'm going to compose this view in the rest of my app.\n\nHere I have another view, RatingContainerView, that combines a Gauge and a RatingView in its body.\n\nCurrently, these views each have their own state, which act as their own separate sources of truth for what the rating is. However, this means that when the rating view increments its own state, the container view's state and the Gauge do not change.\n\nI've updated RatingView to take a Binding as an input, so that a two-way reference can be provided by its container view.\n\nNow, the container view's state becomes the only source of truth, and it provides the value to the Gauge, and a Binding to the RatingView. Now they update in sync, and the animated state change applies to the Gauge as well.\n\nSwiftUI provides many levels of built-in capability, giving you an even higher starting point for building your app.\n\nI've just begun on the app for tracking pets and their tricks, I'm happy with where I've gotten. SwiftUI automatically provides adaptivity along several dimensions.\n\nMy app already looks good in dark mode. It supports several accessibility features, such as dynamic type. And it's ready to be localized. For example, I'm previewing it with a right to left pseudo-language to get a feel for how it might look in Hebrew or Arabic.\n\nThis is one of the things that are great about using Xcode Previews. It quickly shows you how your views look, including in different contexts. And it does this as you write the code, without needing to run the app over and over.\n\nPreviews are interactive even directly on device. You can understand exactly how a feature you're working on is going to feel, as you're building it.\n\nOne benefit to SwiftUI's declarative views is adaptivity. Views provided by SwiftUI often describe the purpose of their functionality as opposed to their exact visual construction.\n\nEarlier, I showed how swipe actions are composed of views like Button. Buttons are a great example of an adaptive view. They have two fundamental properties: an action and the label that describes the action.\n\nThey can be used in many different contexts but still always carry that purpose of a labeled action.\n\nThey adapt across different styles, such as Borderless, Bordered or Prominent. And automatically adapt to different contexts, such as Swipe actions, Menus, and Forms. This pattern applies to all controls in SwiftUI, including Toggles.\n\nToggles have their own styles, such as switches, checkboxes, and toggle buttons. And in different contexts, appear as the idiomatic style to represent something that turns on and off.\n\nMany views across SwiftUI have this same adaptive quality, taking advantage of composition to affect behavior and enable customization. This applies to some view modifiers as well. One of my favorite examples is searchable, which I'll apply to my list of pets.\n\nWhen I add the searchable modifier, I'm describing that the view it's applied to is capable of being searched. SwiftUI takes care of all of the details, to make that happen in an idiomatic way. And through incremental adoption of other modifiers, you can customize the experience: such as adding suggestions, scopes, and tokens.\n\nSwiftUI's declarative and adaptive views pack in a lot of functionality in just a few lines of code.\n\nThere are controls, like Button, Toggle, and Picker.\n\nContainer views like NavigationSplitView, or customizable multi-column tables.\n\nPresentations, such as sheets and inspectors, and many more examples that you can explore in the documentation.\n\nAnd when you're ready to create unique, custom experiences, SwiftUI also has another layer of API, that provides low level control.\n\nYou can build your own control styles; use Canvas for high performance, imperative drawing; create completely custom layouts; and even apply custom Metal shaders directly to SwiftUI views.\n\nIn my app, the scoreboard was a perfect place to create a unique experience using these low level tools, evoking a classic flip-board.\n\nI used animations, graphics tricks, and a dash of Metal shaders.\n\nSheldon, missed the landing on this last trick, so I'm going to have to give him a 7. Better luck next time, buddy.\n\nSwiftUI's capabilities go beyond Views as well. The entire app definition is built on the same principles that Views follow. An App is a declarative structure defined by scenes. WindowGroup is one kind of scene. It's created with a content view to show on screen.\n\nScenes can also be composed together.\n\nOn multi-windowed platforms, such as macOS, additional scenes provide different ways to interact with your app's capabilities.\n\nThis pattern also extends to building custom widgets. Widgets are shown on your home screen and desktop, and are composed out of views. I've reused some of the scoreboard views to display Sheldon's latest rating. SwiftUI's capabilities extend to any platform it's used on and enable you to take your investments in one platform and build native apps on others. SwiftUI is available when building an app, for any Apple platform.\n\nIt's also a multiplier on your efforts: once you have a user interface built using SwiftUI for one platform, you have an excellent start to bringing that UI to any platform.\n\nThe app I've build for iOS is a great example of that.\n\nAdaptive views and scenes provide idiomatic look and feel on any Apple platform. On macOS, automatically supporting things like keyboard navigation or creating multiple windows.\n\nThe same use of search suggestions results in a standard drop down menu on macOS, and an overlay list on iOS.\n\nCustom crafted views from low level APIs will produce the same result across platforms and are another great place to reuse the same views when needed.\n\nMy efforts to perfect the scoreboard animation look great on all platforms.\n\nWhile SwiftUI enables code sharing in these ways, it is not Write Once and Run Everywhere. It's a set of tools you can learn once and use in any context or on any Apple platform.\n\nSwiftUI has a common set of these high and low level components across platforms, but it also has specialized APIs for each platform.\n\nEvery platform is unique in how it is used and therefore in how it is designed.\n\nThe Human Interface Guidelines describes components, patterns, and their platform considerations.\n\nNavigationSplitView automatically adapts to watchOS's design, of a source list that pushes a detail.\n\nAnd I reused custom views, such as the scoreboard. But there is one change I want to make, specific to watchOS.\n\nInstead of using touch or the keyboard, I'd expect to be able to use the digital crown to quickly select a rating.\n\nBuilding on the same scoreboard view, I've added an additional modifier for watchOS: digitalCrownRotation Now, as I turn the digital crown, it flips through to the score I want.\n\nWhen I review pets and their tricks on my Mac, I want to dig into past data and compare it across pets. I can take advantage of macOS's flexible windowing model in different scene types. Or use views that make the most of macOS's familiar control library, information density, and precise input.\n\nAnd I can bring my app to visionOS, taking advantage of views from other platforms and adding in additional volumetric content.\n\nSwiftUI helps you make your app great wherever it takes you. This too is incremental in nature. SwiftUI doesn't require you to support multiple platforms. But it offers you a head start for when you're ready. The last area is not a built-in capability of SwiftUI itself, but in SwiftUI's ability to interoperate with the features and capabilities of other frameworks. SwiftUI is a framework that comes with each platform's SDK.\n\nThere are many other frameworks also part of the SDK, and each bring their own exciting capabilities. Any app won't use all of these frameworks, but can pick and choose from the ones that provide the technology they need.\n\nSwiftUI provides interoperability to all of this functionality, and in many cases is as easy as dropping in another view or property into your app.\n\nUIKit and AppKit are imperative, object oriented user interface frameworks. They provide similar building blocks as SwiftUI, but use different patterns for creating and updating views. And they feature long-standing, rich capabilities that SwiftUI builds on.\n\nA cornerstone feature of SwiftUI is seamless interoperability with them.\n\nIf there's a view or view controller from UIKit or AppKit, that you want to use in SwiftUI, you can create a view representable.\n\nThis is a special SwiftUI view protocol for creating and updating an associated UIKit or AppKit view, using imperative code.\n\nThe result is a View that can be used within SwiftUI's declarative view builders and can be used like any other view, such as using it in an HStack. The inverse is true as well. If you want to embed a SwiftUI view into a UIKit or AppKit view hierarchy, you can use classes such as Hosting View Controller. This is created with a root SwiftUI view, and can be added to your UIKit or AppKit view controller hierarchy.\n\nApple's own apps use these tools to adopt SwiftUI incrementally, whether it's to bring SwiftUI into an existing app, or when building a brand new SwiftUI app and incorporating Kit views. All of these are tools in your toolbox, to build great apps. There is no expectation that an app needs to be entirely SwiftUI in order to take advantage of it.\n\nEvery framework in the SDK brings its own unique capabilities. SwiftData enables you to add persistent models to your app quickly, and comes with APIs to connect and query those models from your SwiftUI views.\n\nSwift Charts is a highly customizable charting framework, built on top of SwiftUI, that makes it easy to create gorgeous information visualizations.\n\nAll of these frameworks are available to use to help you build great apps.\n\nSwiftUI is built with a foundation of declarative, compositional, and state-driven views. On top of that, it provides platform-idiomatic capabilities and integration with a wide SDK. All of these things help you focus on what makes your app unique, with less code Provide a wide range of components that results in idiomatic and engaging applications. And enable incremental adoption along every step of the way.\n\nAnd now it's time for you to get started with SwiftUI. Launch Xcode and begin creating your first app, or begin incorporating SwiftUI into an existing app. Check out other excellent videos on SwiftUI. A great one to watch next is an Introduction to SwiftUI.\n\nFollow along with the SwiftUI tutorials, which guide you through building different apps. And there are many more treats in the documentation.\n\nAs for the pet competition, it's going to take more than an app to answer which pet is best. For now, my conclusion is that they are all... good pets.",
    "segments": []
  },
  "codeExamples": [
    {
      "timestamp": "2:30",
      "title": "Declarative views",
      "language": "swift",
      "code": "Text(\"Whiskers\")\n\nImage(systemName: \"cat.fill\")\n\nButton(\"Give Treat\") {\n   // Give Whiskers a treat\n}"
    },
    {
      "timestamp": "2:43",
      "title": "Declarative views: layout",
      "language": "swift",
      "code": "HStack {\n   Label(\"Whiskers\", systemImage: \"cat.fill\")\n\n   Spacer()\n\n   Text(\"Tightrope walking\")\n}"
    },
    {
      "timestamp": "2:56",
      "title": "Declarative views: list",
      "language": "swift",
      "code": "struct ContentView: View {\n    @State private var pets = Pet.samplePets\n\n    var body: some View {\n        List(pets) { pet in\n            HStack {\n                Label(\"Whiskers\", systemImage: \"cat.fill\")\n\n                Spacer()\n\n                Text(\"Tightrope walking\")\n            }\n        }\n    }\n}\n\nstruct Pet: Identifiable {\n    enum Kind {\n        case cat\n        case dog\n        case fish\n        case bird\n        case lizard\n        case turtle\n        case rabbit\n        case bug\n\n        var systemImage: String {\n            switch self {\n            case .cat: return \"cat.fill\"\n            case .dog: return \"dog.fill\"\n            case .fish: return \"fish.fill\"\n            case .bird: return \"bird.fill\"\n            case .lizard: return \"lizard.fill\"\n            case .turtle: return \"tortoise.fill\"\n            case .rabbit: return \"rabbit.fill\"\n            case .bug: return \"ant.fill\"\n            }\n        }\n    }\n\n    let id = UUID()\n    var name: String\n    var kind: Kind\n    var trick: String\n\n    init(_ name: String, kind: Kind, trick: String) {\n        self.name = name\n        self.kind = kind\n        self.trick = trick\n    }\n\n    static let samplePets = [\n        Pet(\"Whiskers\", kind: .cat, trick: \"Tightrope walking\"),\n        Pet(\"Roofus\", kind: .dog, trick: \"Home runs\"),\n        Pet(\"Bubbles\", kind: .fish, trick: \"100m freestyle\"),\n        Pet(\"Mango\", kind: .bird, trick: \"Basketball dunk\"),\n        Pet(\"Ziggy\", kind: .lizard, trick: \"Parkour\"),\n        Pet(\"Sheldon\", kind: .turtle, trick: \"Kickflip\"),\n        Pet(\"Chirpy\", kind: .bug, trick: \"Canon in D\")\n    ]\n}"
    },
    {
      "timestamp": "3:07",
      "title": "Declarative views: list",
      "language": "swift",
      "code": "struct ContentView: View {\n    @State private var pets = Pet.samplePets\n\n    var body: some View {\n        List(pets) { pet in\n            HStack {\n                Label(pet.name, systemImage: pet.kind.systemImage)\n\n                Spacer()\n\n                Text(pet.trick)\n            }\n        }\n    }\n}\n\nstruct Pet: Identifiable {\n    enum Kind {\n        case cat\n        case dog\n        case fish\n        case bird\n        case lizard\n        case turtle\n        case rabbit\n        case bug\n\n        var systemImage: String {\n            switch self {\n            case .cat: return \"cat.fill\"\n            case .dog: return \"dog.fill\"\n            case .fish: return \"fish.fill\"\n            case .bird: return \"bird.fill\"\n            case .lizard: return \"lizard.fill\"\n            case .turtle: return \"tortoise.fill\"\n            case .rabbit: return \"rabbit.fill\"\n            case .bug: return \"ant.fill\"\n            }\n        }\n    }\n\n    let id = UUID()\n    var name: String\n    var kind: Kind\n    var trick: String\n\n    init(_ name: String, kind: Kind, trick: String) {\n        self.name = name\n        self.kind = kind\n        self.trick = trick\n    }\n\n    static let samplePets = [\n        Pet(\"Whiskers\", kind: .cat, trick: \"Tightrope walking\"),\n        Pet(\"Roofus\", kind: .dog, trick: \"Home runs\"),\n        Pet(\"Bubbles\", kind: .fish, trick: \"100m freestyle\"),\n        Pet(\"Mango\", kind: .bird, trick: \"Basketball dunk\"),\n        Pet(\"Ziggy\", kind: .lizard, trick: \"Parkour\"),\n        Pet(\"Sheldon\", kind: .turtle, trick: \"Kickflip\"),\n        Pet(\"Chirpy\", kind: .bug, trick: \"Canon in D\")\n    ]\n}"
    },
    {
      "timestamp": "4:24",
      "title": "Declarative and imperative programming",
      "language": "swift",
      "code": "struct ContentView: View {\n    @State private var pets = Pet.samplePets\n\n    var body: some View {\n        Button(\"Add Pet\") {\n            pets.append(Pet(\"Toby\", kind: .dog, trick: \"WWDC Presenter\"))\n        }\n\n        List(pets) { pet in\n            HStack {\n                Label(pet.name, systemImage: pet.kind.systemImage)\n\n                Spacer()\n\n                Text(pet.trick)\n            }\n        }\n    }\n}\n\nstruct Pet: Identifiable {\n    enum Kind {\n        case cat\n        case dog\n        case fish\n        case bird\n        case lizard\n        case turtle\n        case rabbit\n        case bug\n\n        var systemImage: String {\n            switch self {\n            case .cat: return \"cat.fill\"\n            case .dog: return \"dog.fill\"\n            case .fish: return \"fish.fill\"\n            case .bird: return \"bird.fill\"\n            case .lizard: return \"lizard.fill\"\n            case .turtle: return \"tortoise.fill\"\n            case .rabbit: return \"rabbit.fill\"\n            case .bug: return \"ant.fill\"\n            }\n        }\n    }\n\n    let id = UUID()\n    var name: String\n    var kind: Kind\n    var trick: String\n\n    init(_ name: String, kind: Kind, trick: String) {\n        self.name = name\n        self.kind = kind\n        self.trick = trick\n    }\n\n    static let samplePets = [\n        Pet(\"Whiskers\", kind: .cat, trick: \"Tightrope walking\"),\n        Pet(\"Roofus\", kind: .dog, trick: \"Home runs\"),\n        Pet(\"Bubbles\", kind: .fish, trick: \"100m freestyle\"),\n        Pet(\"Mango\", kind: .bird, trick: \"Basketball dunk\"),\n        Pet(\"Ziggy\", kind: .lizard, trick: \"Parkour\"),\n        Pet(\"Sheldon\", kind: .turtle, trick: \"Kickflip\"),\n        Pet(\"Chirpy\", kind: .bug, trick: \"Canon in D\")\n    ]\n}"
    },
    {
      "timestamp": "5:41",
      "title": "Container views",
      "language": "swift",
      "code": "struct ContentView: View {\n    var body: some View {\n        HStack {\n            Image(whiskers.profileImage)\n\n            VStack(alignment: .leading) {\n                Label(\"Whiskers\", systemImage: \"cat.fill\")\n                Text(\"Tightrope walking\")\n            }\n\n            Spacer()\n        }\n    }\n}\n\nlet whiskers = Pet(\"Whiskers\", kind: .cat, trick: \"Tightrope walking\", profileImage: \"Whiskers\")\n\nstruct Pet: Identifiable {\n    enum Kind {\n        case cat\n        case dog\n        case fish\n        case bird\n        case lizard\n        case turtle\n        case rabbit\n        case bug\n\n        var systemImage: String {\n            switch self {\n            case .cat: return \"cat.fill\"\n            case .dog: return \"dog.fill\"\n            case .fish: return \"fish.fill\"\n            case .bird: return \"bird.fill\"\n            case .lizard: return \"lizard.fill\"\n            case .turtle: return \"tortoise.fill\"\n            case .rabbit: return \"rabbit.fill\"\n            case .bug: return \"ant.fill\"\n            }\n        }\n    }\n\n    let id = UUID()\n    var name: String\n    var kind: Kind\n    var trick: String\n    var profileImage: String\n\n    init(_ name: String, kind: Kind, trick: String, profileImage: String) {\n        self.name = name\n        self.kind = kind\n        self.trick = trick\n        self.profileImage = profileImage\n    }\n}"
    },
    {
      "timestamp": "6:23",
      "title": "View modifiers",
      "language": "swift",
      "code": "struct ContentView: View {\n    var body: some View {\n        Image(whiskers.profileImage)\n            .clipShape(.circle)\n            .shadow(radius: 3)\n            .overlay {\n                Circle().stroke(.green, lineWidth: 2)\n            }\n    }\n}\n\nlet whiskers = Pet(\"Whiskers\", kind: .cat, trick: \"Tightrope walking\", profileImage: \"Whiskers\")\n\nstruct Pet: Identifiable {\n    enum Kind {\n        case cat\n        case dog\n        case fish\n        case bird\n        case lizard\n        case turtle\n        case rabbit\n        case bug\n\n        var systemImage: String {\n            switch self {\n            case .cat: return \"cat.fill\"\n            case .dog: return \"dog.fill\"\n            case .fish: return \"fish.fill\"\n            case .bird: return \"bird.fill\"\n            case .lizard: return \"lizard.fill\"\n            case .turtle: return \"tortoise.fill\"\n            case .rabbit: return \"rabbit.fill\"\n            case .bug: return \"ant.fill\"\n            }\n        }\n    }\n\n    let id = UUID()\n    var name: String\n    var kind: Kind\n    var trick: String\n    var profileImage: String\n\n    init(_ name: String, kind: Kind, trick: String, profileImage: String) {\n        self.name = name\n        self.kind = kind\n        self.trick = trick\n        self.profileImage = profileImage\n    }\n}"
    },
    {
      "timestamp": "7:05",
      "title": "Custom views: Intro",
      "language": "swift",
      "code": "struct PetRowView: View {\n    var body: some View {\n       // ...\n    }\n}"
    },
    {
      "timestamp": "7:14",
      "title": "Custom views",
      "language": "swift",
      "code": "struct PetRowView: View {\n    var body: some View {\n        Image(whiskers.profileImage)\n            .clipShape(.circle)\n            .shadow(radius: 3)\n            .overlay {\n                Circle().stroke(.green, lineWidth: 2)\n            }\n    }\n}\n\nlet whiskers = Pet(\"Whiskers\", kind: .cat, trick: \"Tightrope walking\", profileImage: \"Whiskers\")\n\nstruct Pet: Identifiable {\n    enum Kind {\n        case cat\n        case dog\n        case fish\n        case bird\n        case lizard\n        case turtle\n        case rabbit\n        case bug\n\n        var systemImage: String {\n            switch self {\n            case .cat: return \"cat.fill\"\n            case .dog: return \"dog.fill\"\n            case .fish: return \"fish.fill\"\n            case .bird: return \"bird.fill\"\n            case .lizard: return \"lizard.fill\"\n            case .turtle: return \"tortoise.fill\"\n            case .rabbit: return \"rabbit.fill\"\n            case .bug: return \"ant.fill\"\n            }\n        }\n    }\n\n    let id = UUID()\n    var name: String\n    var kind: Kind\n    var trick: String\n    var profileImage: String\n\n    init(_ name: String, kind: Kind, trick: String, profileImage: String) {\n        self.name = name\n        self.kind = kind\n        self.trick = trick\n        self.profileImage = profileImage\n    }\n}"
    },
    {
      "timestamp": "7:20",
      "title": "Custom views: iteration",
      "language": "swift",
      "code": "struct PetRowView: View {\n    var body: some View {\n        HStack {\n            Image(whiskers.profileImage)\n                .clipShape(.circle)\n                .shadow(radius: 3)\n                .overlay {\n                    Circle()\n                        .stroke(.green, lineWidth: 2)\n                }\n\n            Text(\"Whiskers\")\n\n            Spacer()\n        }\n    }\n}\n\nlet whiskers = Pet(\"Whiskers\", kind: .cat, trick: \"Tightrope walking\", profileImage: \"Whiskers\")\n\nstruct Pet: Identifiable {\n    enum Kind {\n        case cat\n        case dog\n        case fish\n        case bird\n        case lizard\n        case turtle\n        case rabbit\n        case bug\n\n        var systemImage: String {\n            switch self {\n            case .cat: return \"cat.fill\"\n            case .dog: return \"dog.fill\"\n            case .fish: return \"fish.fill\"\n            case .bird: return \"bird.fill\"\n            case .lizard: return \"lizard.fill\"\n            case .turtle: return \"tortoise.fill\"\n            case .rabbit: return \"rabbit.fill\"\n            case .bug: return \"ant.fill\"\n            }\n        }\n    }\n\n    let id = UUID()\n    var name: String\n    var kind: Kind\n    var trick: String\n    var profileImage: String\n\n    init(_ name: String, kind: Kind, trick: String, profileImage: String) {\n        self.name = name\n        self.kind = kind\n        self.trick = trick\n        self.profileImage = profileImage\n    }\n}"
    },
    {
      "timestamp": "7:24",
      "title": "Custom views: view properties",
      "language": "swift",
      "code": "struct PetRowView: View {\n    var body: some View {\n        HStack {\n            profileImage\n\n            Text(\"Whiskers\")\n\n            Spacer()\n        }\n    }\n\n    private var profileImage: some View {\n        Image(whiskers.profileImage)\n            .clipShape(.circle)\n            .shadow(radius: 3)\n            .overlay {\n                Circle().stroke(.green, lineWidth: 2)\n            }\n    }\n}\n\nlet whiskers = Pet(\"Whiskers\", kind: .cat, trick: \"Tightrope walking\", profileImage: \"Whiskers\")\n\nstruct Pet: Identifiable {\n    enum Kind {\n        case cat\n        case dog\n        case fish\n        case bird\n        case lizard\n        case turtle\n        case rabbit\n        case bug\n\n        var systemImage: String {\n            switch self {\n            case .cat: return \"cat.fill\"\n            case .dog: return \"dog.fill\"\n            case .fish: return \"fish.fill\"\n            case .bird: return \"bird.fill\"\n            case .lizard: return \"lizard.fill\"\n            case .turtle: return \"tortoise.fill\"\n            case .rabbit: return \"rabbit.fill\"\n            case .bug: return \"ant.fill\"\n            }\n        }\n    }\n\n    let id = UUID()\n    var name: String\n    var kind: Kind\n    var trick: String\n    var profileImage: String\n\n    init(_ name: String, kind: Kind, trick: String, profileImage: String) {\n        self.name = name\n        self.kind = kind\n        self.trick = trick\n        self.profileImage = profileImage\n    }\n}"
    },
    {
      "timestamp": "7:34",
      "title": "Custom views: complete row view",
      "language": "swift",
      "code": "struct PetRowView: View {\n    var body: some View {\n        HStack {\n            profileImage\n\n            VStack(alignment: .leading) {\n                Text(\"Whiskers\")\n                Text(\"Tightrope walking\")\n                    .font(.subheadline)\n                    .foregroundStyle(.secondary)\n            }\n\n            Spacer()\n        }\n    }\n\n    private var profileImage: some View {\n        Image(whiskers.profileImage)\n            .clipShape(.circle)\n            .shadow(radius: 3)\n            .overlay {\n                Circle().stroke(.green, lineWidth: 2)\n            }\n    }\n}\n\nlet whiskers = Pet(\"Whiskers\", kind: .cat, trick: \"Tightrope walking\", profileImage: \"Whiskers\")\n\nstruct Pet: Identifiable {\n    enum Kind {\n        case cat\n        case dog\n        case fish\n        case bird\n        case lizard\n        case turtle\n        case rabbit\n        case bug\n\n        var systemImage: String {\n            switch self {\n            case .cat: return \"cat.fill\"\n            case .dog: return \"dog.fill\"\n            case .fish: return \"fish.fill\"\n            case .bird: return \"bird.fill\"\n            case .lizard: return \"lizard.fill\"\n            case .turtle: return \"tortoise.fill\"\n            case .rabbit: return \"rabbit.fill\"\n            case .bug: return \"ant.fill\"\n            }\n        }\n    }\n\n    let id = UUID()\n    var name: String\n    var kind: Kind\n    var trick: String\n    var profileImage: String\n\n    init(_ name: String, kind: Kind, trick: String, profileImage: String) {\n        self.name = name\n        self.kind = kind\n        self.trick = trick\n        self.profileImage = profileImage\n    }\n}"
    },
    {
      "timestamp": "7:41",
      "title": "Custom views: input properties",
      "language": "swift",
      "code": "struct PetRowView: View {\n    var pet: Pet\n    var body: some View {\n        HStack {\n            profileImage\n\n            VStack(alignment: .leading) {\n                Text(pet.name)\n                Text(pet.trick)\n                    .font(.subheadline)\n                    .foregroundStyle(.secondary)\n            }\n\n            Spacer()\n        }\n    }\n\n    private var profileImage: some View {\n        Image(pet.profileImage)\n            .clipShape(.circle)\n            .shadow(radius: 3)\n            .overlay {\n                Circle().stroke(pet.favoriteColor, lineWidth: 2)\n            }\n    }\n}\n\nstruct Pet: Identifiable {\n    enum Kind {\n        case cat\n        case dog\n        case fish\n        case bird\n        case lizard\n        case turtle\n        case rabbit\n        case bug\n\n        var systemImage: String {\n            switch self {\n            case .cat: return \"cat.fill\"\n            case .dog: return \"dog.fill\"\n            case .fish: return \"fish.fill\"\n            case .bird: return \"bird.fill\"\n            case .lizard: return \"lizard.fill\"\n            case .turtle: return \"tortoise.fill\"\n            case .rabbit: return \"rabbit.fill\"\n            case .bug: return \"ant.fill\"\n            }\n        }\n    }\n\n    let id = UUID()\n    var name: String\n    var kind: Kind\n    var trick: String\n    var profileImage: String\n    var favoriteColor: Color\n\n    init(_ name: String, kind: Kind, trick: String, profileImage: String, favoriteColor: Color) {\n        self.name = name\n        self.kind = kind\n        self.trick = trick\n        self.profileImage = profileImage\n        self.favoriteColor = favoriteColor\n    }\n}"
    },
    {
      "timestamp": "7:53",
      "title": "Custom views: reuse",
      "language": "swift",
      "code": "PetRowView(pet: model.pet(named: \"Whiskers\"))\n\nPetRowView(pet: model.pet(named: \"Roofus\"))\n\nPetRowView(pet: model.pet(named: \"Bubbles\"))"
    },
    {
      "timestamp": "7:59",
      "title": "List composition",
      "language": "swift",
      "code": "struct ContentView: View {\n    var model: PetStore\n    var body: some View {\n        List(model.allPets) { pet in\n            PetRowView(pet: pet)\n        }\n    }\n}\n\n@Observable\nclass PetStore {\n    var allPets: [Pet] = [\n        Pet(\"Whiskers\", kind: .cat, trick: \"Tightrope walking\", profileImage: \"Whiskers\", favoriteColor: .green),\n        Pet(\"Roofus\", kind: .dog, trick: \"Home runs\", profileImage: \"Roofus\", favoriteColor: .blue),\n        Pet(\"Bubbles\", kind: .fish, trick: \"100m freestyle\", profileImage: \"Bubbles\", favoriteColor: .orange),\n        Pet(\"Mango\", kind: .bird,  trick: \"Basketball dunk\", profileImage: \"Mango\", favoriteColor: .green),\n        Pet(\"Ziggy\", kind: .lizard, trick: \"Parkour\", profileImage: \"Ziggy\", favoriteColor: .purple),\n        Pet(\"Sheldon\", kind: .turtle, trick: \"Kickflip\", profileImage: \"Sheldon\", favoriteColor: .brown),\n        Pet(\"Chirpy\", kind: .bug, trick: \"Canon in D\", profileImage: \"Chirpy\", favoriteColor: .orange)\n    ]\n}"
    },
    {
      "timestamp": "8:14",
      "title": "List composition: ForEach",
      "language": "swift",
      "code": "struct ContentView: View {\n    var model: PetStore\n    var body: some View {\n        List {\n            ForEach(model.allPets) { pet in\n                PetRowView(pet: pet)\n            }\n        }\n    }\n}\n\n@Observable\nclass PetStore {\n    var allPets: [Pet] = [\n        Pet(\"Whiskers\", kind: .cat, trick: \"Tightrope walking\", profileImage: \"Whiskers\", favoriteColor: .green),\n        Pet(\"Roofus\", kind: .dog, trick: \"Home runs\", profileImage: \"Roofus\", favoriteColor: .blue),\n        Pet(\"Bubbles\", kind: .fish, trick: \"100m freestyle\", profileImage: \"Bubbles\", favoriteColor: .orange),\n        Pet(\"Mango\", kind: .bird,  trick: \"Basketball dunk\", profileImage: \"Mango\", favoriteColor: .green),\n        Pet(\"Ziggy\", kind: .lizard, trick: \"Parkour\", profileImage: \"Ziggy\", favoriteColor: .purple),\n        Pet(\"Sheldon\", kind: .turtle, trick: \"Kickflip\", profileImage: \"Sheldon\", favoriteColor: .brown),\n        Pet(\"Chirpy\", kind: .bug, trick: \"Canon in D\", profileImage: \"Chirpy\", favoriteColor: .orange)\n    ]\n}"
    },
    {
      "timestamp": "8:27",
      "title": "List composition: sections",
      "language": "swift",
      "code": "struct ContentView: View {\n    var model: PetStore\n    var body: some View {\n        List {\n            Section(\"My Pets\") {\n                ForEach(model.myPets) { pet in\n                    PetRowView(pet: pet)\n                }\n            }\n            Section(\"Other Pets\") {\n                ForEach(model.otherPets) { pet in\n                    PetRowView(pet: pet)\n                }\n            }\n        }\n    }\n}\n\n@Observable\nclass PetStore {\n    var myPets: [Pet] = [\n        Pet(\"Roofus\", kind: .dog, trick: \"Home runs\", profileImage: \"Roofus\", favoriteColor: .blue),\n        Pet(\"Sheldon\", kind: .turtle, trick: \"Kickflip\", profileImage: \"Sheldon\", favoriteColor: .brown),\n    ]\n\n    var otherPets: [Pet] = [\n        Pet(\"Whiskers\", kind: .cat, trick: \"Tightrope walking\", profileImage: \"Whiskers\", favoriteColor: .green),\n        Pet(\"Bubbles\", kind: .fish, trick: \"100m freestyle\", profileImage: \"Bubbles\", favoriteColor: .orange),\n        Pet(\"Mango\", kind: .bird,  trick: \"Basketball dunk\", profileImage: \"Mango\", favoriteColor: .green),\n        Pet(\"Ziggy\", kind: .lizard, trick: \"Parkour\", profileImage: \"Ziggy\", favoriteColor: .purple),\n        Pet(\"Chirpy\", kind: .bug, trick: \"Canon in D\", profileImage: \"Chirpy\", favoriteColor: .orange)\n    ]\n}"
    },
    {
      "timestamp": "8:36",
      "title": "List composition: section actions",
      "language": "swift",
      "code": "PetRowView(pet: pet)\n    .swipeActions(edge: .leading) {\n        Button(\"Award\", systemImage: \"trophy\") {\n            // Give pet award\n        }\n        .tint(.orange)\n\n        ShareLink(item: pet, preview: SharePreview(\"Pet\", image: Image(pet.name)))\n    }"
    },
    {
      "timestamp": "9:31",
      "title": "View updates",
      "language": "swift",
      "code": "struct ContentView: View {\n    var model: PetStore\n    var body: some View {\n        List {\n            Section(\"My Pets\") {\n                ForEach(model.myPets) { pet in\n                    row(pet: pet)\n                }\n            }\n            Section(\"Other Pets\") {\n                ForEach(model.otherPets) { pet in\n                    row(pet: pet)\n                }\n            }\n        }\n    }\n\n    private func row(pet: Pet) -> some View {\n        PetRowView(pet: pet)\n            .swipeActions(edge: .leading) {\n                Button(\"Award\", systemImage: \"trophy\") {\n                    pet.giveAward()\n                }\n                .tint(.orange)\n\n                ShareLink(item: pet, preview: SharePreview(\"Pet\", image: Image(pet.name)))\n            }\n    }\n}\n\nstruct PetRowView: View {\n    var pet: Pet\n    var body: some View {\n        HStack {\n            profileImage\n\n            VStack(alignment: .leading) {\n                HStack(alignment: .firstTextBaseline) {\n                    Text(pet.name)\n\n                    if pet.hasAward {\n                        Image(systemName: \"trophy.fill\")\n                            .foregroundStyle(.orange)\n                    }\n                }\n                Text(pet.trick)\n                    .font(.subheadline)\n                    .foregroundStyle(.secondary)\n            }\n\n            Spacer()\n        }\n    }\n\n    private var profileImage: some View {\n        Image(pet.profileImage)\n            .clipShape(.circle)\n            .shadow(radius: 3)\n            .overlay {\n                Circle().stroke(pet.favoriteColor, lineWidth: 2)\n            }\n    }\n}\n\n@Observable\nclass PetStore {\n    var myPets: [Pet] = [\n        Pet(\"Roofus\", kind: .dog, trick: \"Home runs\", profileImage: \"Roofus\", favoriteColor: .blue),\n        Pet(\"Sheldon\", kind: .turtle, trick: \"Kickflip\", profileImage: \"Sheldon\", favoriteColor: .brown),\n    ]\n\n    var otherPets: [Pet] = [\n        Pet(\"Whiskers\", kind: .cat, trick: \"Tightrope walking\", profileImage: \"Whiskers\", favoriteColor: .green),\n        Pet(\"Bubbles\", kind: .fish, trick: \"100m freestyle\", profileImage: \"Bubbles\", favoriteColor: .orange),\n        Pet(\"Mango\", kind: .bird,  trick: \"Basketball dunk\", profileImage: \"Mango\", favoriteColor: .green),\n        Pet(\"Ziggy\", kind: .lizard, trick: \"Parkour\", profileImage: \"Ziggy\", favoriteColor: .purple),\n        Pet(\"Chirpy\", kind: .bug, trick: \"Canon in D\", profileImage: \"Chirpy\", favoriteColor: .orange)\n    ]\n}\n\n@Observable\nclass Pet: Identifiable {\n    enum Kind {\n        case cat\n        case dog\n        case fish\n        case bird\n        case lizard\n        case turtle\n        case rabbit\n        case bug\n\n        var systemImage: String {\n            switch self {\n            case .cat: return \"cat.fill\"\n            case .dog: return \"dog.fill\"\n            case .fish: return \"fish.fill\"\n            case .bird: return \"bird.fill\"\n            case .lizard: return \"lizard.fill\"\n            case .turtle: return \"tortoise.fill\"\n            case .rabbit: return \"rabbit.fill\"\n            case .bug: return \"ant.fill\"\n            }\n        }\n    }\n\n    var name: String\n    var kind: Kind\n    var trick: String\n    var profileImage: String\n    var favoriteColor: Color\n    var hasAward: Bool = false\n\n    init(_ name: String, kind: Kind, trick: String, profileImage: String, favoriteColor: Color) {\n        self.name = name\n        self.kind = kind\n        self.trick = trick\n        self.profileImage = profileImage\n        self.favoriteColor = favoriteColor\n    }\n\n    func giveAward() {\n        hasAward = true\n    }\n}\n\nextension Pet: Transferable {\n    static var transferRepresentation: some TransferRepresentation {\n        ProxyRepresentation { $0.name }\n    }\n}"
    },
    {
      "timestamp": "10:57",
      "title": "State changes",
      "language": "swift",
      "code": "struct RatingView: View {\n    @State var rating: Int = 5\n\n    var body: some View {\n        HStack {\n            Button(\"Decrease\", systemImage: \"minus.circle\") {\n                rating -= 1\n            }\n            .disabled(rating == 0)\n            .labelStyle(.iconOnly)\n\n            Text(rating, format: .number.precision(.integerLength(2)))\n                .font(.title.bold())\n\n            Button(\"Increase\", systemImage: \"plus.circle\") {\n                rating += 1\n            }\n            .disabled(rating == 10)\n            .labelStyle(.iconOnly)\n        }\n    }\n}"
    },
    {
      "timestamp": "11:51",
      "title": "State changes: animation",
      "language": "swift",
      "code": "struct RatingView: View {\n    @State var rating: Int = 5\n\n    var body: some View {\n        HStack {\n            Button(\"Decrease\", systemImage: \"minus.circle\") {\n                withAnimation {\n                    rating -= 1\n                }\n            }\n            .disabled(rating == 0)\n            .labelStyle(.iconOnly)\n\n            Text(rating, format: .number.precision(.integerLength(2)))\n                .font(.title.bold())\n\n            Button(\"Increase\", systemImage: \"plus.circle\") {\n                withAnimation {\n                    rating += 1\n                }\n            }\n            .disabled(rating == 10)\n            .labelStyle(.iconOnly)\n        }\n    }\n}"
    },
    {
      "timestamp": "12:05",
      "title": "State changes: text content transition",
      "language": "swift",
      "code": "struct RatingView: View {\n    @State var rating: Int = 5\n\n    var body: some View {\n        HStack {\n            Button(\"Decrease\", systemImage: \"minus.circle\") {\n                withAnimation {\n                    rating -= 1\n                }\n            }\n            .disabled(rating == 0)\n            .labelStyle(.iconOnly)\n\n            Text(rating, format: .number.precision(.integerLength(2)))\n                .contentTransition(.numericText(value: Double(rating)))\n                .font(.title.bold())\n\n            Button(\"Increase\", systemImage: \"plus.circle\") {\n                withAnimation {\n                    rating += 1\n                }\n            }\n            .disabled(rating == 10)\n            .labelStyle(.iconOnly)\n        }\n    }\n}"
    },
    {
      "timestamp": "12:22",
      "title": "State changes: multiple state",
      "language": "swift",
      "code": "struct RatingContainerView: View {\n    @State private var rating: Int = 5\n\n    var body: some View {\n        Gauge(value: Double(rating), in: 0...10) {\n            Text(\"Rating\")\n        }\n        RatingView()\n    }\n}\n\nstruct RatingView: View {\n    @State var rating: Int = 5\n\n    var body: some View {\n        HStack {\n            Button(\"Decrease\", systemImage: \"minus.circle\") {\n                withAnimation {\n                    rating -= 1\n                }\n            }\n            .disabled(rating == 0)\n            .labelStyle(.iconOnly)\n\n            Text(rating, format: .number.precision(.integerLength(2)))\n                .contentTransition(.numericText(value: Double(rating)))\n                .font(.title.bold())\n\n            Button(\"Increase\", systemImage: \"plus.circle\") {\n                withAnimation {\n                    rating += 1\n                }\n            }\n            .disabled(rating == 10)\n            .labelStyle(.iconOnly)\n        }\n    }\n}"
    },
    {
      "timestamp": "12:45",
      "title": "State changes: state and binding",
      "language": "swift",
      "code": "struct RatingContainerView: View {\n    @State private var rating: Int = 5\n\n    var body: some View {\n        Gauge(value: Double(rating), in: 0...10) {\n            Text(\"Rating\")\n        }\n        RatingView(rating: $rating)\n    }\n}\n\nstruct RatingView: View {\n    @Binding var rating: Int\n\n    var body: some View {\n        HStack {\n            Button(\"Decrease\", systemImage: \"minus.circle\") {\n                withAnimation {\n                    rating -= 1\n                }\n            }\n            .disabled(rating == 0)\n            .labelStyle(.iconOnly)\n\n            Text(rating, format: .number.precision(.integerLength(2)))\n                .contentTransition(.numericText(value: Double(rating)))\n                .font(.title.bold())\n\n            Button(\"Increase\", systemImage: \"plus.circle\") {\n                withAnimation {\n                    rating += 1\n                }\n            }\n            .disabled(rating == 10)\n            .labelStyle(.iconOnly)\n        }\n    }\n}"
    },
    {
      "timestamp": "14:16",
      "title": "Adaptive buttons",
      "language": "swift",
      "code": "Button(\"Reward\", systemImage: \"trophy\") {\n    // Give pet award\n}\n// .buttonStyle(.borderless)\n// .buttonStyle(.bordered)\n// .buttonStyle(.borderedProminent)"
    },
    {
      "timestamp": "14:53",
      "title": "Adaptive toggles",
      "language": "swift",
      "code": "Toggle(\"Nocturnal Mode\", systemImage: \"moon\", isOn: $pet.isNocturnal)\n// .toggleStyle(.switch)\n// .toggleStyle(.checkbox)\n// .toggleStyle(.button)"
    },
    {
      "timestamp": "15:19",
      "title": "Searchable",
      "language": "swift",
      "code": "struct PetListView: View {\n    @Bindable var viewModel: PetStoreViewModel\n\n    var body: some View {\n        List {\n            Section(\"My Pets\") {\n                ForEach(viewModel.myPets) { pet in\n                    row(pet: pet)\n                }\n            }\n            Section(\"Other Pets\") {\n                ForEach(viewModel.otherPets) { pet in\n                    row(pet: pet)\n                }\n            }\n        }\n        .searchable(text: $viewModel.searchText)\n    }\n\n    private func row(pet: Pet) -> some View {\n        PetRowView(pet: pet)\n            .swipeActions(edge: .leading) {\n                Button(\"Reward\", systemImage: \"trophy\") {\n                    pet.giveAward()\n                }\n                .tint(.orange)\n\n                ShareLink(item: pet, preview: SharePreview(\"Pet\", image: Image(pet.name)))\n            }\n    }\n}\n\n@Observable\nclass PetStoreViewModel {\n    var petStore: PetStore\n    var searchText: String = \"\"\n\n    init(petStore: PetStore) {\n        self.petStore = petStore\n    }\n\n    var myPets: [Pet] {\n        // For illustration purposes only. The filtered pets should be cached.\n        petStore.myPets.filter { searchText.isEmpty || $0.name.contains(searchText) }\n    }\n    var otherPets: [Pet] {\n        // For illustration purposes only. The filtered pets should be cached.\n        petStore.otherPets.filter { searchText.isEmpty || $0.name.contains(searchText) }\n    }\n}"
    },
    {
      "timestamp": "15:20",
      "title": "Searchable: customization",
      "language": "swift",
      "code": "struct PetListView: View {\n    @Bindable var viewModel: PetStoreViewModel\n\n    var body: some View {\n        List {\n            Section(\"My Pets\") {\n                ForEach(viewModel.myPets) { pet in\n                    row(pet: pet)\n                }\n            }\n            Section(\"Other Pets\") {\n                ForEach(viewModel.otherPets) { pet in\n                    row(pet: pet)\n                }\n            }\n        }\n        .searchable(text: $viewModel.searchText, editableTokens: $viewModel.searchTokens) { $token in\n            Label(token.kind.name, systemImage: token.kind.systemImage)\n        }\n        .searchScopes($viewModel.searchScope) {\n            Text(\"All Pets\").tag(PetStoreViewModel.SearchScope.allPets)\n            Text(\"My Pets\").tag(PetStoreViewModel.SearchScope.myPets)\n            Text(\"Other Pets\").tag(PetStoreViewModel.SearchScope.otherPets)\n        }\n        .searchSuggestions {\n            PetSearchSuggestions(viewModel: viewModel)\n        }\n    }\n\n    private func row(pet: Pet) -> some View {\n        PetRowView(pet: pet)\n            .swipeActions(edge: .leading) {\n                Button(\"Reward\", systemImage: \"trophy\") {\n                    pet.giveAward()\n                }\n                .tint(.orange)\n\n                ShareLink(item: pet, preview: SharePreview(\"Pet\", image: Image(pet.name)))\n            }\n    }\n}"
    },
    {
      "timestamp": "16:58",
      "title": "App definition",
      "language": "swift",
      "code": "@main\nstruct SwiftUIEssentialsApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n        }\n    }\n}"
    },
    {
      "timestamp": "17:15",
      "title": "App definition: multiple scenes",
      "language": "swift",
      "code": "@main\nstruct SwiftUIEssentialsApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n        }\n\n        WindowGroup(\"Training History\", id: \"history\", for: TrainingHistory.ID.self) { $id in\n            TrainingHistoryView(historyID: id)\n        }\n\n        WindowGroup(\"Pet Detail\", id: \"detail\", for: Pet.ID.self) { $id in\n            PetDetailView(petID: id)\n        }\n   }\n}"
    },
    {
      "timestamp": "17:23",
      "title": "Widgets",
      "language": "swift",
      "code": "struct ScoreboardWidget: Widget {\n    var body: some WidgetConfiguration {\n        // ...\n    }\n}\n\nstruct ScoreboardWidgetView: View {\n    var petTrick: PetTrick\n    \n    var body: some View {\n        ScoreCard(rating: petTrick.rating)\n            .overlay(alignment: .bottom) {\n                Text(petTrick.pet.name)\n                    .padding()\n            }\n            .widgetURL(petTrick.pet.url)\n    }\n}"
    },
    {
      "timestamp": "19:37",
      "title": "Digital Crown rotation",
      "language": "swift",
      "code": "ScoreCardStack(rating: $rating)\n   .focusable()\n   #if os(watchOS)\n   .digitalCrownRotation($rating, from: 0, through: 10)\n   #endif"
    }
  ],
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "Forum: UI Frameworks",
        "url": "https://developer.apple.com/forums/topics/ui-frameworks?cid=vf-a-0010"
      },
      {
        "title": "SwiftUI",
        "url": "https://developer.apple.com/documentation/SwiftUI"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2024/10150/4/43B9EF68-FA39-44B2-9CCD-82D0EB4CA44D/downloads/wwdc2024-10150_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2024/10150/4/43B9EF68-FA39-44B2-9CCD-82D0EB4CA44D/downloads/wwdc2024-10150_sd.mp4?dl=1"
  },
  "relatedVideos": [
    {
      "id": "10181",
      "year": "2024",
      "title": "Xcode essentials",
      "url": "https://developer.apple.com/videos/play/wwdc2024/10181"
    },
    {
      "id": "10119",
      "year": "2020",
      "title": "Introduction to SwiftUI",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10119"
    }
  ],
  "extractedAt": "2025-07-18T10:20:52.887Z"
}