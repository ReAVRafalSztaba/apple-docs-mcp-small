{
  "id": "10007",
  "year": "2022",
  "url": "https://developer.apple.com/videos/play/wwdc2022/10007/",
  "title": "What's new with in-app purchase",
  "speakers": [],
  "duration": "",
  "topics": [
    "App Store, Distribution & Marketing"
  ],
  "hasTranscript": true,
  "hasCode": false,
  "transcript": {
    "fullText": "♪ Mellow instrumental hip-hop music ♪ ♪ Dani Chootong: Hello, and welcome to \"What's new with in-app purchase.\" I'm Dani, and I'm an engineer on the StoreKit team.\n\nToday I'll be presenting with my colleague Ian, and we'll be going over the new improvements we're bringing to in-app purchase this year.\n\nLast year, we introduced StoreKit 2, a set of new APIs designed from the ground up to make it simple to integrate in-app purchases.\n\nStoreKit 2 uses modern language features, including Swift concurrency using the async/await pattern.\n\nOn the server side, we complemented these new StoreKit features with an entirely new set of App Store Server endpoints.\n\nThese server endpoints make it easy to retrieve transaction information and check subscription status on your server.\n\nWe also released Version 2 of App Store Server Notifications, to make tracking the subscription lifecycle on your server easier than ever.\n\nToday I'll be going over these new APIs, as well as enhancements we're bringing to the new StoreKit models.\n\nThen, Ian will walk you through some exciting new server updates, including App Store Server API enhancements and brand-new APIs for App Store Server Notifications.\n\nFirst, I'll go over the new App Transaction API for verifying the purchase of your app.\n\nNext, I'll dig into some new properties we've added to our StoreKit models.\n\nI'll introduce you to the new SwiftUI friendly APIs for redeeming subscription offer codes and asking a customer to review your app.\n\nThen, I'll introduce you to StoreKit Messages, an API used to display App Store messages to your customers.\n\nAnd finally, I'll go over an enhancement we're adding to preserve Application Username when you're migrating from the original to the modern StoreKit APIs.\n\nThroughout this presentation, I'll be using my favorite app, Food Truck.\n\nIn the Food Truck app, I manage a pop-up donut food truck that visits various cities to make donut deliveries.\n\nSo, let's get started! Meet App Transaction.\n\nThe App Transaction is our new API for verifying the purchase of your app.\n\nThe App Transaction represents the signed information for the purchase of your app for the device it's running on.\n\nIt's signed using JWS, and it replaces the app detail portion of the app receipt from the original StoreKit API.\n\nJust like transaction verification, StoreKit performs automatic verification of the app transaction for you.\n\nHowever, if you wish, you can also perform your own validation.\n\nValidating a JWS signature is a well-documented standard.\n\nYou can refer to the public documentation to implement your own validation.\n\nStoreKit takes care of automatically updating the App Transaction when necessary.\n\nHowever, in the rare case that the user thinks there's something wrong, it can be refreshed.\n\nYou should provide UI in your app to allow your customers to refresh the app transaction.\n\nThis should only be used in response to user action, as refreshing the App Transaction prompts the user to authenticate.\n\nPreventing fraud isn't the only reason to love App Transaction.\n\nIf you're looking to switch business models from a paid app to a free app that offers in-app purchases, if you're curious about which of your customers preordered your app, or even if you just want to know when your app was purchased, these are all situations you can handle with App Transaction.\n\nIn the app receipt, the receipt payload combine the purchase data about your application along with all the in-app purchases that have occurred.\n\nThese are now broken up into two separate components in StoreKit.\n\nThe first of these is the Transaction History.\n\nStoreKit's transaction APIs give you insight into the user's entire in-app purchase history, right on the device.\n\nThese APIs allow you to find the exact information you need, including the user's latest transactions, unfinished transactions, and current entitlements.\n\nIf you prefer to perform these calculations on your server, you can also get the user's purchase history from the App Store Server API.\n\nIan will have some exciting updates on this later this session.\n\nAnd the second component is the App Transaction, which contains the data you need to make sure that your app is valid for the device it's running on.\n\nIt's easy to verify the purchase of your app using App Transaction, and in just a moment, I'll be going over an example of how you can use it.\n\nBut first, let me give you some background about my favorite app.\n\nWith Food Truck, I'm able to make donut deliveries, check in on a basic social feed, and visualize my sales history.\n\nKeeping all this information in a database is an ongoing cost for my app, so to help me cover the costs, I'm going to turn the yearly sales history chart into a onetime purchase.\n\nAdditionally, I want to enhance the social feed.\n\nSo instead of just seeing what others are saying about my food truck, I want to provide the tools so I can engage with my customers as well.\n\nThis will be a subscription service, and I'll have a monthly and a yearly plan.\n\nFood Truck began as a paid app, but I'm going to make the switch to a free app that offers in-app purchases.\n\nBut I don't want my existing customers who already purchased Food Truck to feel left out.\n\nSo, I'll be using the App Transaction to make sure that the customers who purchased Food Truck continue to have access to the premium content they paid for.\n\nHere's the timeline for Food Truck.\n\nAt the initial release, Food Truck started out as a paid app that cost $4.99.\n\nVersion 1.0 offered donut deliveries, a basic social feed, and sales history charts.\n\nLater, at the release of version 8.0, my business model changed.\n\nFood Truck is now free, but includes a variety of in-app purchases which unlock premium features.\n\nThe yearly sales history chart is now a nonconsumable onetime purchase, and now there's a new subscription service for a premium social feed that gives you advanced engagement tools.\n\nNow let's take a look at two different types of customers who might be affected by this.\n\nAlice found out about my Food Truck app in version 2.5, and she decided she wants to share her passion for donuts in the digital world.\n\nSo, she purchased my app for $4.99 and began her donut delivery journey.\n\nA second customer, Bob, finds out about my Food Truck app though a friend and downloads it for free in the App Store in version 8.2.\n\nIn this scenario, Alice, who purchased my app before it became free, should still have access to all the premium content she already paid for.\n\nShe still has the option to purchase the premium social feed subscription, but I don't want to deny her the yearly sales history chart that was initially included.\n\nBob, however, got my app for free.\n\nI know then not to unlock features and content until they complete the in-app purchase.\n\nSo, let's see how we can achieve this with App Transaction in code.\n\nI'll start off by fetching the app transaction by calling AppTransaction.shared.\n\nThis call gets me a VerificationResult containing my app transaction.\n\nWithin the result, the AppTransaction type contains the JWS payload.\n\nNext, I'll switch on the result.\n\nIf the result is unverified, this would be a good time to alert the user that their app purchase could not be verified by the App Store, and then, I can prompt them to refresh the app transaction.\n\nAt this time, I'll offer a minimal experience for my app.\n\nIf the result is verified, I'm going to use this as an opportunity to check whether the user has purchased my app.\n\nCustomers that purchased my app should be granted the services they paid for.\n\nFor this, I'll use the original app version property.\n\nThis property lets me know the app version in which the customer had downloaded my app for the very first time.\n\nVersion 8.0 is the version in which my app became free with in-app purchases.\n\nI'm going to pass the customer's original app version to my function which checks if the user purchased my app before version 8.0.\n\nAnd with that, I can make an informed decision about how I should go about providing premium content to my users.\n\nFor customers like Alice, who purchased my app, I'm going to provide the content the user is entitled to that they had at the time of purchase.\n\nIn my case, I'm going to unlock the yearly sales history chart for her deliveries.\n\nAlso, I want to check any additional in-app purchases they may have made so I can provide that as well.\n\nOtherwise, I can be confident that the user downloaded my app after I switched my business model, like Bob.\n\nThis can be a good time to check the user's current entitlements so I can unlock the features and content they paid for.\n\nAnd with just a few lines of code, I was able to verify the purchase of my app, check whether the user downloaded the paid version of my app, and I can immediately start providing my premium content, whether the customer purchased my app or not.\n\nWith App Transaction, you can easily support your customers whether they're early supporters or if they've just recently downloaded your app.\n\nNow I'd like to move on to the new properties we're adding to our StoreKit models.\n\nThe first of these properties is the price locale.\n\nThe price locale is now included in StoreKit products.\n\nYou may already be familiar with price locale from interfacing with our original purchase APIs.\n\nNext, I'll dig into the server environment property.\n\nNow, you can tell the server environment a transaction or renewal info occurred in.\n\nThen, I'll move onto the recent subscription start date property.\n\nYou can use this as a tool to make informed decisions for your customers based on their subscription patterns.\n\nAnd lastly, I'll go over some special considerations for these properties when you're using them with StoreKit Testing in Xcode.\n\nThese properties return sentinel values in older operating systems, and I'll explain what this means in just a bit.\n\nThe StoreKit APIs were designed with flexibility in mind, so I'm proud to announce that you can take advantage of these new properties on devices as far back as last year's operating systems, even though they did not originally ship with them.\n\nAll you'll need to make this happen is to use Xcode 14 to build your app, and you'll have access to these properties in the previous operating systems.\n\nThis is possible because the implementation for these properties are compiled into your app, so when your customers update to the new version, they'll be able to get the benefits of these enhancements without needing to update their operating system.\n\nThere is one thing to keep in mind when using these properties, though.\n\nThese properties will return sentinel values when you're using StoreKit testing in Xcode in these older operating systems.\n\nWhen I say sentinel values, I'm referring to placeholder values that signal that these are not real values you should work with, and I'll explain why this occurs.\n\nThe sandbox and production environments make use of these properties by extracting the values from the App Store server response.\n\nStoreKit testing in Xcode, however, is a local testing environment that operates independently from the App Store server.\n\nThis means we're not able to backport the value of these properties to the previous operating systems there.\n\nYou can easily get around this limitation by updating your test device to a new operating system, and you'll be all set to test these values in the local environment.\n\nLet's discuss some situations that demonstrate how you can start using these new properties, the first of which is price locale.\n\nStoreKit products already have a display price property to label the purchase price, but with price locale, you can format numbers deriving from the product's decimal price.\n\nIf you have a yearly subscription, you might use this as an opportunity to show your customers how much it would cost them per month.\n\nIn this example, you can see that the yearly subscription amounts to $4.17 per month.\n\nOr perhaps you'd want to show them how much they would save if they purchased your yearly service over your monthly service.\n\nWith this information, your customers can make informed decisions when they're considering your purchase options.\n\nNow, let's move on to the environment property.\n\nThe environment property is available in the Transaction and renewal Info.\n\nThis property tells you the server environment in which the transaction or renewal info originated in, which could be Xcode, sandbox, or production.\n\nYour app may communicate transaction information to your server after a customer makes a purchase for bookkeeping and analytics.\n\nWhen your app generates these transactions, it could be from any one of these server environments.\n\nLike most of you, I don't want to add noise to my analytics with irrelevant test data.\n\nSo, knowing the environment can help you filter out unnecessary information from being sent up to your server.\n\nFinally, let's take a look at the recent subscription start date.\n\nThe recent subscription start date is available within a product's subscription information, and it represents the most recent period of continuous subscription.\n\nA subscription is considered continuous if there is no more than a 60-day gap between any two subscribed periods.\n\nKeep in mind that this period can contain gaps where the customer was not subscribed to your product, so don't use this as an indicator for the number of days a customer has been subscribed.\n\nThe recent subscription start date can help you determine a pattern of loyalty between you and your customers.\n\nFor your loyal customers, you might offer them a reward as a way to keep them engaged with your product.\n\nOr if you notice that a customer has unsubscribed from your service, you can use it as a chance to win back a lapsed customer by offering them an incentive to start using your product again.\n\nI mentioned earlier that we'd take a closer look at the sentinel values for these properties.\n\nAs a reminder, when I say sentinel values, I'm referring to placeholder values that serve as an indicator of the absence of a real value.\n\nThe sentinel values for these properties are easy to identify.\n\nWhen you're dealing with price locale, the sentinel value is a locale with the identifier xx_XX.\n\nFor the environment property, it'll be an empty string.\n\nAnd finally, for the recent subscription start date, this value is Date.distantPast.\n\nLuckily, the occurrence of these sentinel values are predictable -- you'll only encounter them if you're using StoreKit testing in Xcode in older operating systems, and you can get around this by updating your test device.\n\nSo now you've seen the enhancements we've made to our StoreKit models.\n\nAnd my favorite part is, they're backward compatible all the way back to the operating system in which the models were introduced, so your customers can see the benefits right away just by updating your app.\n\nWhen you perform arithmetic with price values, the price locale helps you correctly format it so that it matches the App Store's locale.\n\nFor transactions and subscription information, the environment tells you exactly where they originated from, so if you store this data on your server, you can act on it accordingly depending on the environment.\n\nThe recent subscription start date helps you understand customer loyalty, so you can tailor specific offers to long-time customers, or maybe you can provide an incentive for customers who have unsubscribed.\n\nAnd in case you were wondering, yes, the environment and recent subscription start date are also available via App Store Server API and App Store Server Notifications, which Ian will discuss.\n\nNow I'd like talk about the new SwiftUI APIs we're providing for redeeming offer codes and requesting a review.\n\nOffer codes can help you acquire, retain, and win back subscribers by providing subscriptions at a discount or free for a limited time.\n\nNow in App Store Connect, you can create uniquely named custom codes.\n\nThere, you can set a maximum redemption limit and you can choose whether or not to set an expiration.\n\nLet's look at the SwiftUI implementation to present an offer code redemption sheet straight from your app.\n\nHere, I've got a SwiftUI view with a button to trigger the offer code redeem sheet.\n\nThe offer code redemption sheet now has its own view modifier in SwiftUI.\n\nThe view modifier is easy to use, it just needs a binding Boolean to start the process.\n\nAnd once the offer code sheet is dismissed, you'll get a result representing whether or not the sheet presented successfully.\n\nWhen a customer redeems an offer code for your app, the resulting transaction is sent to the transaction listener.\n\nSo, be sure to set up a transaction listener as soon as your app launches to receive new and updated transactions while your app is running.\n\nThe offer code view modifier is available starting on iOS 16.\n\nNext, I'd like to talk about updates to request review.\n\nGetting customer feedback is important.\n\nPotential new customers might use reviews as a deciding factor in their decision to download your app.\n\nOthers might want to leave a review as a way to provide feedback or suggestions.\n\nEither way, we want to give you the tools to make it easy for you to request a rating from your customers, so you can let them know you're listening and you can continue engaging with them.\n\nLet's review the code.\n\nHere I have a very simple view to demonstrate the Request Review APIs.\n\nIn SwiftUI, there's now an environment value called requestReview.\n\nYou can use this value to get an instance of the RequestReviewAction, and when you're ready to request a rating, simply call the instance as a function to request to display the review prompt.\n\nYou can decide the right time to request a review for your app.\n\nHowever, you should be aware that the prompt will only be displayed to customers a maximum of three times within a 365-day period.\n\nAnd you shouldn't ask customers to review the same version of your app multiple times.\n\nAvoid interrupting customers with a review prompt.\n\nA good time to ask for a review could be after they've had a positive interaction, such as completing a purchase on an e-commerce app, or completing a level in a game.\n\nFinally, customers can disable requests from ever appearing on their device, so you shouldn't request a review as a result of a user action.\n\nThese APIs are really going to come in handy for your SwiftUI apps.\n\nNext, I'd like to introduce you to our new API for StoreKit messages.\n\nA StoreKit message represents a sheet that appears over your app to display important information to the user.\n\nMessages are vended by the App Store.\n\nEach message has a reason, which is included in the message metadata.\n\nStoreKit messages are retrieved when your app comes to the foreground.\n\nAs an example, let's take a look at one of the message reasons -- price increase consent.\n\nWhen you increase the price of a subscription and it requires user consent, the App Store will inform affected subscribers through email, push notification, and an in-app price consent sheet.\n\nIn this case, the App Store requires that the user agrees to the new price of your subscription before it renews at the higher price.\n\nSo, if you decide to charge more for your subscription, a price increase consent sheet may appear when a user opens your app if they haven't already responded to your price increase.\n\nBy default, StoreKit messages appear over your app when the user brings your app to the foreground, and it may ask the user to take some action relating to your app.\n\nLet's review this.\n\nThe entire process starts with your app.\n\nWhen your app enters the foreground, StoreKit knows to check if there's pending messages to display.\n\nAnd if there are, StoreKit checks in with the App Store.\n\nThe App Store returns information about the message to StoreKit.\n\nAt this time, StoreKit checks whether your app is set up to receive messages.\n\nYou can do this by setting up a message listener in your app, which I'll get into shortly.\n\nIf your app has set up a message listener, StoreKit sends information about the message to your app.\n\nNow's your chance to decide whether or not it's a good time for your app to display the message, or if you want to defer the presentation for later.\n\nIf you don't set up a message listener, StoreKit displays the message right away by presenting the message sheet over your app.\n\nI'll go over how to do this in code.\n\nBut before I do that, I'll explain a situation in which it would be useful to control the presentation of an App Store message.\n\nIn the Food Truck app, I'm able to customize the donuts I'm delivering to different cities.\n\nIf a message gets delivered to my app during this time, it would be confusing to the user if they're suddenly interrupted by a message sheet, so I'm going to be implementing the messages API to make sure this doesn't happen by controlling when incoming messages are presented.\n\nNow let's get into the code.\n\nHere, I have a simple view for the donut editor.\n\nAs I mentioned earlier, pending messages are sent each time your app comes to the foreground.\n\nSo, I want to set up a message listener in each view in which I want to defer the presentation of a message.\n\nI'll add a binding array to collect all the messages that are delivered to my app while I'm in the editing view.\n\nThis is important, because if I don't set up a message listener, StoreKit is going to display the message sheet right away when my app comes to the foreground.\n\nAs soon as the view appears, I set up my message listener.\n\nI'll do this by setting up a task that iterates over a static property on the message type.\n\nThis property is an async sequence, and I'm able to receive messages as they come in.\n\nFor my use case, I'm going to save the message in the pendingMessages array.\n\nSince pending messages get delivered each time your app enters the foreground, your app could receive the same message more than once, so I have this condition to avoid adding duplicate messages to my array.\n\nThen, once the view dismisses, I'll display the messages in the parent view.\n\nThis is the parent view which holds a navigation link to the donut editor.\n\nHere, I've collected all the pending messages I need to display in this pendingMessages array.\n\nSo how do I display these pending messages? Well, now there's an environment value displayStoreKitMessage.\n\nThis gets you an instance of a DisplayMessageAction, which you can then use to display a given message.\n\nWhen the view appears, I'll iterate through the pending messages and call displayStoreKitMessage passing in the message I want to display.\n\nStoreKit takes care of presenting the message sheet.\n\nEarlier, I mentioned that the same message may get delivered to your app more than once.\n\nThat's because a message doesn't get marked as read until it's presented to the user.\n\nSo, StoreKit makes sure that each unique message is only presented once.\n\nAnd that was a quick implementation of the Messages API.\n\nRemember, StoreKit messages are sent to your app each time it comes to the foreground, so you'll want to set up a message listener in each view in which you want to control the timing of when the messages are presented.\n\nYou can ensure customers have a great experience by making sure message sheets don't appear at unexpected moments.\n\nOr perhaps you want to tailor your logic for certain messages types.\n\nWith a price increase consent message, you may want to educate your customer about the additional value you're providing before the price increase consent sheet appears.\n\nFinally, let's review how StoreKit preserves the applicationUsername as an appAccountToken after a user makes a purchase.\n\nIf you have a user account system on your server, chances are you're already making use of the applicationUsername property.\n\nThe applicationUsername is a string that you create to associate a transaction with a user account on your service.\n\nIn the original API for in-app purchase, you set the applicationUsername value when you add a payment to the payment queue.\n\nAlthough the applicationUsername accepts any string, we recommend that you provide the string representation of a UUID.\n\nWhen you provide it a UUID string, StoreKit persists the value and you'll see it in the transaction that the queue updates.\n\nIf you don't provide a UUID string for the applicationUsername, StoreKit may not persist it.\n\nThere's no guarantee the value will persist between the time you add the payment transaction to the queue and when the queue updates the transaction.\n\nWhen you provide the string representation of a UUID, you can identify which of your app's user accounts began and completed a transaction.\n\nIn the modern StoreKit APIs, we implement this concept as a purchase option called appAccountToken and it requires a UUID format.\n\nNow, when you set the applicationUsername to a UUID string during payment, the App Store server stores it as an appAccountToken.\n\nSo you'll see its UUID appear in the signed transaction info returned by the App Store Server API and in V2 App Store Server Notifications.\n\nAnd as a UUID, it's compatible with the appAccountToken in the modern StoreKit transaction APIs.\n\nSo, now you can be sure that when you update your codebase to the modern StoreKit APIs, the UUID you used for the applicationUsername is preserved as an appAccountToken in the StoreKit transactions.\n\nWe touched on a lot of things today.\n\nBefore moving on to the server updates, let's review this year's StoreKit updates.\n\nWe discussed validating your app's purchase with App Transaction, redeeming an offer code and requesting a review in SwiftUI, and controlling the presentation of StoreKit messages.\n\nWe talked about new price locale, environment, and recent subscription start date properties.\n\nAnd, we went over the importance of using a string representation of a UUID for the applicationUsername to persist it as an app account token.\n\nI highly recommend you check out our other session \"What's new in StoreKit testing.\" And if you need a refresher on the StoreKit 2 APIs, check out last year's session \"Meet StoreKit 2.\" Now I'd like to hand it over to Ian to walk you through the updates to the App Store server.\n\nIan Zanger: Thanks, Dani.\n\nHi, everyone. My name is Ian, and I'm an engineer on the App Store Server team.\n\nNow that you've heard the latest about in-app purchase with StoreKit, I'm going to switch gears and talk about the server.\n\nFirst, I'll review some recent developments from the past year before moving on to some exciting new updates coming to the App Store Server API and App Store Server Notifications Version 2.\n\nLet's get started.\n\nLast year was big.\n\nWe brought you an entirely new suite of endpoints with the App Store Server API and App Store Server Notifications V2, including full sandbox testing support for all these new features.\n\nWe shared how you can use the Get Transaction History endpoint to get the full history of a user's in-app purchases, or the Get All Subscription Statuses endpoint to stay up to date with the current state of a user's subscriptions.\n\nBoth of these endpoints conveniently key off of a user's originalTransactionId, so you can access this trove of data by storing just this one simple value.\n\nWe also covered how version 2 of App Store Server Notifications can simplify event processing on your server and complement the App Store Server API.\n\nWith V2 notifications, the App Store server calls your server directly, providing in-app purchase updates as they happen.\n\nThe streamlined notification type and subtype make it easy to understand what's happening.\n\nYou can use these to track changes related to in-app subscriptions and other events.\n\nWith all of these data sources, we wanted to make that data as easy as possible to parse.\n\nReceipts are now a thing of the past, as these new services provide in-app data in signed JSON format, so you can easily parse it and trust that it came from the App Store server.\n\nLast year was a big year for the App Store server.\n\nIt may have been big for you as well if you worked to update your server code to leverage all these new features.\n\nRest assured that effort will continue to pay off as we bring powerful new enhancements and features to App Store Server API and App Store Server Notifications V2.\n\nThat's our year in review, but if you'd like more of a refresher after hearing this year's updates, be sure to check out the WWDC21 sessions titled \"Manage in-app purchases on your server,\" \"Meet StoreKit 2,\" and \"Support customers and handle refunds.\" Now let's move on to brand-new updates coming to the App Store server for WWDC22.\n\nFirst I'll share some updates to transaction and renewal info fields.\n\nNext I'll tell you about new enhancements to the App Store Server API.\n\nAnd finally, I'll share exciting new features coming to App Store Server Notifications V2.\n\nNow let's dive in with the first of our new topics: new fields found in transaction and renewal info.\n\nEarlier, you heard from Dani about a couple new fields coming to the transaction and renewal info of in-app purchases.\n\nThese fields, environment and recentSubscriptionStartDate, are also coming to the transaction and renewal info payloads you receive from the App Store Server API and in V2 App Store Server Notifications.\n\nLet's take a fresh look at the data you can expect to receive from the App Store server with these new fields included.\n\nFirst is the transaction info payload, which we can see here after decoding.\n\nDown at the bottom, you can see our new field: environment.\n\nYou can use it to tell, at a glance, whether the transaction took place in the production or sandbox environment.\n\nNext is the renewal info payload, also seen here after decoding.\n\nAs you can see, the environment field is also available here for your reference.\n\nAdditionally, recentSubscriptionStartDate will now appear in every renewal info payload.\n\nThis is the start date of the user's first subscription purchase in their most recent string of renewals, ignoring any gaps of 60 days or fewer.\n\nrecentSubscriptionStartDate is an easy way to get an idea of a customer's loyalty at a glance.\n\nBut if you'd like more detail, including the timing and length of any gaps in service, you can call the Get Transaction History endpoint and examine the full history of a user's subscription renewal purchases.\n\nOr for even more detail, with App Store Server Notifications V2, the App Store server automatically sends updates about user subscriptions to your server.\n\nThese notifications give you maximum insight into the timing of events like renewal preference changes, offer redemptions, billing failures, and more.\n\nAs you can see, recentSubscriptionStartDate rounds out a suite of options for determining customer loyalty.\n\nUse these tools to target offers and reward your most loyal customers.\n\nNow let's move on to some convenient new enhancements to the Get Transaction History endpoint.\n\nWith the Get Transaction History endpoint, you can fetch the full history of a user's purchases in your app.\n\nThe endpoint response is paginated so you can process this data in reasonable chunks.\n\nEach response contains a revision token that you provide in the next request in order to get the next page.\n\nAnd the pages are sorted by modified date, meaning each subsequent page contains transactions that are more recently modified.\n\nLet's take a look at how this works.\n\nYou call the Get Transaction History endpoint, and provide an originalTransactionId.\n\nThe App Store server will return up to 20 signed transactions for that user.\n\nIt will also return an updated revision value that you will provide in your next page request for this user.\n\nYou'll know there's more data available when the hasMore field in the response is true.\n\nLet's say in this case that there's another page of data available.\n\nYou make another request to the endpoint, and you include that revision value from the first response.\n\nYou receive the next page of data, including an updated revision value.\n\nhasMore is now false, so you know you're up to date with the latest transaction data.\n\nExcept this time, you notice something about the final transaction in the response; you've seen it before! It was one of the original 20 you received in response to your first request.\n\nThis means the transaction must have been modified, so it was put back at the top of the sort order.\n\nNow, you can examine the data of that transaction and take note of what's changed.\n\nIn this instance, you notice the revocationDate and revocationReason fields are now populated, meaning the transaction was revoked.\n\nYou can take action by revoking any content associated with the purchase.\n\nIt's a good idea to store the revision value from this final response alongside the originalTransactionId you used to identify the user.\n\nThe next time you call the endpoint for this user, you can provide that revision and know that you're getting back only fresh transaction data that has been modified since your last request.\n\nAs you've seen, the Get Transaction History endpoint provides you a simple way to retrieve a comprehensive set of in-app purchase data.\n\nBut maybe sometimes it can be a bit too comprehensive.\n\nSome users have lengthy purchase histories dating back several years.\n\nFor these users, this endpoint could return hundreds of purchases of a variety of types.\n\nEven with pages, this can be a lot to handle.\n\nThat's why this year, we're enhancing this endpoint with a variety of new sort and filter options.\n\nNow, you can tell us exactly the data you want from the start, saving processing time on your server and reducing the number of network calls needed to retrieve all available pages.\n\nYou can sort by descending modified date if you're interested in seeing the most recently modified purchases on the first page of results.\n\nYou can also filter by several useful fields such as product type, product ID, Family sharing status, and more.\n\nTo apply these new sort and filter options, just append them as query parameters to your request to the Get Transaction History endpoint.\n\nLet's take a closer look at how that works.\n\nHere you can see all the new parameter options.\n\nThese may look familiar, since most are taken directly from the transaction info payload.\n\nYou can mix and match these parameters to get very specific results.\n\nFor example, maybe we want to fetch only the nonconsumable purchases a user has made since the beginning of this year.\n\nWe also want to exclude any revoked purchases.\n\nWe will build our custom request by setting the productType to NON_CONSUMABLE and specifying the startDate as the beginning of this year represented in milliseconds.\n\nFinally, we'll set excludeRevoked to true.\n\nAnd that's our request! Since we did not specify a sort order, the response will default to sorting by ascending modified date.\n\nNow even with a request as specific as this, there could be multiple pages of purchases to retrieve.\n\nFor follow-up requests, we should make sure to include the exact same query parameters, in addition to the revision from the previous response.\n\nFor even more flexibility, three of the filter fields support multiple values, so you can filter to only those purchases that match at least one of the provided values.\n\nThese fields are productType, productId, and subscriptionGroupIdentifier.\n\nTo provide multiple values for these parameters, simply define them multiple times.\n\nNext let's move on to App Store Server Notification updates.\n\nWith App Store Server Notifications V2, you can take your server to the next level.\n\nV2 notifications give detailed insights about in-app purchase events that you can't get anywhere else.\n\nThese are especially useful for tracking the lifecycle of autorenewable subscriptions offered in your app.\n\nYou can use these insights to retain customers, win back those that have churned, resolve customer support requests, and more.\n\nWith all of these benefits, you might wonder how to get started.\n\nAs with any new feature, the sandbox testing environment is the best place to start.\n\nThat's why last year, we added the ability to set a separate server URL in App Store Connect for receiving App Store Server Notifications in sandbox.\n\nAfter registering your server URL, you'll want to confirm your server is receiving notifications from the App Store server.\n\nYou might set up a sandbox account just to trigger a notification through a user action.\n\nFor example, let's say you perform a first time buy of a subscription using that sandbox account.\n\nYou should receive a V2 notification of type SUBSCRIBED and subtype INITIAL_BUY.\n\nBut what if that notification doesn't come? You might wonder if there was an issue with your server or the steps you took to trigger a notification.\n\nThis situation can generate a lot of uncertainty right as you're getting started.\n\nWe want to simplify this experience and give you a way to easily verify that App Store Server Notifications can reach your server.\n\nThat's why this year, we're introducing the new Request a Test Notification endpoint.\n\nBy calling this simple endpoint, you can ask us to send a V2 Notification of type TEST to the server URL registered for your app in App Store Connect.\n\nThe new TEST notification type is used exclusively for this endpoint.\n\nYou can call the endpoint in sandbox or production to test your saved URL for either environment.\n\nUse this new endpoint to quickly test new server URLs and configurations.\n\nLet's see how this simplifies first-time setup.\n\nNow, if you're just looking to trigger your first notification, there's no need to set up a sandbox account or perform a purchase.\n\nJust call the new endpoint in whichever environment you want to test and you'll receive an HTTP 200 response confirming your request.\n\nThe response will contain a new field, testNotificationToken, which identifies the test notification your server will receive.\n\nWe will come back to this field later.\n\nShortly afterward, your server should receive a V2 notification of type TEST at the URL saved in App Store Connect.\n\nNow let's see how to call this endpoint.\n\nJust send a simple POST request to this new path on the App Store server.\n\nYou'll receive an HTTP 200 response and know that your request has been submitted.\n\nThe response will contain that new field I mentioned, testNotificationToken.\n\nTake note of this for later.\n\nSoon you'll receive a signed TEST Notification.\n\nHere's what that notification will look like once it's decoded.\n\nYou'll notice it contains all the usual top-level fields of a V2 notification, including the new notificationType, TEST.\n\nThe contents of the data object are a bit shorter than a normal notification.\n\nSince this is just a test, there are no transaction-related data to include, so we omit transaction-specific fields, most notably the signedTransactionInfo.\n\nWhen calling the new Request a Test Notification endpoint, keep in mind that App Store Server Notifications are sent asynchronously.\n\nYour successful call to the endpoint will return an HTTP 200 but the actual test notification will arrive separately, a short while later.\n\nGiven that this endpoint is all about testing your server configuration, you might be wondering what to do when that test fails.\n\nIn other words, what if the test notification doesn't arrive? To further enhance your testing capabilities, we're releasing the Get Test Notification Status endpoint, which you will use in conjunction with the Request a Test Notification endpoint.\n\nWith this new endpoint, you can check on the status of a previously requested TEST notification.\n\nThe endpoint response will tell you if the App Store server was able to reach your server and successfully send the TEST notification.\n\nIf the send failed, it will give you an idea of why, so you can better troubleshoot your server configuration.\n\nLet's check out how you'll use this endpoint.\n\nSend a GET request to this path on the App Store server.\n\nIn the path, include the testNotificationToken you received from the Request a Test Notification endpoint.\n\nThis will tell us which test notification you want to check the status of.\n\nNow for the response.\n\nThe signedPayload field contains the TEST notification payload that the App Store server attempted to send to your server.\n\nAnd the firstSendAttemptResult field indicates the result of that send attempt.\n\nHere, SUCCESS indicates that the send was successful, meaning the App Store server received an HTTP 200 response from your server.\n\nIf the send was unsuccessful, you'll instead see one of several different error values.\n\nThese values indicate the error the App Store server experienced trying to reach your server with the test notification.\n\nWith this information, you can troubleshoot your server issue, request new test notifications as needed, and get your server running reliably.\n\nCollectively, these test notification endpoints are simple to use and can save you a lot of trouble when setting up or reconfiguring your server to receive V2 App Store Server Notifications.\n\nNow with the help of these endpoints, you can set up your server and confirm it's running smoothly.\n\nBut servers aren't perfect and outages happen.\n\nHow do you recover when your server goes down, leading you to miss App Store Server Notifications? The current solution to this is a retry system.\n\nWhen the App Store server fails to reach your server, it initiates a retry process.\n\nIt will retry sending the same notification up to five times, with a longer wait between each attempt.\n\nThese retries take place only in the production environment.\n\nRetries help you eventually recover from an outage, but they're not perfect for every situation.\n\nFor example, some outages can be extensive.\n\nIf your server is down long enough to miss the final retry attempt from the App Store server, that notification is lost.\n\nOr more commonly, your server could experience a very brief issue, during which it misses only a handful of notifications.\n\nBut missing even a single notification means some of your customer records are out of date for at least an hour.\n\nYet you don't know which ones! Clearly, server outages are stressful, and recovering from them can be a complex task.\n\nThat's why we want to make it as easy as possible to recover missed App Store Server Notifications, so you can get your server back on track as soon as possible.\n\nThat's why this year, we are introducing the new Get Notification History endpoint.\n\nWith this endpoint, you can fetch the history of V2 App Store Server Notifications generated for your app.\n\nWhether your server successfully received a notification or not, that notification will appear in the response of this endpoint.\n\nWhen calling this endpoint, you'll specify a date range of notifications to fetch.\n\nWith WWDC, we have started recording this data, and we will build up to the cap of the latest six months of rolling history being available.\n\nYou can optionally filter your request by type and subtype, or fetch just a single user's notifications by providing an originalTransactionId.\n\nAnd the existing retry system is still available, so you can use it in tandem with this new endpoint.\n\nLet's take a look at how you'll call this endpoint.\n\nYou'll send a POST request to this new path on the App Store server.\n\nIn the request body, you'll include a startDate and endDate.\n\nThe response will contain only notifications we first attempted to send in this window.\n\nKeep in mind that the earliest notifications available will be those sent six months before the date of your request.\n\nOptionally, you can specify a notificationType and notificationSubtype.\n\nIf you do, the history will be filtered to only notifications that match both of these values.\n\nKeep in mind that some notifications have no subtype.\n\nAlternatively, you can provide an originalTransactionId of a user, to fetch the notification history of only that user.\n\nFinally, you should provide a paginationToken as a query parameter for every follow-up request in order to get the next page.\n\nMake sure you use the same request body for follow-up requests, changing only this paginationToken.\n\nNow let's take a look at the response.\n\nThe notificationHistory array contains up to 20 notifications, with the oldest notifications first.\n\nEach entry in this array represents a notification and inside you'll find the signedPayload, which you can decode as usual to view the transaction data.\n\nThe data within is identical to the payload the App Store server sent in the original notification.\n\nYou'll see that we've also brought the new firstSendAttemptResult field to this endpoint response.\n\nYou can use this field to look for sequences of timeouts and other errors to better understand why your server missed notifications in the past.\n\nThe response also contains a paginationToken if there are more pages to retrieve.\n\nYou should provide this in your next request in order to get the next page of notifications.\n\nYou'll know there are more pages to retrieve as long as the hasMore field is true.\n\nAnd that's everything you need to know about this useful new endpoint.\n\nThat concludes our App Store server updates for today.\n\nEvery server feature announced today is available now in both sandbox and production.\n\nWe hope you'll take advantage of these new features to make your server the best it can be.\n\nFor more great content on using a server with in-app purchase, including how to use the latest features while supporting legacy clients, I encourage you to check out another session at WWDC22, \"Explore in-app purchase integration and migration.\" Both: Thanks for joining us at WWDC22! ♪",
    "segments": []
  },
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "environment",
        "url": "https://developer.apple.com/documentation/AppStoreServerAPI/environment"
      },
      {
        "title": "Get Notification History",
        "url": "https://developer.apple.com/documentation/AppStoreServerAPI/Get-Notification-History"
      },
      {
        "title": "Get Test Notification Status",
        "url": "https://developer.apple.com/documentation/AppStoreServerAPI/Get-Test-Notification-Status"
      },
      {
        "title": "Get Transaction History",
        "url": "https://developer.apple.com/documentation/AppStoreServerAPI/Get-Transaction-History"
      },
      {
        "title": "recentSubscriptionStartDate",
        "url": "https://developer.apple.com/documentation/AppStoreServerAPI/recentSubscriptionStartDate"
      },
      {
        "title": "Request a Test Notification",
        "url": "https://developer.apple.com/documentation/AppStoreServerAPI/Request-a-Test-Notification"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2022/10007/4/2E07F67B-3E73-4DC2-A300-93EB4AF56295/downloads/wwdc2022-10007_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2022/10007/4/2E07F67B-3E73-4DC2-A300-93EB4AF56295/downloads/wwdc2022-10007_sd.mp4?dl=1"
  },
  "relatedVideos": [
    {
      "id": "10142",
      "year": "2023",
      "title": "Explore testing in-app purchases",
      "url": "https://developer.apple.com/videos/play/wwdc2023/10142"
    },
    {
      "id": "10141",
      "year": "2023",
      "title": "What’s new in App Store server APIs",
      "url": "https://developer.apple.com/videos/play/wwdc2023/10141"
    },
    {
      "id": "10140",
      "year": "2023",
      "title": "What’s new in StoreKit 2 and StoreKit Testing in Xcode",
      "url": "https://developer.apple.com/videos/play/wwdc2023/10140"
    },
    {
      "id": "10040",
      "year": "2022",
      "title": "Explore in-app purchase integration and migration",
      "url": "https://developer.apple.com/videos/play/wwdc2022/10040"
    },
    {
      "id": "110404",
      "year": "2022",
      "title": "Implement proactive in-app purchase restore",
      "url": "https://developer.apple.com/videos/play/wwdc2022/110404"
    },
    {
      "id": "10039",
      "year": "2022",
      "title": "What's new in StoreKit testing",
      "url": "https://developer.apple.com/videos/play/wwdc2022/10039"
    },
    {
      "id": "10174",
      "year": "2021",
      "title": "Manage in-app purchases on your server",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10174"
    },
    {
      "id": "10114",
      "year": "2021",
      "title": "Meet StoreKit 2",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10114"
    },
    {
      "id": "10175",
      "year": "2021",
      "title": "Support customers and handle refunds",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10175"
    }
  ],
  "extractedAt": "2025-07-18T09:19:17.715Z"
}