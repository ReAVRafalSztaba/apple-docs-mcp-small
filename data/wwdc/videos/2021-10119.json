{
  "id": "10119",
  "year": "2021",
  "url": "https://developer.apple.com/videos/play/wwdc2021/10119/",
  "title": "SwiftUI Accessibility: Beyond the basics",
  "speakers": [],
  "duration": "",
  "topics": [
    "Accessibility & Inclusion"
  ],
  "hasTranscript": true,
  "hasCode": true,
  "transcript": {
    "fullText": "♪ Bass music playing ♪  ♪ Nathan Tannar: Hello, and welcome to WWDC! My name is Nathan, and I'm an engineer on the Accessibility team.\n\nToday we'll be going beyond the basics to learn how to deliver exceptional and accessible SwiftUI apps.\n\nThis year marks a huge leap forward for accessibility in SwiftUI.\n\nAt Apple, accessibility is one of our core values.\n\nOur assistive technologies across all our platforms make sure that anyone can use your app regardless of any physical, visual, audible, or motor impairment.\n\nMy team and I work to make sure most of your app is accessible by default, but there is always more you can do to enrich the experience.\n\nToday I'll show you the new tools and APIs for SwiftUI that make enriching this experience easy.\n\nLet's begin with the tooling improvements in Xcode.\n\nSwiftUI Previews have changed how many of us develop apps.\n\nIt dramatically improves your ability to iterate upon your views across multiple environments, all without the need of running your app.\n\nTo make the most important accessibility modifiers just a click away, we've added a curated list of accessibility editors.\n\nI hope this encourages everyone to always make their views accessible.\n\nBut there's more.\n\nSince accessibility modifiers don't have visual changes in the previews, a new tool was developed that allows you to inspect the accessibility of your view without leaving Xcode.\n\nLet's switch from the editor's panel to the new accessibility panel.\n\nShipping in Xcode 13, SwiftUI Previews will now also feature an Accessibility Preview.\n\nWith it, you can inspect the accessibility elements for a preview in real time.\n\nAnd this is a game changer.\n\nAccessibility Preview will help you make accessible apps even if you don't have a deep understanding of each assistive technology.\n\nLet's take a closer look to see how changes are reflected in the Accessibility Preview.\n\nThis is a simplified version of the view we just saw.\n\nAfter running the preview, I can select the VStack and the Accessibility Preview will update to display the elements in their sorted order.\n\nNotice that each element will always display its basic properties -- such as a label and traits.\n\nFor example, the Text view will create an accessibility element with the string as its label.\n\nIt also gains the .isStaticText trait.\n\nThe preview will update for any accessibility changes we make, such as adding the .isHeader trait.\n\nYou will also be able to see some of the automatic accessibility that takes place behind the scenes, such as automatic SF Symbol labels.\n\nFor example, the checkmark.seal.fill symbol is labeled \"Verified\" by default.\n\nIf you're relying on a symbol's default label, it's important to check that it accurately describes your interface.\n\nWe'll continue to use the Accessibility Preview as we step through five importance areas that'll help you deliver an exceptional experience to all of your app's users.\n\nWe'll start by examining the best way to make custom controls accessible.\n\nNext, we'll discuss how to make a view accessible with children.\n\nI'll highlight how to audit your app for common navigation problems and how the Accessibility Preview can assist with this.\n\nThen I'll show you how to supercharge your app's navigation with VoiceOver rotors.\n\nAnd finally, we'll look at focus and how it relates to assistive technologies.\n\nI've been working to prototype a new finance app I call Wallet Pal.\n\nIt's still in the early stages, but so far, I'm pretty happy with the initial design.\n\nI was pleased to hear that early beta testers are also loving it.\n\nNow that I've polished the UI, I should spend some time to polish the accessibility interface.\n\nThe accessibility interface compliments the visual experience to make sure that it’s usable by everyone.\n\nI've asked some VoiceOver users to help test Wallet Pal and I've heard that the app is hard to navigate and not fully accessible.\n\nIf parts are not accessible to VoiceOver, then they are also not accessible to other assistive technologies.\n\nIt's important that anyone be able to use Wallet Pal, so let's investigate to see where we can improve the experience.\n\nWe'll begin with reports of users not being able to edit their budgets, a critical feature in Wallet Pal.\n\nThis is the Budget Planner view which allows users to edit their food, entertainment, and savings budgets.\n\nTo fit the design of Wallet Pal, I ended up needing to create custom sliders.\n\nI accomplished this by creating a budget slider out of shapes and used a drag gesture for interaction.\n\nShapes in SwiftUI make it easy to create stunning and unique views, but they are not accessible by default, and so neither is my budget slider.\n\nThis must be why some users are not able to edit their budgets.\n\nWe can confirm it's not accessible by running a SwiftUI preview and selecting the SliderShape.\n\nThe Accessibility Preview shows that there are no elements, so this control is not accessible.\n\nIdeally, we should have a single labeled accessibility element with a value that can be changed.\n\nIn contrast, standard controls are accessible by default, meaning little to no extra effort is required to provide a great experience.\n\nSwiftUI uses the view type and its initialization parameters to automatically derive the accessibility element's label, value, traits, and actions.\n\nSo what's the best way to make our custom budget slider accessible? Since the standard slider is accessible by default, my team and I thought it would be great to have an API that allows the accessibility of one view to be represented by another.\n\nThis is what led us to us to create accessibilityRepresentation(representation:).\n\nIt's an API that allows the accessibility of one view to be defined by another.\n\nSince I want this to be perceived by assistive technologies as a slider, that's what I'll use for the accessibility representation.\n\nWith accessibilityRepresentation(representation:), we're now well on the way to making this budget slider accessible.\n\nThe only change needed to improve the experience of the slider is to describe the value in dollars.\n\nAnd great, just like that, now our budget slider is perfectly accessible.\n\nOn macOS, the type of control will also be spoken to VoiceOver users.\n\nSo by using the slider view in our budget slider's representation, it will be announced as a slider.\n\nIt's recommended to use accessibilityRepresentation(representation:) when possible, to make custom controls accessible.\n\nThis is just one way to use accessibilityRepresentation(representation:).\n\nIts flexibility allows for many more creative uses.\n\nLet's see if we can use it to fix other accessibility bugs in our app.\n\nWhile we have now fixed the functional ability to edit budgets, some users reported that they couldn't discover how to navigate to the Budget Planner view.\n\nWhen designing Wallet Pal, we decided to use SF Symbols for all of our buttons.\n\nWhile SF Symbols may have great default accessibility labels, they may not always fit the intended use case.\n\nLet's investigate if the problem is a poorly labeled button.\n\nThe NavigationBarView contains the Edit Budgets button.\n\nSince we rely on SF Symbols for so many of our buttons, I created a custom buttonStyle called SymbolButtonStyle.\n\nBut it appears that despite initializing the button with the label \"Edit Budgets\", the label for the button is slider.vertical.3.\n\nSo the accessibility label is being derived from the SF Symbol.\n\nLet's take a closer look at the SymbolButtonStyle.\n\nThe SymbolButtonStyle's makeBody(configuration:) method returns an Image view.\n\nThe Edit Budgets string we initialize the button with would create a Text view as the configuration's label.\n\nBut this style completely ignores the configuration's label.\n\nThis is why the button is not labeled \"Edit Budgets\".\n\nWhile we want an SF Symbol to appear visually, we want the accessibility of the button to be represented by the configuration's label.\n\nAnd so this seems like a great use case for accessibilityRepresentation(representation:).\n\nUsing accessibilityRepresentation(representation:), I can substitute the accessibility of the Image view with another view, in this case, the configuration's label.\n\nThis way, we can preserve the label we used to create the button.\n\naccessibilityRepresentation(representation:) is not just the ideal and recommended way to make custom controls accessible, it also opens up new creative possibilities to make views accessible.\n\nNext, let's discuss the relationship between children and accessibility containers.\n\nAs you may recall, accessibility elements can be wrapped together in a group as children of an accessibility container.\n\nThis is done with the accessibilityElement(children:) modifier and the contain child behavior.\n\nIn case you're unfamiliar, the contain child behavior can be used to create an accessibility container, which wraps existing accessibility elements as children.\n\nBut what if instead you have an accessibility element and you want to set its children? I'm running into this case when trying to make the Budget History graph accessible.\n\nUsers reported the graph is completely inaccessible.\n\nAnd so this means when assistive technologies are focused on the Budget History header and try to navigate to the next element, they end up at the Alerts header.\n\nVoiceOver users would not even know that this graph exists.\n\nI built the graph using the new Canvas view.\n\nCanvas makes it easier to draw a collection of shapes.\n\nFor more on Canvas, please check out Jacob's presentation on how it can be used to add rich graphics to your app.\n\nThe most important takeaway for accessibility is that Canvas draws a collection of shapes.\n\nAnd just like we saw with BudgetSlider, shapes are not accessible by default.\n\nAll users need to be able to view their budget history, so let's make this accessible for everyone.\n\nStarting with the basics, let's give our Canvas a label.\n\nThis will automatically create a new accessibility element for the Canvas and assign its label.\n\nNow, I'd like each bar in the graph to be represented by their own accessibility element.\n\nThis is a use case where we have an accessibility element and want to provide its children.\n\nTo do this, I'll use the new accessibilityChildren(children:) modifier.\n\nThis will transform the accessibility element into an accessibility container, preserving other accessibility properties, such as the label.\n\nThe modifier takes a ViewBuilder, which allows us to set new views as children of the accessibility container.\n\nRecall that our Budget History graph is drawing a horizontal bar graph, so we'll use an HStack and return a view for each budget.\n\nI'll use a Rectangle for each accessibility element so that the frame will fill all available vertical space.\n\nThis will make each accessibility element's frame bigger than what's displayed visually, and that's OK.\n\nHaving a large but consistent frame will make it easier to navigate on iOS when VoiceOver users drag their finger across the screen to scan for accessibility elements.\n\nIf I select the HStack from within the accessibilityChildren(children:) modifier, the Accessibility Preview confirms that an element has been created for each bar in the graph.\n\nThese will all be accessible as children of the Canvas accessibility container.\n\nWith these changes, the Budget History graph is now completely accessible, and assistive technologies can navigate through each bar in the graph.\n\nNotice that the frame for each element is the same, which is ideal.\n\nFor more complex charts, we have other ways of making them accessible.\n\nFor that, please check out Preston's presentation on bringing accessibility to charts.\n\nBut with accessibility children, the accessibility elements of a view can differ from what's presented visually, allowing you to tailor a great experience.\n\nBut accessibility children can also be used to compose the accessibility with the help of the combine behavior.\n\nAs a quick refresh, the combine child behavior will merge properties from multiple accessibility elements into a new or existing accessibility element.\n\nBut with the addition of the accessibility children API, it can now also be used to compose accessibility in a generic way.\n\nWith accessibility representation, the original accessibility is completely replaced.\n\nThis means no composition can take place; whereas accessibility children is additive.\n\nThis means you could later combine the children to merge their properties into the original element.\n\nThis is a more advanced use case of the accessibilityChildren(children:) modifier, but it's a functionality I wanted to highlight.\n\nExamples are featured in this presentation's Accessibility Catalog Sample Project.\n\nI hope to see many of you explore what's possible with this kind of composition.\n\naccessibilityChildren(children:) gives you control over the children of a container.\n\nAnd with that, complex graphs drawn with Canvas can be made accessible with modifiers and views you're already familiar with.\n\nAnd with the combine child behavior, the accessibility of a single view can be composed of many.\n\nNow that we've learned how to make individual components of our app accessible, we can start putting things together to refine the navigation experience.\n\nI've heard that navigating Wallet Pal with VoiceOver is confusing and difficult.\n\nSo we have some more work to do if we want to deliver a great accessible app.\n\nLet's take a closer look at the Friends carousel at the top.\n\nWhile I don't have this feature built yet, I plan to add some kind of gamification to Wallet Pal.\n\nSo I've added a challenge button at the top left of each friend view.\n\nWe already fixed the SymbolButtonStyle, so the challenge button will be properly labeled now.\n\nBut since users are reporting that navigation is confusing, are there other issues? To answer that, we must first understand how assistive technologies will navigate Wallet Pal.\n\nBy default, accessibility elements are sorted based off their geometric position in relation to other elements, from top left to bottom right.\n\nThis means that without accessibility containers to differentiate the content, VoiceOver would navigate through each of the challenge buttons, then the Image and Add Friend button, and finally, the text with the user's name.\n\nA great feature of the Accessibility Preview is that it shows accessibility elements in their sorted order.\n\nThis makes it easy to visualize how assistive technologies will navigate right from within Xcode.\n\nAs expected, the sorted order matches what we previously saw.\n\nAnd this order would certainly be confusing to navigate.\n\nNow there are multiple ways we could fix the sort order of the accessibility elements.\n\nOne thing we could do is to introduce accessibility containers.\n\nI'll add the accessibilityElement(children:) modifier with the contain behavior.\n\nThis will wrap the accessibility elements of each FriendCellView in an accessibility container.\n\nThis fixes the navigation order, because children of an accessibility container are navigated before moving to the next accessibility element.\n\nWith this change, VoiceOver will navigate through the children of the accessibility container before moving to the next accessibility element.\n\nAnd so we achieve a much more desirable navigation order.\n\nBut could we do better to improve this experience? One problem is that the challenge button is navigated to before knowing who the user is.\n\nA VoiceOver user would want to know the name of the user before sending a challenge, so this button should really be sorted last.\n\nWe can use the accessibilitySortPriority(_:) modifier to fix this.\n\naccessibilitySortPriority(_:) can be used to change the order of elements within an accessibility container.\n\nAn element with a higher priority will be sorted first, whereas a lower priority will be sorted last.\n\nElements with equal priorities are then sorted based off their geometric positioning.\n\nI'll add the accessibilitySortPriority(_:) modifier to the challenge button to improve the navigation order.\n\nI'll use a priority of -1 since the default is 0, to force the sort order of the challenge button to be last.\n\nNow the challenge button will be navigated to last.\n\nThis is a good improvement, since there is less chance a VoiceOver user would be confused as to who they are sending a challenge to, but it's still not great.\n\nRather than wrapping each FriendCellView in an accessibility container, we could combine the children into a single element.\n\nRecall that combine merges properties from children into an existing or new accessibility element.\n\nThe combine behavior also curates which properties are merged for the best default result.\n\nFor example, the challenge button has become an action named \"Send Challenge\".\n\nThis too fixes the navigation order and reduces the number of accessibility elements.\n\nNow there's a single element for each user, and each element has a Send Challenge action.\n\nIt is often ideal to combine the accessibility elements of views that are represented in a ForEach.\n\nAs you may have picked up on by now, combine is a super useful child behavior.\n\nInstead of children being individually navigable, it merges their properties into a single, navigable element.\n\nFor when you need a single element but do not want it to inherit properties from the children, use the ignore behavior.\n\nAnd lastly, the contain child behavior wraps the children in an accessibility container and should be used to express a groups of views that are related.\n\nThis not only improves the default sort order but has other advantages to assistive technologies.\n\nWith the new Accessibility Preview, discovering these navigation problems is easy.\n\nAnd with a few small changes, you can dramatically improve the experience.\n\nBut to deliver a truly exceptional navigation experience to VoiceOver users, you'll will want to consider rotors.\n\nNow if you are new to accessibility, you might be thinking, \"What are rotors?\" In short, rotors are a powerful navigation tool.\n\nThey can be thought of as bookmarks that allow users to quickly navigate between them.\n\nSystem rotors, such as the headings and containers rotor, provide the foundation for this supercharged form of navigation.\n\nFor example, users can quickly navigate through sections using the headings rotor.\n\nThis is because the Section view automatically adds the isHeader trait to the header view If you are not using the Section view, you can add the isHeader trait to your view with accessibilityAddTraits(_:).\n\nSimilarly, accessibility containers are added to the container's rotor, which as we saw earlier, are created with the accessibilityElement(children:) modifier.\n\nAs you can see, supporting the headings rotor is incredibly easy, and the container's rotor further adds to the benefit of grouping your accessibility elements with the contain child behavior.\n\nNow that the basic navigation experience of Wallet Pal has been refined, let's take it a step further with rotors.\n\nIn Wallet Pal, alerts help keep users' spending habits in check by providing motivation messages and warnings when budgets near or exceed their limit.\n\nWe've incorporated SF Symbols for the different types of alerts.\n\nThese allow visual users to quickly scan through the list.\n\nBut this iconography will not help VoiceOver users.\n\nThey would instead have to navigate through every alert just to know if they have any warnings.\n\nTo replicate a similar experience that sighted users have, VoiceOver users need to be able to exclusively navigate warnings, that way, in an instant, they can navigate to the next warning alert.\n\nTo do this, we can use rotors.\n\nFor more examples of custom rotors and why they're so important to efficiency, please check out our \"VoiceOver Efficiency for Custom Rotors\" presentation from 2020.\n\nTo add a warnings rotor to my AlertsView, the first thing I'll do is to make sure I'm adding my rotor to an accessibility container.\n\nSome views in SwiftUI are accessibility containers by default -- such as List or LazyVStack -- but VStacks and HStacks are not, so I'll add the accessibilityElement(children:) modifier with the contain child behavior.\n\nNext, I'll create my rotor with the accessibilityRotor(_:entries:) modifier, giving it the name \"Warnings\".\n\nAnd lastly, I'll declare which of my alerts I want included in the warnings rotor, in this case all of the warning alerts.\n\nAnd that's it! It's this easy to supercharge your app's navigation.\n\nPart of what makes rotors so easy for these simple use cases is that SwiftUI can automatically match the rotor entry to the accessibility element based off the ID.\n\nThis is because the ID of our rotor entry will match the ID given to the AlertCellView by a ForEach.\n\nThe identity of a view is important to understand for accessibility rotors.\n\nSo if view identity is unclear or you'd like a refresher, I strongly encourage you to check out the \"Demystifying SwiftUI\" presentation to learn more.\n\nNow you might be thinking, \"Hold on, my view isn't this simple.\n\nWhat about views that are not within a ForEach?\" Don't worry, the accessibility rotor API can scale from simple to complex views.\n\nThis simple case works elegantly because there is a single accessibility element -- due to the combine -- for the AlertCellView.\n\nAnd the AlertCellView is identified by the ID of the alert.\n\nWhat if for every alert there was also an Actions view? In this case, the VStack is now the root view of our ForEach, and it's the VStack which will be given the identity of the alert.\n\nSo to include the AlertCellView in our warnings rotor, we will need to explicitly mark it as a rotor entry.\n\nWe can do that with the accessibilityRotorEntry modifier.\n\nThis modifier requires a namespace and an ID, which could be anything as long as they match the ID and namespace used to create the AccessibilityRotorEntry.\n\nAnd lastly, we'll need to include this namespace for each rotor entry.\n\nThe ability to refer to an explicit namespace is what enables the accessibility rotor API to scale from simple to complex use cases, allowing accessibility elements that span across multiple views to be included in the same rotor.\n\nAccessibility rotors can also be added to enrich text navigation.\n\nTo do that, use a different variant of the accessibilityRotor modifier, which allows you provide an array of text ranges.\n\nThis modifier is great for giving VoiceOver users quick and easy access to specific strings within a TextEditor, such as emails, links, or phone numbers.\n\nAccessibility rotors makes complex navigation easy for VoiceOver users.\n\nAnd with the new SwiftUI rotors API, it's never been easier to deliver this exceptional navigation experience.\n\nThe last topic for today is focus.\n\nThe concept of element of focus is something you may already be familiar with, but what you may not know is that many of our assistive technologies have their own focus state.\n\nThis is what we call \"accessibility focus\".\n\nIt's the focused view you have been seeing change when I refer to assistive technologies navigating.\n\nThe position of an assistive technology's cursor is critical to the user experience.\n\nWhen focus is changed in VoiceOver, the cursor moves to match the focused element's path in addition to speaking a description of the element.\n\nSo when does focus change? Focus can but may not always change when one of three events occur.\n\nThe first and most common use case is when a user drives a focus change when navigating to a different accessibility element.\n\nThe second case is when the UI changes, and the previously focused view is no longer on screen or is covered by a modal view.\n\nWhen this happens, focus is often reset to the first sorted accessibility element.\n\nThis covers many use cases automatically, such as moving to the first accessibility element of a newly presented view.\n\nBut that may not be the best behavior in your app, which is why focus can also be changed upon programmatic request.\n\nHowever, this should be handled with caution, because moving a VoiceOver user's focus can be very disruptive.\n\nOn that note, let's focus -- no pun intended -- on the last case.\n\nThis year we have a new API that will allow you to both request an assistive technology to move its focus, in addition to reading where an assistive technology is currently focused.\n\nHere we have a simple view which tracks a notification, and if it exists, overlays a custom NotificationBanner.\n\nWe want to use this view in Wallet Pal to show alerts for push notifications received while the app is in the foreground.\n\nWhen the NotificationBanner is added, assistive technologies will not automatically focus on it.\n\nBut we can request they do so with the new AccessibilityFocusState.\n\nAccessibilityFocusState is a property wrapper that provides both a way of reading where an assistive technology is focused and requesting a programmatic focus change.\n\nI'll add one to my view and bind it to the NotificationBanner with the accessibilityFocused(_:) modifier.\n\nNext, I'll use the onChange(of:perform:) modifier to track when a new notification is received.\n\nOnly when a high-priority notification is received do we request accessibility focus to change.\n\nIt's especially important to note that moving focus programmatically can be very disruptive if no user interaction occurred.\n\nIt takes the user out of whatever context they are currently focused on, so it must be handled with care.\n\nSo for lower priority notifications, I'll post an accessibility notification for VoiceOver to announce.\n\nThis way, VoiceOver users still know a new notification has appeared and can navigate to it if desired.\n\nNow let's step inside the NotificationBanner view.\n\nWhen the notification appears, a timer is started.\n\nUpon it completing, the notification is set to nil.\n\nRecall from before that when the notification is nil, the NotificationBanner will be hidden.\n\nThis means if a VoiceOver user was focused on the notification banner and the timer expired, their focus would be reset, since the view is removed; and this isn't a great user experience.\n\nTo fix this, let's read if our NotificationBanner is focused by an assistive technology, and if it is, delay the notification dismissal.\n\nThis is the ideal solution.\n\nA VoiceOver user's focus will no longer be reset, since the view is no longer removed while focused.\n\nAdditionally, we have given assistive technology users an unlimited number of time to digest the content and interact if desired; two things that may take assistive technology users much longer to do so.\n\nAccessibilityFocusState is the last piece you need to deliver exceptional and accessible SwiftUI apps this year and beyond.\n\nWith it, you can read and direct the focus of assistive technologies to create smooth transitions between views.\n\nWow, we've covered a lot today for SwiftUI accessibility.\n\nWe were introduced to the new Accessibility Preview, which enhances the way you can develop and debug SwiftUI accessibility; we covered how to make custom controls and complex graphs accessible; and we took the time to learn how the navigation experience can be improved with grouping, rotors, and focus.\n\nPut everything together, and it truly has been a huge leap for accessibility this year.\n\nFor some great simple and complex examples of our Accessibility APIs, please checkout the Accessibility Catalog Sample Project.\n\nIt features more examples that we couldn't cover today and some of our recommended best practices.\n\nThank you so much for joining me.\n\nWe look forward to seeing how you make your app accessible to everyone.\n\n♪",
    "segments": []
  },
  "codeExamples": [
    {
      "timestamp": "2:00",
      "title": "Welcome to the Accessibility Preview",
      "language": "swift",
      "code": "struct ContentView: View {\n    var body: some View {\n        VStack {\n            Text(\"WWDC 2021\")\n                .accessibilityAddTraits(.isHeader)\n\n            Text(\"SwiftUI Accessibility\")\n            Text(\"Beyond the Basics\")\n\n            Image(systemName: \"checkmark.seal.fill\")\n        }\n    }\n}"
    },
    {
      "timestamp": "4:30",
      "title": "BudgetSlider",
      "language": "swift",
      "code": "struct BudgetSlider: View {\n    @Binding var value: Double\n    var label: String\n\n    var body: some View {\n        VStack(alignment: .leading) {\n            HStack {\n                Text(label)\n                Text(value.toDollars()).bold()\n            }\n            SliderShape(value: value)\n                .gesture(DragGesture().onChanged(handle))\n        }\n    }\n}\n\nstruct SliderShape: View {\n    var value: Double\n\n    private struct BackgroundTrack: View {\n        var cornerRadius: CGFloat\n        var body: some View {\n            RoundedRectangle(\n                cornerRadius: cornerRadius,\n                style: .continuous\n            )\n            .foregroundColor(Color(white: 0.2))\n        }\n    }\n\n    private struct OverlayTrack: View {\n        var cornerRadius: CGFloat\n        var body: some View {\n            RoundedRectangle(\n                cornerRadius: cornerRadius,\n                style: .continuous\n            )\n            .foregroundColor(Color(white: 0.95))\n        }\n    }\n\n    private struct Knob: View {\n        var cornerRadius: CGFloat\n        var body: some View {\n            RoundedRectangle(\n                cornerRadius: cornerRadius,\n                style: .continuous\n            )\n            .strokeBorder(Color(white: 0.7), lineWidth: 1)\n            .shadow(radius: 3)\n        }\n    }\n\n    var body: some View {\n        GeometryReader { geometry in\n            ZStack(alignment: .leading) {\n                BackgroundTrack(cornerRadius: geometry.size.height / 2)\n\n                OverlayTrack(cornerRadius: geometry.size.height / 2)\n                    .frame(\n                        width: max(geometry.size.height, geometry.size.width * CGFloat(value) + geometry.size.height / 2),\n                        height: geometry.size.height)\n\n                Knob(cornerRadius: geometry.size.height / 2)\n                    .frame(\n                        width: geometry.size.height,\n                        height: geometry.size.height)\n                    .offset(x: max(0, geometry.size.width * CGFloat(value) - geometry.size.height / 2), y: 0)\n            }\n        }\n    }\n}\n\nextension Double {\n    func toDollars() -> String {\n        return \"$\\(Int(self))\"\n    }\n}"
    },
    {
      "timestamp": "5:15",
      "title": "Slider",
      "language": "swift",
      "code": "struct StandardSlider: View {\n    @Binding var value: Double\n    var label: String\n\n    var body: some View {\n        Slider(value: $value, in: 0...1) {\n            Text(label) \n        }\n    }\n}"
    },
    {
      "timestamp": "5:50",
      "title": "Accessible BudgetSlider",
      "language": "swift",
      "code": "struct BudgetSlider: View {\n    @Binding var value: Double\n    var label: String\n\n    var body: some View {\n        VStack(alignment: .leading) {\n            HStack {\n                Text(label)\n                Text(value.toDollars()).bold()\n            }\n            SliderShape(value: value)\n                .gesture(DragGesture().onChanged(handle))\n                .accessibilityRepresentation {\n                    Slider(value: $value, in: 0...1) {\n                        Text(label)\n                    }\n                    .accessibilityValue(value.toDollars())\n                }\n        }\n    }\n}\n\nstruct SliderShape: View {\n    var value: Double\n\n    private struct BackgroundTrack: View {\n        var cornerRadius: CGFloat\n        var body: some View {\n            RoundedRectangle(\n                cornerRadius: cornerRadius,\n                style: .continuous\n            )\n            .foregroundColor(Color(white: 0.2))\n        }\n    }\n\n    private struct OverlayTrack: View {\n        var cornerRadius: CGFloat\n        var body: some View {\n            RoundedRectangle(\n                cornerRadius: cornerRadius,\n                style: .continuous\n            )\n            .foregroundColor(Color(white: 0.95))\n        }\n    }\n\n    private struct Knob: View {\n        var cornerRadius: CGFloat\n        var body: some View {\n            RoundedRectangle(\n                cornerRadius: cornerRadius,\n                style: .continuous\n            )\n            .strokeBorder(Color(white: 0.7), lineWidth: 1)\n            .shadow(radius: 3)\n        }\n    }\n\n    var body: some View {\n        GeometryReader { geometry in\n            ZStack(alignment: .leading) {\n                BackgroundTrack(cornerRadius: geometry.size.height / 2)\n\n                OverlayTrack(cornerRadius: geometry.size.height / 2)\n                    .frame(\n                        width: max(geometry.size.height, geometry.size.width * CGFloat(value) + geometry.size.height / 2),\n                        height: geometry.size.height)\n\n                Knob(cornerRadius: geometry.size.height / 2)\n                    .frame(\n                        width: geometry.size.height,\n                        height: geometry.size.height)\n                    .offset(x: max(0, geometry.size.width * CGFloat(value) - geometry.size.height / 2), y: 0)\n            }\n        }\n    }\n}\n\nextension Double {\n    func toDollars() -> String {\n        return \"$\\(Int(self))\"\n    }\n}"
    },
    {
      "timestamp": "7:05",
      "title": "NavigationBarView",
      "language": "swift",
      "code": "struct NavigationBarView: View {\n    var body: some View {\n        HStack {\n            Text(\"Wallet Pal\")\n                .font(.largeTitle)\n                .bold()\n\n            Spacer()\n\n            Button(\"Edit Budgets\", action: { ... })\n                .buttonStyle(\n                    SymbolButtonStyle(\n                        systemName: \"slider.vertical.3\"))\n        }\n    }\n}\n\nstruct SymbolButtonStyle: ButtonStyle {\n    let systemName: String\n\n    func makeBody(configuration: Configuration) -> some View {\n\t\t\t\tImage(systemName: systemName)\n            .accessibilityRepresentation { configuration.label }\n    }\n}"
    },
    {
      "timestamp": "9:40",
      "title": "BudgetHistoryGraph",
      "language": "swift",
      "code": "struct Budget: Identifiable {\n    var month: String\n    var amount: Double\n\n    var id: String { month }\n}\n\nstruct BudgetHistoryGraph: View {\n    var budgets: [Budget]\n\n    var body: some View {\n        GeometryReader { proxy in\n            VStack {\n                Canvas { ctx, size in\n                    let inset: CGFloat = 25\n                    let insetSize = CGSize(width: size.width, height: size.height - inset * 2)\n                    let width = insetSize.width / CGFloat(budgets.count)\n                    let max = budgets.map(\\.amount).max() ?? 0\n                    for n in budgets.indices {\n                        let x = width * CGFloat(n)\n                        let height = (CGFloat(budgets[n].amount) / CGFloat(max)) * insetSize.height\n                        let y = insetSize.height - height\n                        let p = Path(\n                            roundedRect: CGRect(\n                                x: x + 2.5,\n                                y: y + inset,\n                                width: width - 5,\n                                height: height),\n                            cornerRadius: 4)\n                        ctx.fill(p, with: .color(Color.green))\n\n                        ctx.draw(Text(budgets[n].amount.toDollars()), at: CGPoint(x: x + width / 2, y: y + inset / 2))\n\n                        ctx.draw(Text(budgets[n].month), at: CGPoint(x: x + width / 2, y: y + height + 1.5*inset))\n                    }\n                }\n                .accessibilityLabel(\"Budget History Graph\")\n                .accessibilityChildren {\n                    HStack {\n                        ForEach(budgets) { budget in\n                            Rectangle()\n                                .accessibilityLabel(budget.month)\n                                .accessibilityValue(budget.amount.toDollars())\n\n                        }\n                    }\n                }\n\n            }\n        }\n        .padding()\n        .background(\n            RoundedRectangle(cornerRadius: 16)\n                .foregroundColor(Color(white: 0.9)))\n        .padding(.horizontal)\n    }\n}"
    },
    {
      "timestamp": "12:30",
      "title": "Composition",
      "language": "swift",
      "code": "// See CompositionExample.swift in the referenced sample project"
    },
    {
      "timestamp": "13:50",
      "title": "FriendCellView",
      "language": "swift",
      "code": "struct User: Identifiable {\n    var id: Int\n    var name: String\n    var photo: String\n}\n\nstruct FriendCellView: View {\n    var user: User\n\n    var body: some View {\n        ZStack(alignment: .topLeading) {\n            VStack(alignment: .center) {\n                Image(user.photo)\n                Text(user.name)\n            }\n\n            Button(\"Send Challenge\", action: { /* ... */ })\n                .buttonStyle(\n                    SymbolButtonStyle(\n                        systemName: \"gamecontroller.fill\"))\n        }\n    }\n}\n\nstruct SymbolButtonStyle: ButtonStyle {\n    let systemName: String\n\n    func makeBody(configuration: Configuration) -> some View {\n\t\t\t\tImage(systemName: systemName)\n            .accessibilityRepresentation { configuration.label }\n    }\n}"
    },
    {
      "timestamp": "14:50",
      "title": "FriendsView",
      "language": "swift",
      "code": "struct User: Identifiable {\n    var id: Int\n    var name: String\n    var photo: String\n}\n\nstruct FriendCellView: View {\n    var user: User\n\n    var body: some View {\n        ZStack(alignment: .topLeading) {\n            VStack(alignment: .center) {\n                Image(user.photo)\n                Text(user.name)\n            }\n\n            Button(\"Send Challenge\", action: { /* ... */ })\n                .buttonStyle(\n                    SymbolButtonStyle(\n                        systemName: \"gamecontroller.fill\"))\n        }\n    }\n}\n      \nstruct FriendsView: View {\n    var users: [User]\n\n    var body: some View {\n        ScrollView(.horizontal, showsIndicators: false) {\n            HStack {\n                ForEach(users) { user in\n                    FriendCellView(user: user)\n                        .onTapGesture { /* ... */ }\n                }\n\n                AddFriendButton()\n\n                Spacer()\n            }\n        }\n    }\n}\n  \nstruct AddFriendButton: View {\n    var body: some View {\n        Button(action: { /* ... */ }) {\n            Circle()\n                .foregroundColor(Color(white: 0.9))\n                .frame(width: 50, height: 50)\n                .overlay(\n                    Image(systemName: \"plus\")\n                        .resizable()\n                        .foregroundColor(Color(white: 0.5))\n                        .padding(15)\n                )\n        }\n        .buttonStyle(PlainButtonStyle())\n    }\n}\n\nstruct SymbolButtonStyle: ButtonStyle {\n    let systemName: String\n\n    func makeBody(configuration: Configuration) -> some View {\n\t\t\t\tImage(systemName: systemName)\n            .accessibilityRepresentation { configuration.label }\n    }\n}"
    },
    {
      "timestamp": "15:10",
      "title": "FriendsView with Containers",
      "language": "swift",
      "code": "struct User: Identifiable {\n    var id: Int\n    var name: String\n    var photo: String\n}\n\nstruct FriendCellView: View {\n    var user: User\n\n    var body: some View {\n        ZStack(alignment: .topLeading) {\n            VStack(alignment: .center) {\n                Image(user.photo)\n                Text(user.name)\n            }\n\n            Button(\"Send Challenge\", action: { /* ... */ })\n                .buttonStyle(\n                    SymbolButtonStyle(\n                        systemName: \"gamecontroller.fill\"))\n        }\n    }\n}\n      \nstruct FriendsView: View {\n    var users: [User]\n\n    var body: some View {\n        ScrollView(.horizontal, showsIndicators: false) {\n            HStack {\n                ForEach(users) { user in\n                    FriendCellView(user: user)\n                         .accessibilityElement(children: .contain)\n                        .onTapGesture { /* ... */ }\n                }\n\n                AddFriendButton()\n\n                Spacer()\n            }\n        }\n    }\n}\n  \nstruct AddFriendButton: View {\n    var body: some View {\n        Button(action: { /* ... */ }) {\n            Circle()\n                .foregroundColor(Color(white: 0.9))\n                .frame(width: 50, height: 50)\n                .overlay(\n                    Image(systemName: \"plus\")\n                        .resizable()\n                        .foregroundColor(Color(white: 0.5))\n                        .padding(15)\n                )\n        }\n        .buttonStyle(PlainButtonStyle())\n    }\n}\n\nstruct SymbolButtonStyle: ButtonStyle {\n    let systemName: String\n\n    func makeBody(configuration: Configuration) -> some View {\n\t\t\t\tImage(systemName: systemName)\n            .accessibilityRepresentation { configuration.label }\n    }\n}"
    },
    {
      "timestamp": "16:20",
      "title": "FriendCellView Sort Priority",
      "language": "swift",
      "code": "struct User: Identifiable {\n    var id: Int\n    var name: String\n    var photo: String\n}\n\nstruct FriendCellView: View {\n    var user: User\n\n    var body: some View {\n        ZStack(alignment: .topLeading) {\n            VStack(alignment: .center) {\n                Image(user.photo)\n                Text(user.name)\n            }\n\n            Button(\"Send Challenge\", action: { /* ... */ })\n                .buttonStyle(\n                    SymbolButtonStyle(\n                        systemName: \"gamecontroller.fill\"))\n                .accessibilitySortPriority(-1)\n        }\n    }\n}"
    },
    {
      "timestamp": "16:55",
      "title": "FriendsView with .combine",
      "language": "swift",
      "code": "struct User: Identifiable {\n    var id: Int\n    var name: String\n    var photo: String\n}\n\nstruct FriendCellView: View {\n    var user: User\n\n    var body: some View {\n        ZStack(alignment: .topLeading) {\n            VStack(alignment: .center) {\n                Image(user.photo)\n                Text(user.name)\n            }\n\n            Button(\"Send Challenge\", action: { /* ... */ })\n                .buttonStyle(\n                    SymbolButtonStyle(\n                        systemName: \"gamecontroller.fill\"))\n        }\n    }\n}\n      \nstruct FriendsView: View {\n    var users: [User]\n\n    var body: some View {\n        ScrollView(.horizontal, showsIndicators: false) {\n            HStack {\n                ForEach(users) { user in\n                    FriendCellView(user: user)\n                        .accessibilityElement(children: .combine)\n                        .onTapGesture { /* ... */ }\n                }\n\n                AddFriendButton()\n\n                Spacer()\n            }\n        }\n    }\n}\n  \nstruct AddFriendButton: View {\n    var body: some View {\n        Button(action: { /* ... */ }) {\n            Circle()\n                .foregroundColor(Color(white: 0.9))\n                .frame(width: 50, height: 50)\n                .overlay(\n                    Image(systemName: \"plus\")\n                        .resizable()\n                        .foregroundColor(Color(white: 0.5))\n                        .padding(15)\n                )\n        }\n        .buttonStyle(PlainButtonStyle())\n    }\n}\n\nstruct SymbolButtonStyle: ButtonStyle {\n    let systemName: String\n\n    func makeBody(configuration: Configuration) -> some View {\n\t\t\t\tImage(systemName: systemName)\n            .accessibilityRepresentation { configuration.label }\n    }\n}"
    },
    {
      "timestamp": "20:30",
      "title": "AlertsView Implicit Rotor",
      "language": "swift",
      "code": "struct Alert: Identifiable {\n    var id: Int\n    var isUnread: Bool\n    var isFlagged: Bool\n    var subject: String\n    var content: String\n}\n\nstruct AlertsView: View {\n    var alerts: [Alert]\n\n    var body: some View {\n        VStack {\n            ForEach(alerts) { alert in\n                AlertCellView(alert: alert)\n                    .accessibilityElement(children: .combine)\n            }\n        }\n        .accessibilityElement(children: .contain)\n        .accessibilityRotor(\"Warnings\") {\n            ForEach(alerts) { alert in\n                if alert.isWarning {\n                    AccessibilityRotorEntry(alert.title, id: alert.id)\n                }\n            }\n        }\n    }\n}\n\nstruct AlertCell: View {\n    var alert: Alert\n\n    var body: some View {\n        VStack(alignment: .leading) {\n            HStack {\n                if alert.isUnread {\n                    Circle()\n                        .foregroundColor(.blue)\n                        .frame(width: 10, height: 10)\n                }\n                if alert.isFlagged {\n                    Image(systemName: \"exclamationmark.triangle.fill\")\n                        .foregroundColor(.orange)\n                        .frame(width: 10, height: 10)\n                }\n                Text(alert.subject)\n                    .font(.headline)\n                    .fontWeight(.semibold)\n                Spacer()\n                Text(\"04/30/21\")\n                    .font(.subheadline)\n                    .foregroundColor(.secondary)\n            }\n            Text(alert.content)\n                .lineLimit(3)\n        }\n        .padding(10)\n        .background(\n            RoundedRectangle(cornerRadius: 8)\n                .foregroundColor(Color(white: 0.9))\n        )\n    }\n}"
    },
    {
      "timestamp": "21:50",
      "title": "AlertsView Explicit Rotor",
      "language": "swift",
      "code": "struct Alert: Identifiable {\n    var id: Int\n    var isUnread: Bool\n    var isFlagged: Bool\n    var subject: String\n    var content: String\n}\n\nstruct AlertsView: View {\n    var alerts: [Alert]\n    @Namespace var namespace\n\n    var body: some View {\n        VStack {\n            ForEach(alerts) { alert in\n                VStack {\n                    AlertCellView(alert: alert)\n                        .accessibilityElement(children: .combine)\n                        .accessibilityRotorEntry(id: alert.id, in: namespace)\n                    AlertActionsView(alert: alert)\n                }\n            }\n        }\n        .accessibilityElement(children: .contain)\n        .accessibilityRotor(\"Warnings\") {\n            ForEach(alerts) { alert in\n                if alert.isWarning {\n                    AccessibilityRotorEntry(alert.title, id: alert.id, in: namespace)\n                }\n            }\n        }\n    }\n}\n\nstruct AlertCell: View {\n    var alert: Alert\n\n    var body: some View {\n        VStack(alignment: .leading) {\n            HStack {\n                if alert.isUnread {\n                    Circle()\n                        .foregroundColor(.blue)\n                        .frame(width: 10, height: 10)\n                }\n                if alert.isFlagged {\n                    Image(systemName: \"exclamationmark.triangle.fill\")\n                        .foregroundColor(.orange)\n                        .frame(width: 10, height: 10)\n                }\n                Text(alert.subject)\n                    .font(.headline)\n                    .fontWeight(.semibold)\n                Spacer()\n                Text(\"04/30/21\")\n                    .font(.subheadline)\n                    .foregroundColor(.secondary)\n            }\n            Text(alert.content)\n                .lineLimit(3)\n        }\n        .padding(10)\n        .background(\n            RoundedRectangle(cornerRadius: 8)\n                .foregroundColor(Color(white: 0.9))\n        )\n    }\n}"
    },
    {
      "timestamp": "22:20",
      "title": "TextEditor Rotors",
      "language": "swift",
      "code": "struct ContentView: View {\n    @State var note: Note\n\n    var body: some View {\n        TextEditor($text.content)\n            .accessibilityRotor(\"Email Addresses\", textRanges: note.addressRanges)\n            .accessibilityRotor(\"Links\", textRanges: note.linkRanges)\n            .accessibilityRotor(\"Phone Numbers\", textRanges: note.phoneNumberRanges)\n    }\n}"
    },
    {
      "timestamp": "24:45",
      "title": "AlertNotificationView",
      "language": "swift",
      "code": "struct Notification: Equatable {\n    enum Priority {\n        case low, high\n    }\n    var content: String\n    var priority: Priority\n}\n\nstruct AlertNotificationView<Content: View>: View {\n    @ViewBuilder var content: Content\n    @Binding var notification: Notification?\n    @AccessibilityFocusState var isNotificationFocused: Bool\n\n    var body: some View {\n        ZStack(alignment: .top) {\n            content\n\n            if let notification = $notification {\n                NotificationBanner(notification: notification)\n                    .accessibilityFocused($isNotificationFocused)\n            }\n        }\n        .onChange(of: notification) { notification in\n            if notification?.priority == .high {\n                isNotificationFocused = true\n            } else {\n                postAccessibilityNotification()\n            }\n        }\n    }\n\n    func postAccessibilityNotification() {\n        guard let announcement = notification?.content else {\n            return\n        }\n        #if os(macOS)\n        NSAccessibility.post(\n            element: NSApp.accessibilityWindow(),\n            notification: .announcementRequested,\n            userInfo: [.announcement: announcement])\n        #else\n        UIAccessibility.post(notification: .announcement, argument: announcement)\n        #endif\n    }\n}\n\nstruct NotificationBanner: View {\n    @Binding var notification: Notification?\n    @State var timer: Timer?\n    @AccessibilityFocusState var isNotificationFocused: Bool\n\n    var body: some View {\n        if let notification = notification {\n            Text(notification.content)\n                .accessibilityFocused($isNotificationFocused)\n                .onAppear { startTimer() }\n                .onDisappear { stopTimer() }\n        } else {\n            EmptyView()\n        }\n    }\n\n    func startTimer() {\n        timer = Timer.scheduledTimer(\n            withTimeInterval: 3,\n            repeats: true) { _ in\n            if !isNotificationFocused {\n                notification = nil\n            }\n        }\n    }\n\n    func stopTimer() {\n        timer?.invalidate()\n    }\n}"
    }
  ],
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "Accessibility",
        "url": "https://developer.apple.com/documentation/swiftui/view-accessibility"
      },
      {
        "title": "Creating Accessible Views",
        "url": "https://developer.apple.com/documentation/swiftui/creating_accessible_views"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2021/10119/6/A3AEB1E4-C4E9-43B4-9EF6-206F6B9704E6/downloads/wwdc2021-10119_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2021/10119/6/A3AEB1E4-C4E9-43B4-9EF6-206F6B9704E6/downloads/wwdc2021-10119_sd.mp4?dl=1"
  },
  "relatedVideos": [
    {
      "id": "10034",
      "year": "2023",
      "title": "Create accessible spatial experiences",
      "url": "https://developer.apple.com/videos/play/wwdc2023/10034"
    },
    {
      "id": "10021",
      "year": "2021",
      "title": "Add rich graphics to your SwiftUI app",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10021"
    },
    {
      "id": "10122",
      "year": "2021",
      "title": "Bring accessibility to charts in your app",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10122"
    },
    {
      "id": "10223",
      "year": "2021",
      "title": "Create accessible experiences for watchOS",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10223"
    },
    {
      "id": "10022",
      "year": "2021",
      "title": "Demystify SwiftUI",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10022"
    },
    {
      "id": "10018",
      "year": "2021",
      "title": "What's new in SwiftUI",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10018"
    },
    {
      "id": "10116",
      "year": "2020",
      "title": "VoiceOver efficiency with custom rotors",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10116"
    }
  ],
  "extractedAt": "2025-07-18T09:08:40.194Z"
}