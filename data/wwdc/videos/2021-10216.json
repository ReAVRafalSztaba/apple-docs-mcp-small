{
  "id": "10216",
  "year": "2021",
  "url": "https://developer.apple.com/videos/play/wwdc2021/10216/",
  "title": "ARC in Swift: Basics and beyond",
  "speakers": [],
  "duration": "",
  "topics": [
    "Swift"
  ],
  "hasTranscript": true,
  "hasCode": true,
  "transcript": {
    "fullText": "♪ Bass music playing ♪  ♪ Meghana Gupta: Hi, my name is Meghana.\n\nToday, I'll be talking to you about ARC in Swift.\n\nSwift provides powerful value types like structs and enums.\n\nYou should prefer to use value types when possible to avoid the dangers of unintended sharing that comes with reference types.\n\nClasses are reference types in Swift, and if you decide to use them, Swift manages its memory via Automatic Reference Counting, or ARC.\n\nIn order to write effective Swift, it is important to understand how ARC works.\n\nIn this session, we’ll do just that.\n\nI’ll start with a review of object lifetimes and ARC in Swift.\n\nThen, I’ll describe what observable object lifetimes are.\n\nI'll explain in detail what language features make object lifetimes observable, consequences of relying on observed object lifetimes, and some safe techniques to fix them.\n\nLet’s begin.\n\nAn object’s lifetime in Swift begins at initialization and ends at last use.\n\nARC automatically manages memory, by deallocating an object after its lifetime ends.\n\nIt determines an object’s lifetime by keeping track of its reference counts.\n\nARC is mainly driven by the Swift compiler which inserts retain and release operations.\n\nAt runtime, retain increments the reference count and release decrements it.\n\nWhen the reference count drops to zero, the object will be deallocated.\n\nLet’s see how it works with an example.\n\nImagine we want to build a travel app.\n\nTo represent a traveler, let’s write a class with name and an optional destination property.\n\nIn the test() function, first, a Traveler object is created, then its reference is copied, and finally, its destination is updated.\n\nIn order to automatically manage the memory of the Traveler object, the Swift compiler inserts a retain operation when a reference begins and a release operation after the last use of the reference.\n\ntraveler1 is the first reference to the Traveler object, and its last use is the copy.\n\nHere, the Swift compiler inserts a release operation immediately after the last use of the traveler1 reference.\n\nIt does not insert a retain operation when the reference begins, because initialization sets the reference count to one.\n\ntraveler2 is another reference to the Traveler object, and its last use is the destination update.\n\nHere, the Swift compiler inserts a retain operation when the reference begins and a release operation immediately after the last use of the reference.\n\nLet's step through the code and see what happens at runtime.\n\nFirst, the Traveler object is created on the heap and initialized with a reference count of one.\n\nThen in preparation of the new reference, retain operation executes, incrementing the reference count to two.\n\nNow traveler2 is also a reference to the Traveler object.\n\nAfter the last use of the traveler1 reference, the release operation executes, decrementing the reference count to one.\n\nThen the destination of the Traveler object is updated to Big Sur.\n\nSince that was the last use of the traveler2 reference, release operation executes, decrementing the reference count to zero.\n\nOnce the reference count drops to zero, the object can be deallocated.\n\nObject lifetimes in Swift are use-based.\n\nAn object's guaranteed minimum lifetime begins at initialization and ends at last use.\n\nThis is different from languages like C++, in which an object’s lifetime is guaranteed to end at the closing brace.\n\nIn this example, we saw the object was deallocated immediately after the last use.\n\nHowever, in practice, object lifetimes are determined by the retain and release operations inserted by the Swift compiler.\n\nAnd depending on the ARC optimizations that kick in, the observed object lifetimes may differ from their guaranteed minimum, ending beyond the last use of the object.\n\nIn such cases, the object is deallocated at a program point beyond its last use.\n\nIn most cases, it doesn’t really matter what the exact lifetime of an object is.\n\nHowever, with language features like weak and unowned references and deinitializer side effects, it is possible to observe object lifetimes.\n\nAnd if you have programs that rely on observed object lifetimes instead of guaranteed object lifetimes, you can end up with problems in the future.\n\nBecause relying on observed object lifetimes may work today, but it is only a coincidence.\n\nObserved object lifetimes are an emergent property of the Swift compiler and can change as implementation details change.\n\nSuch bugs may not be discovered during development and may remain hidden for a long time, only to be uncovered by a compiler update with improved ARC optimizations or unrelated source changes that enable a previously limited ARC optimization.\n\nI’ll go over the language features that make object lifetimes observable, walk through what can happen if we rely only on observed object lifetimes, and some safe techniques to fix them.\n\nUnlike default references that are strong references, weak and unowned references do not participate in reference counting, and for this reason, they are commonly used to break reference cycles.\n\nBefore I get into their details, let’s see what reference cycles are.\n\nThis is an extension of our Travel app.\n\nWe now want to introduce an optional points system.\n\nA traveler can have an account and accumulate points in it.\n\nTo represent this, we have a new Account class with points property.\n\nThe Account class refers to the Traveler class, and the Traveler class refers back to the Account class.\n\nIn the test() function, we create Traveler and Account objects, and then call the printSummary() function via the traveler reference.\n\nLet’s step through the code and see what happens with ARC.\n\nFirst, Traveler object is created on the heap with a reference count of one.\n\nThen Account object is created on the heap with a reference count of one.\n\nSince the Account object refers to the Traveler object, the reference count of the Traveler object is incremented to two.\n\nNow the Traveler object starts referring to the Account object, so the reference count of the Account object is also incremented to two.\n\nThis is the last use of the account reference.\n\nAfter this, the account reference goes away and reference count of the Account object is decremented to one.\n\nThen, printSummary() function is called to print name and points.\n\nThis is the last use of the Traveler reference.\n\nAfter this, the Traveler reference goes away and the reference count of the Traveler object is decremented to one.\n\nEven after all the references that make the objects reachable go away, the reference count of the objects remain one.\n\nThis is because of the reference cycle.\n\nAs a result, the objects are never deallocated, causing a memory leak.\n\nYou may break the reference cycle with a weak or unowned reference.\n\nBecause they don’t participate in reference counting, the referred object may be deallocated while a weak or unowned reference is in use.\n\nWhen this happens, the Swift runtime safely turns access to weak references as nil, and access to unowned references as traps.\n\nAny reference participating in the reference cycle can be marked as weak or unowned to break the reference cycle.\n\nIt depends on the application.\n\nIn our example, let’s mark the traveler reference in the Account class as weak.\n\nBecause weak reference does not participate in reference counting, after the last use of the Traveler object, its reference count drops to zero.\n\nOnce the reference count of the Traveler object is zero, it can be deallocated.\n\nWhen the Traveler object goes away, its reference to the Account object goes away, making its reference count zero.\n\nNow the Account object can be deallocated.\n\nIn this example, we used the weak reference to only break the reference cycle.\n\nIf a weak reference is used to access an object while its guaranteed object lifetime has ended, and you are relying on observed object lifetime for the object to be available, you can end up with bugs in the future when the observed object lifetime changes for unrelated reasons.\n\nLet’s see an example.\n\nHere, the printSummary() function is moved from the Traveler class to the Account class.\n\nAnd the test() function now calls the printSummary() function via the Account reference.\n\nWhat exactly happens when printSummary() function is called? It may print the traveler’s name and points today, but this is only a coincidence.\n\nThis is because the last use of the Traveler object is before the call to the printSummary() function.\n\nAfter this, the reference count of the Traveler object can drop to zero if the compiler inserted a release immediately after the last use.\n\nIf the reference count has dropped to zero, access to the Traveler object via the weak reference will be nil, and the Traveler object may be deallocated.\n\nSo when the printSummary() function is called, the force unwrap of the weak Traveler reference will trap, causing a crash.\n\nYou may be wondering if the force unwrap is the reason for the crash here, and optional binding may have prevented it.\n\nOptional binding actually worsens the problem.\n\nWithout an obvious crash, it creates a silent bug that may go unnoticed when the observed object lifetime changes for unrelated reasons.\n\nThere are different techniques to safely handle weak and unowned references, each of them with varying degrees of upfront implementation cost versus continuous maintenance cost.\n\nLet’s explore them one by one with our example.\n\nSwift provides withExtendedLifetime() utility that can explicitly extend the lifetime of an object.\n\nUsing withExtendedLifetime(), it is possible to safely extend the lifetime of the Traveler object, while the printSummary() function is being called, preventing potential bugs.\n\nThe same effect can be achieved by placing an empty call to withExtendedLifetime() at the end of the existing scope.\n\nFor more complex cases, we can ask the compiler to extend the lifetime of an object to the end of the current scope using defer.\n\nwithExtendedLifetime() may look like an easy way out of object lifetimes bugs.\n\nHowever, this technique is fragile, and transfers the responsibility of correctness on you.\n\nWith this approach, you should ensure withExtendedLifetime() is used every time a weak reference has a potential to cause bugs.\n\nIf not controlled, withExtendedLifetime() can creep up all over the codebase, increasing maintenance cost.\n\nRedesigning classes with better APIs is a much more principled approach.\n\nObject lifetime surprises can be prevented, if access to the object can be limited to strong references only.\n\nHere, the printSummary() function is moved back to the Traveler class, and the weak reference in Account class is hidden.\n\nTests are now forced to call the printSummary() function via a strong reference, eliminating potential bugs.\n\nIn addition to carrying a performance cost, weak and unowned references can expose bugs if you are not careful with class design.\n\nIt is important to pause and think, why are weak and unowned references needed? Are they used only to break reference cycles? What if you avoid creating reference cycles in the first place? Reference cycles can often be avoided by rethinking algorithms and transforming cyclic class relationships to tree structures.\n\nIn our example, Traveler class needs to refer to the Account class.\n\nIt is not really necessary for the Account class to refer to the Traveler class.\n\nAccount class only needs access to the traveler’s personal information.\n\nWe can move the traveler’s personal information into a new class called PersonalInfo.\n\nBoth Traveler class and Account class can refer to the PersonalInfo class, avoiding the cycle.\n\nAvoiding the need for weak and unowned references may have additional implementation cost, but this is a definite way to eliminate all potential object lifetime bugs.\n\nAnother language feature that makes object lifetimes observable are deinitializer side effects.\n\nA deinitializer runs before deallocation and its side effects can be observed by external program effects.\n\nIf you write code to sequence deinitializer side effects with external program effects, it can lead to hidden bugs, which are uncovered only when the observed object lifetime changes due to unrelated reasons.\n\nBefore I get into how such bugs can come up, let’s see what a deinitializer is.\n\nThis is a repeat of the first example, now with a deinitializer.\n\nThe deinitializer has a global side effect: printing a message on the console.\n\nToday the deinitializer may run after \"Done traveling\" is printed.\n\nBut since the last use of the Traveler object is the destination update, the deinitializer can run before \"Done traveling\" is printed, depending on the ARC optimizations that kick in.\n\nIn this example, deinitializer side effects were observable but not relied upon.\n\nLet’s look at a more complex example, where deinitializer side effects are relied upon by external program effects.\n\nWe now introduce travel metrics to the Traveler class.\n\nWhenever a destination is updated, it is recorded in the TravelMetrics class.\n\nEventually when deinitializing the Traveler object, metrics get published to a global record.\n\nMetrics published are the traveler’s anonymous ID, number of destinations looked up, and a computed travel interest category.\n\nIn the test() function, first, a Traveler object is created, then reference to the travelMetrics is copied from the Traveler object.\n\nThe traveler’s destination is updated to Big Sur, which records Big Sur in TravelMetrics.\n\nThe traveler’s destination is updated to Catalina, which records Catalina in TravelMetrics.\n\nThen the travel interest category is computed by looking at the recorded destinations.\n\nToday the deinitializer may run after computing travel interest, publishing the interested category as Nature.\n\nBut the last use of the Traveler object is the destination update to Catalina, immediately after which the deinitializer can run.\n\nSince the deinitializer runs before computing the travel interest, nil gets published, causing a bug.\n\nJust like weak and unowned references, there are different techniques to safely handle deinitializer side effects.\n\nEach of them with varying degrees of upfront implementation cost versus continuous maintenance cost.\n\nLet’s look at them one by one.\n\nwithExtendedLifetime() can be used to explicitly extend the lifetime of the Traveler object until the travel interest category is computed, preventing potential bugs.\n\nAs discussed before, this transfers responsibility of correctness on you.\n\nWith this approach, you should ensure withExtendedLifetime is used every time there is a potential of incorrect interaction between deinitializer side effects and external program effects, increasing maintenance cost.\n\nDeinitializer side effects cannot be observed if the effects are all local.\n\nRedesigning class API by limiting the visibility of internal class details can prevent object lifetime bugs.\n\nHere, TravelMetrics is marked private, hiding it from external access.\n\nThe deinitializer now computes the most interested travel category and publishes the metrics.\n\nThis works, but a more principled approach is to get rid of the deinitializer side effects altogether.\n\nHere, defer is used instead of the deinitializer to publish metrics, and the deinitializer only performs verification.\n\nBy removing deinitializer side effects, we can eliminate all potential object lifetime bugs.\n\nWe explored our educational Travel app example to learn about ARC, weak and unowned references, and deinitializer side effects.\n\nIt is important to thoroughly understand the language features that make object lifetimes observable and eliminate potentially incorrect reliance on observed object lifetimes, so that we don’t uncover bugs at surprising times.\n\nWith Xcode 13, a new experimental build setting called \"Optimize Object Lifetimes\" is available for the Swift compiler.\n\nThis enables powerful lifetime shortening ARC optimizations.\n\nWith this build setting turned on, you may see objects being deallocated immediately after last use much more consistently, bringing observed object lifetimes closer to their guaranteed minimum.\n\nThis may expose hidden object lifetime bugs, similar to the examples discussed.\n\nYou can follow the safe techniques discussed in this session to eliminate all such bugs.\n\nI hope you enjoyed this session.\n\nThanks for watching.\n\n♪",
    "segments": []
  },
  "codeExamples": [
    {
      "timestamp": "1:49",
      "title": "ARC Example",
      "language": "swift",
      "code": "class Traveler {\n    var name: String\n    var destination: String?\n}\n\nfunc test() {\n    let traveler1 = Traveler(name: \"Lily\")\n    let traveler2 = traveler1\n    traveler2.destination = \"Big Sur\"\n    print(\"Done traveling\")\n}"
    },
    {
      "timestamp": "6:37",
      "title": "Reference Cycle Example",
      "language": "swift",
      "code": "class Traveler {\n    var name: String\n    var account: Account?\n    func printSummary() {\n        if let account = account {\n            print(\"\\(name) has \\(account.points) points\")\n        }\n    }\n}\n\nclass Account {\n    var traveler: Traveler\n    var points: Int\n}\n\nfunc test() {\n    let traveler = Traveler(name: \"Lily\")\n    let account = Account(traveler: traveler, points: 1000)\n    traveler.account = account\n    traveler.printSummary()\n}"
    },
    {
      "timestamp": "9:05",
      "title": "Weak Reference Example",
      "language": "swift",
      "code": "class Traveler {\n    var name: String\n    var account: Account?\n    func printSummary() {\n        if let account = account {\n            print(\"\\(name) has \\(account.points) points\")\n        }\n    }\n}\n\nclass Account {\n    weak var traveler: Traveler?\n    var points: Int\n}\n\nfunc test() {\n    let traveler = Traveler(name: \"Lily\")\n    let account = Account(traveler: traveler, points: 1000)\n    traveler.account = account\n    traveler.printSummary()\n}"
    },
    {
      "timestamp": "10:05",
      "title": "Accessing an object via weak reference",
      "language": "swift",
      "code": "class Traveler {\n    var name: String\n    var account: Account?\n}\n\nclass Account {\n    weak var traveler: Traveler?\n    var points: Int\n    func printSummary() {\n        print(\"\\(traveler!.name) has \\(points) points\")\n    }\n}\n\nfunc test() {\n    let traveler = Traveler(name: \"Lily\")\n    let account = Account(traveler: traveler, points: 1000)\n    traveler.account = account\n    account.printSummary()\n}"
    },
    {
      "timestamp": "11:14",
      "title": "Accessing an object via optional binding of weak reference",
      "language": "swift",
      "code": "class Traveler {\n    var name: String\n    var account: Account?\n}\n\nclass Account {\n    weak var traveler: Traveler?\n    var points: Int\n    func printSummary() {\n         if let traveler = traveler {\n            print(\"\\(traveler.name) has \\(points) points\") \n         }\n    }\n}\n\nfunc test() {\n    let traveler = Traveler(name: \"Lily\")\n    let account = Account(traveler: traveler, points: 1000)\n    traveler.account = account\n    account.printSummary()\n}"
    },
    {
      "timestamp": "11:45",
      "title": "Safe techniques for handling weak references - withExtendedLifetime()",
      "language": "swift",
      "code": "func test() {\n    let traveler = Traveler(name: \"Lily\")\n    let account = Account(traveler: traveler, points: 1000)\n    traveler.account = account\n    withExtendedLifetime(traveler) {\n        account.printSummary()\n    }\n}\n\nfunc test() {\n    let traveler = Traveler(name: \"Lily\")\n    let account = Account(traveler: traveler, points: 1000)\n    traveler.account = account\n    account.printSummary()\n    withExtendedLifetime(traveler) {}\n}\n\nfunc test() {\n    let traveler = Traveler(name: \"Lily\")\n    let account = Account(traveler: traveler, points: 1000)\n    defer {withExtendedLifetime(traveler) {}}\n    traveler.account = account\n    account.printSummary()\n}"
    },
    {
      "timestamp": "12:55",
      "title": "Safe techniques for handling weak references - Redesign to access via strong reference",
      "language": "swift",
      "code": "class Traveler {\n    var name: String\n    var account: Account?\n    func printSummary() {\n        if let account = account {\n            print(\"\\(name) has \\(account.points) points\")\n        }\n    }\n}\n\nclass Account {\n    private weak var traveler: Traveler?\n    var points: Int\n}\n\nfunc test() {\n    let traveler = Traveler(name: \"Lily\")\n    let account = Account(traveler: traveler, points: 1000)\n    traveler.account = account\n    traveler.printSummary()\n}"
    },
    {
      "timestamp": "14:20",
      "title": "Safe techniques for handling weak references - Redesign to avoid weak/unowned reference",
      "language": "swift",
      "code": "class PersonalInfo {\n    var name: String\n}\n\nclass Traveler {\n    var info: PersonalInfo\n    var account: Account?\n}\n\nclass Account {\n    var info: PersonalInfo\n    var points: Int\n}"
    },
    {
      "timestamp": "15:23",
      "title": "Deinitializer Example",
      "language": "swift",
      "code": "class Traveler {\n  var name: String\n  var destination: String?\n  deinit {\n    print(\"\\(name) is deinitializing\")\n  }\n}\n\nfunc test() {\n    let traveler1 = Traveler(name: \"Lily\")\n    let traveler2 = traveler1\n    traveler2.destination = \"Big Sur\"\n    print(\"Done traveling\")\n}"
    },
    {
      "timestamp": "16:10",
      "title": "Sequencing deinitializer side-effects with external program effects",
      "language": "swift",
      "code": "class Traveler {\n    var name: String\n    var id: UInt\n    var destination: String?\n    var travelMetrics: TravelMetrics\n    // Update destination and record travelMetrics\n    func updateDestination(_ destination: String) {\n        self.destination = destination\n        travelMetrics.destinations.append(self.destination)\n    }\n    // Publish computed metrics\n    deinit {\n        travelMetrics.publish()\n    }\n}\n\nclass TravelMetrics {\n    let id: UInt\n    var destinations = [String]()\n    var category: String?\n    // Finds the most interested travel category based on recorded destinations\n    func computeTravelInterest()\n    // Publishes id, destinations.count and travel interest category\n    func publish()\n}\n\nfunc test() {\n    let traveler = Traveler(name: \"Lily\", id: 1)\n    let metrics = traveler.travelMetrics\n    ...\n    traveler.updateDestination(\"Big Sur\")\n    ...\n    traveler.updateDestination(\"Catalina\")\n    metrics.computeTravelInterest()\n}\n\nverifyGlobalTravelMetrics()"
    },
    {
      "timestamp": "17:56",
      "title": "Safe techniques for handing deinitalizer side effects - withExtendedLifetime()",
      "language": "swift",
      "code": "func test() {\n    let traveler = Traveler(name: \"Lily\", id: 1)\n    let metrics = traveler.travelMetrics\n    ...\n    traveler.updateDestination(\"Big Sur\")\n    ...\n    traveler.updateDestination(\"Catalina\")\n    withExtendedLifetime(traveler) {\n        metrics.computeTravelInterest()\n    }\n}"
    },
    {
      "timestamp": "18:31",
      "title": "Safe techniques for handing deinitalizer side effects - Redesign to limit visibility of internal class details",
      "language": "swift",
      "code": "class Traveler {\n    ...\n    private var travelMetrics: TravelMetrics\n    deinit {\n        travelMetrics.computeTravelInterest()\n        travelMetrics.publish()\n    }\n}\n\nfunc test() {\n    let traveler = Traveler(name: \"Lily\", id: 1)\n    ...\n    traveler.updateDestination(\"Big Sur\")\n    ...\n    traveler.updateDestination(\"Catalina\")\n}"
    },
    {
      "timestamp": "19:08",
      "title": "Safe techniques for handling deinitalizer side effects - Redesign to avoid deinitializer side-effects",
      "language": "swift",
      "code": "class Traveler {\n    ...\n    private var travelMetrics: TravelMetrics\n     \n    func publishAllMetrics() {\n        travelMetrics.computeTravelInterest()\n        travelMetrics.publish()\n    }\n\n    deinit {\n\t\t\t\tassert(travelMetrics.published)\n    }\n}\n\nclass TravelMetrics {\n    ...\n    var published: Bool\n    ...\n}\n\nfunc test() {\n    let traveler = Traveler(name: \"Lily\", id: 1)\n    defer { traveler.publishAllMetrics() }\n    ...\n    traveler.updateDestination(\"Big Sur\")\n    ...\n    traveler.updateDestination(\"Catalina\")\n}"
    }
  ],
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2021/10216/4/884C234F-2424-47DF-A4CF-A9010D869C66/downloads/wwdc2021-10216_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2021/10216/4/884C234F-2424-47DF-A4CF-A9010D869C66/downloads/wwdc2021-10216_sd.mp4?dl=1"
  },
  "extractedAt": "2025-07-18T10:49:20.628Z"
}