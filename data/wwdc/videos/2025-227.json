{
  "id": "227",
  "year": "2025",
  "url": "https://developer.apple.com/videos/play/wwdc2025/227/",
  "title": "Finish tasks in the background",
  "speakers": [],
  "duration": "",
  "topics": [
    "System Services"
  ],
  "hasTranscript": true,
  "hasCode": true,
  "transcript": {
    "fullText": "Hey, I’m Ryan, a software engineer here at Apple. Today, I’d like to chat about how your app can embrace background runtime.\n\nThe App Store is home to millions of apps, and each one brings something unique to the table. Your app shines brightest when it's front and center. With every pixel at your disposal, you’re able to foster memorable experiences.\n\nAnd people expect this - fast, useful, well-crafted apps from developers like yourself.\n\nBut what happens when the app transitions to the background? In this session, I’ll explore background runtime, building a toolkit that fits your app, one that’s efficient and well-behaved. It's not just about staying alive. It’s about being useful, doing things like prefetching, syncing, and uploading, setting your app up for success the next time it launches. Used well, background runtime makes your app feel fast, seamless, and maybe even a little magical.\n\nI’ll start with a quick overview of what foreground and background actually mean and share some principles about how the system decides when and how frequently apps run in the background.\n\nThen I’ll cover many of the existing means to do so, including a new API for continuing tasks that were started in the foreground.\n\nEvery foregrounded app follows the same rhythm.\n\nThe app itself and everything it needs frameworks, assets, and more are loaded into memory. It’s in this state where your app’s interface is the focus on the device, and your app is defined as foregrounded.\n\nWhen someone leaves your app, but the process stays alive, it enters the background. By default, backgrounded apps are suspended. They don't get CPU time. This protects battery life, preserves privacy, and frees up resources for apps in the foreground.\n\nIn some cases, your app can request background time to finish up in-flight work before being suspended. When someone returns to your app through the app switcher, it’s resumed by the system as it moves to the foreground.\n\nBefore using background runtime, it’ll help to understand how the system prioritizes and manages resources, and what you can do in your app to build the best experience.\n\nThe system’s main goals are straightforward: protect battery life and optimize performance, while preserving a fluid and responsive experience.\n\nThat means background execution isn’t guaranteed. Instead, it’s opportunistic, often discretionary, and tightly managed. Successful workloads understand this context and are designed to work with the system, not against it.\n\nThe most fundamental constraint is energy.\n\nEvery operation, CPU cycles, GPU rendering, network requests, even Neural Engine usage has an associated battery cost. Battery life is a finite resource. And to preserve it, the system coalesces work when the devices wake, cutting down on unnecessary background activity throughout the day. Since background runtime is limited, think about the things your app should do in the background as discrete, tailored tasks. Each task does one thing efficiently, maintaining awareness of the system's priorities and constraints. This background work is reflected in Battery Settings, where people learn which apps have significant impact on their battery life. iOS 26 brings incredible insights to your device's battery performance, with detailed app-specific breakdowns.\n\nYour best move here is to be efficient. If a task doesn't need to run immediately, consider deferring it until the device is charging. And if it does need to run, keep it lightweight and purpose-driven.\n\nIn addition to battery, the system is also responsible for managing other shared resources things like memory, CPU time, and network bandwidth. When someone is using their device, the foreground app is prioritized. If a backgrounded app consumes too much memory or CPU, it's not just inefficient. It’s also competing with the foreground experience. This is when the system may step in. Throttling, suspending, or even terminating processes that prove too costly.\n\nThe takeaway is simple. Keep your background work minimal. Avoid bloated work and prefer batch processing to minimize your memory footprint.\n\nEven when workloads are well-behaved, there’s no guarantee they’ll be allowed to run for long. The queue of background work is never empty, so the system may opt to prioritize other workloads. That said, we’re all working as a team here, with the system doing its job of maximizing the foreground experience.\n\nYour workloads must be resilient. Save incremental progress early and often. Respond to expiration signals promptly and trust the system will soon return to your workload. It appreciates cooperative processes, using these behaviors to influence future scheduling. But at the end of the day, the person using the device has the last say. They influence scheduling by toggling settings like Low Power Mode, Background App Refresh, and Low Data Mode. The system provides transparency, empowering folks to make these decisions on their own. For example, if your app drains too much battery in the background, they may take action, and not necessarily in your favor.\n\nTherefore, background work should be courteous, stay lightweight and honor preferences while making sure your impact is proportional to the value you’re delivering.\n\nNow even when every process in the system fully embraces these principles, they’re still running in a complex and highly dynamic environment.\n\nThings like network availability, CPU load, device activity, thermal state, and battery level are all used as context to inform scheduling decisions.\n\nFortunately, the system accounts for these challenging conditions, forging the best experience at all times. This means that even well designed tasks may be postponed if the conditions aren’t quite right, optimizing for the bigger picture. It's crucial to maintain adaptability. Keep your work atomic and lightweight while clearly advertising your requirements. Designing workloads to pick up where they left off allows for incremental progress as runtime opportunities arise. The more you understand and adapt to system conditions and priorities, the more successful your workloads will be.\n\nEfficient, Minimal, Resilient, Courteous, and Adaptive. These are the keys to building background work that fits seamlessly into the platform. And it may help to ask yourself a few key questions during development.\n\nWho initiated the task? Was the work explicitly kicked off or is it something discretionary that could run at a later time? How long will the work take? Try to categorize your tasks into short, medium, and long durations. Is this work critical to app state and freshness? Background downloads enhance the feeling of liveliness to your app, but telemetry uploads have no immediate benefit to the device owner. And finally, does the work require consent or input? Background runtime isn’t appropriate for these types of workloads, so I’d recommend taking a different approach if that’s the case.\n\nWith this foundation in place, let’s explore how you can effectively design your tasks. iOS provides a number of different APIs that let you request background runtime, and each API assumes a distinct type or profile depending on the support of work. This enables the system to adjust your app’s runtime to the constraints and conditions I talked about earlier. For example, folks expect their most frequently used apps to always have the latest and greatest content. It makes sense for the system to understand app usage patterns, optimizing background tasks and support.\n\nThis is the case for the first API, BGAppRefreshTask.\n\nApps can use this to silently fetch content from servers moments before use while fully embracing the idea of courtesy. The system aligns these tasks with app usage history.\n\nFrequently used apps  have an increased chance of being scheduled, guaranteeing fresh content on each launch.\n\nTo create an app refresh task in SwiftUI, add the BackgroundTask modifier to a scene. When the system wakes the app in the background, it will invoke this closure, suspending the app when the closure returns.\n\nWhile refresh tasks cover fetch based use cases, you may also want to maintain remote documents that are updated infrequently or irregularly.\n\nBackground Push Notifications provide an elegant solution. When your server sends a notification about new content, the system will wake your app at an opportune time to fetch it. Note this is different from the app refresh case. Here an update is pushed to the device rather than it opportunistically fetching data.\n\nBecause Background Push Notifications are used to indicate new remote content, they are always considered discretionary.\n\nThey’re also sent at a low priority and coalesced to minimize overhead and power cost.\n\nAnd when someone removes your app from the app switcher, the system respects their intent. The notifications are not delivered to your app until it’s launched again.\n\nSometimes, though, you may want your app to perform other types of work. Maybe you’d like to run an ML model on generated data, or even simply handle database maintenance.\n\nThe BGProcessingTask API enables you to do just that.\n\nRegistering for this task is straightforward. All it takes is a task identifier, callback queue, and a closure that's invoked at runtime.\n\nYou must register BackgroundTasks immediately during launch. This way, the system is promptly made aware of your task if it's launched in the background, invoking its handler immediately. Processing tasks also support additional configurations in pursuit of the principles I covered earlier. For example, if the work isn’t particularly sensitive to latency, a great task may elect to only run when the device is on charger and connected to network. This minimizes battery impact, reducing your app’s footprint and battery settings.\n\nSo far, I’ve covered APIs that let your app get runtime for tasks that begin in the background. But sometimes you may just want a little bit more time to continue running while transitioning to the background.\n\nThe begin and end background task APIs allow your app to finish work that may be irrecoverable should it be interrupted and left incomplete.\n\nTake even a simple state save, for example. Depending on the work, premature termination may lead to a poor experience.\n\nWrapping your code in these API calls informs the system that your app is handling crucial work that should not be interrupted. This API is a great fit when you’re cleaning up file handles or closing database connections.\n\nThe landscape of background support on iOS is vast, designed to handle a wide variety of tasks, including those kicked off by the user.\n\nEnsuring these user-initiated operations complete reliably is essential for a great experience. In an iPadOS and iOS 26, the BG continued processing task provides your app a way to support these exact features. This task allows you to continue work even after the app is backgrounded, with a system providing UI to communicate progress. Take the Journal app, for example. It uses the continued processing task to drive exports in the background with progress updates reflected to the initiator.\n\nAnd once it completes, the system briefly updates, then automatically dismisses the UI.\n\nPeople remain in control. They can consult the progress in the task and cancel the work at any time, enabling complex features.\n\nContinue processing tasks always start with an explicit action that someone performs in your app, like a button tap or gesture. Each task represents a clear and immediate goal that someone wants your app to perform, like exporting file, publishing social media content, or completing an update on a connected accessory. These tasks make measurable progress, and it's easy to understand what it means when the task is finished.\n\nPeople don't expect tasks to start automatically, even if they’ve set a preference in your app before. Avoid automatic workloads like maintenance, backups, or photo syncing. If a task starts without an explicit action, people may not understand the goal of the task or what its progress really means.\n\nDoing this unexpected work may lead to your app’s task being canceled.\n\nFor these needs, consider other APIs that are a better fit.\n\nWith these considerations in mind, adopting continued processing tasks is a breeze. To begin, add a task identifier to your Info.plist. You’ll use this to register a launch handler that manages state and progress reporting. Then, simply submit a task request when prompted.\n\nLet's start with the identifier. You’ll define this by adding a new value to the permitted background task scheduler identifiers array in your Info.plist, ensuring it is prefixed with your app's bundle ID.\n\nIn addition to static identifiers, continued processing tasks support a new wildcard notation with a dynamic suffix.\n\nWildcard identifiers always begin with your bundle ID, followed by some semantic context. The new component here is the dot asterisk, indicating a dynamic suffix will be appended to the identifier at registration and submission.\n\nA fully composed identifier, used to register and submit, takes the form like so.\n\nFor now, let’s stick with something more static.\n\nWith that selected, the scheduler needs to know what code to execute when your continued processing task is asked to run. Like before, a closure provided to the scheduler is invoked after a task request is submitted. But here's a crucial shift. Launch handlers don’t need to be registered before your app finishes launching. Instead, you’ll now dynamically register these handlers when the intent to use them is expressed.\n\nJust like in Journal, it’s imperative that you provide timely updates about workload progression. And if that progression is slower than expected, the system will prompt the initiator, asking if they want the work to continue.\n\nThe system relies on these progress updates to manage ongoing work. As a consequence, tasks that do not report any progress will be expired, allowing  the system to reclaim and redistribute the resources. Your app actively communicates these updates using the Progress Reporting Protocol. As it does, the system continuously monitors them, surfacing the progress in the UI.\n\nNow we still need to be mindful of the fact that the system may need to stop your task early if conditions change. To handle this, your task must provide an expiration handler that will be called when it's time to stop. Think of the handler as your chance to quickly flip a variable so that the task can stop gracefully and avoid doing extra work.\n\nCritically, when your task does complete its work, you must call setTaskCompleted. This tells the system you're finished.\n\nOK, I’ve covered how to manage progress updates, handle potential interruptions, and signal completion of a running task. Now, let’s put it together by building and submitting a valid, user-initiated task request.\n\nYou start by initializing a task request object. This needs three pieces of information an identifier matching one from your Info.plist, a localized title, and a localized subtitle. These are what the user sees in the system UI.\n\nNext, you’ll need to provide a submission strategy for the system to abide by. By default, if the system finds it cannot immediately run your continued processing task, it will add it to the back of the queue. You don’t need to specify anything extra for this.\n\nHowever, sometimes queuing isn’t quite the right approach. What if the task is only useful if it starts right now? Instead of letting it queue, you can tell the system to fail the submission if it cannot start immediately. This gives your app instant feedback, allowing you to handle the situation appropriately.\n\nOnce you’ve decided on your strategy and configured the request, you just submit it to the scheduler and let the system manage the workload. And that’s the core process when working with continued processing tasks. By providing the title and subtitle and considering the submission strategy, you integrate smoothly with the system while upholding the crucial principle of consent. This API offers even more capabilities than what meets the eye. In iPadOS and iOS 26, your continued processing tasks can also benefit from background GPU access on supported devices.\n\nTo take advantage of this, make sure you add the background GPU capability in your Xcode project settings.\n\nOnce that’s added, you can and should, dynamically query the scheduler’s supported resources property. This lets your app understand exactly what the current device supports at runtime so you can adapt your task requirements appropriately.\n\nThis check is important. The system enforces these requirements. Any requests for unavailable resources will be rejected upon submission, keeping the system and your task in a healthy, known state.\n\nFinally, remember the broader context of system priorities. iOS prioritizes the foreground experience, meaning your background task may receive a lower quality of service compared to when your app is active. However, the system is smart about this. When your app does return to the foreground, it will intelligently boost your task priority, helping ensure things remain smooth and responsive.\n\nThese new APIs enable the most powerful and seamless background execution capabilities yet, adding the vital BGContinuedProcessingTask to your toolkit. With a complete understanding of these tasks and how they fit into the broader system, you're ready to start adopting them. We’re excited to see how you’ll use these tools to create smarter, more efficient background experiences. Thank you for watching!",
    "segments": []
  },
  "codeExamples": [
    {
      "timestamp": "8:27",
      "title": "Register an app refresh task",
      "language": "swift",
      "code": "import BackgroundTasks\nimport SwiftUI\n\n@main\nstruct ColorFeed: App {\n    var body: some Scene {\n        WindowGroup {\n            // ...\n        }\n        .backgroundTask(.appRefresh(\"com.colorfeed.wwdc25.appRefresh\")) {\n            await self.handleAppRefreshTask()\n        }\n    }\n}"
    },
    {
      "timestamp": "9:45",
      "title": "Register a processing task",
      "language": "swift",
      "code": "import BackgroundTasks\nimport UIKit\n\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n    func application(\n        _ application: UIApplication,\n        didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?\n    ) -> Bool {\n        BGTaskScheduler.shared.register(\n            forTaskWithIdentifier: \"com.example.apple-samplecode.ColorFeed.db_cleaning\",\n            using: nil\n        ) { task in\n            self.handleAppRefresh(task: task as! BGProcessingTask)\n        }\n    }\n\n    func submitProcessingTaskRequest() {\n        let request = BGProcessingTaskRequest(\n            identifier: \"com.example.apple-samplecode.ColorFeed.db_cleaning\"\n        )\n        request.requiresNetworkConnectivity = true\n        request.requiresExternalPower = true\n\n        BGTaskScheduler.shared.submit(request)! \n    }\n}"
    },
    {
      "timestamp": "10:51",
      "title": "Begin and end background task",
      "language": "swift",
      "code": "import UIKit\n\n@main\nclass AppDelegate: UIResponder, UIApplicationDelegate {\n    var backgroundTaskID: UIBackgroundTaskIdentifier = .invalid\n   \n    func saveState() { /*  ... */ }\n\n    func handlePersistence() {\n        let app = UIApplication.shared\n        guard backgroundTaskID != .invalid else { return }\n        backgroundTaskID = app.beginBackgroundTask(withName: \"Finish Export\") {\n            app.endBackgroundTask(self.backgroundTaskID)\n            self.backgroundTaskID = .invalid\n        }\n\n        self.saveState()\n\n        app.endBackgroundTask(backgroundTaskID)\n        backgroundTaskID = .invalid\n    }\n}"
    },
    {
      "timestamp": "14:00",
      "title": "Continued processing task registration",
      "language": "swift",
      "code": "import BackgroundTasks\n\nfunc handleDialogConfirmation() {\n    BGTaskScheduler.shared.register(\"com.colorfeed.wwdc25.userTask\") { task in\n        let task = task as! BGContinuedProcessingTask\n                                                                      \n        var shouldContinue = true\n        task.expirationHandler = {\n            shouldContinue = false\n        }\n\n        task.progress.totalUnitCount = 100\n        task.progress.completedUnitCount = 0\n\n        while shouldContinue {\n            // Do some work\n            task.progress.completedUnitCount += 1\n        }\n\n        task.setTaskCompleted(success: true)\n    }\n}"
    },
    {
      "timestamp": "15:47",
      "title": "Continued processing task submission",
      "language": "swift",
      "code": "import BackgroundTasks\n\nfunc submitContinuedProcessingTaskRequest() {\n    let request = BGContinuedProcessingTaskRequest(\n        identifier: \"com.colorfeed.wwdc25.userTask\",\n        title: \"A succinct title\",\n        subtitle: \"A useful and informative subtitle\"\n    )\n\n    request.strategy = .fail\n\n    BGTaskScheduler.shared.submit(request)!\n}"
    }
  ],
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "Background Tasks",
        "url": "https://developer.apple.com/documentation/BackgroundTasks"
      },
      {
        "title": "Performing long-running tasks on iOS and iPadOS",
        "url": "https://developer.apple.com/documentation/BackgroundTasks/performing-long-running-tasks-on-ios-and-ipados"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2025/227/4/b4d5d5a5-5c5a-4f37-a4ad-66fea0b6f25d/downloads/wwdc2025-227_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2025/227/4/b4d5d5a5-5c5a-4f37-a4ad-66fea0b6f25d/downloads/wwdc2025-227_sd.mp4?dl=1"
  },
  "extractedAt": "2025-07-18T11:00:50.894Z"
}