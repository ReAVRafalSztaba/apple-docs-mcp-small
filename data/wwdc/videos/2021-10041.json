{
  "id": "10041",
  "year": "2021",
  "url": "https://developer.apple.com/videos/play/wwdc2021/10041/",
  "title": "Extract document data using Vision",
  "speakers": [],
  "duration": "",
  "topics": [
    "Machine Learning & AI"
  ],
  "hasTranscript": true,
  "hasCode": true,
  "transcript": {
    "fullText": "Hello, and welcome to WWDC. My name is Frank Doepke, and I'm an Engineer on the Vision team.\n\nThe Vision framework has grown over the years, with its focus on image analysis. To get a better grasp, we can look at Vision's capabilities in terms of its usage focus. Sports. Tracking objects and the analysis of the human pose are just some of the requests that can help you to create a sports application.\n\nAccessibility. Visions request like OCR or image classification and object detection are helping visually-impaired users.\n\nPeople. Vision provides a number of face and body-related requests that your app can use. You can find out more about this in the \"Detect people, faces, and poses using Vision\" session.\n\nHealth. From barcode scanning and OCR to analysis of the human pose, Vision provides building blocks to create a smart Health application.\n\nComputational Photography. Features like portrait mode rely on face detection and segmentation.\n\nSecurity. Requests like face and human detection are helpful for applications like motion detection in security cameras.\n\nAnd documents. This is what we want to focus on in this session.\n\nVision offers a number of requests that help you with the analysis of documents: barcode detection, text recognition, or commonly known as OCR, contour detection, rectangle detection, and new for this year, document segmentation detection.\n\nHere's our agenda. First, we'll talk about barcode detection. Then, we'll talk about text recognition. And last, we'll talk about document detection.\n\nLet's look at barcode detection. This year, we are introducing a new revision of the barcode detection request.\n\nVNDetectBarcodesRequestRevision2 offers support for new symbologies. Codabar, GS1Databar, including Expanded and Limited, MicroPDF, and MicroQR, where the latter is particularly helpful if you want to make a QR code for a URL and need to place it on a small label or package, as it uses a lot less space.\n\nWe changed the behavior for this new revision to be in line with the rest of Vision in respect to how the resulting bounding boxes are reported in relation to the region of interest that a client has specified.\n\nLet's look at that change in detail. Here, we have a document with a QR code. When we do not specify a Region of Interest, also known as ROI, the bounding box gets reported in relation to the full image. Now, let's specify an ROI, like we want to only focus on the center part of what the camera sees. Revision 2 now reports the bounding box in relation to the ROI, just like other Vision requests.\n\nUnfortunately, Revision 1 always reports in relation to the full image. But we don't want to change that behavior, as it would potentially break existing clients. And just as a reminder, when you compile your application against the latest SDK and do not specify a specific revision, you will always get the latest revision on your request. But for applications that specify Revision 1 or do not re-compile against a new SDK, they will still get the old Revision 1 behavior.\n\nLet me highlight a few interesting aspects of the barcode detection request in Vision. Vision supports 1D and 2D barcodes.\n\nBut what makes it really interesting is that within one image, it can detect multiple codes, as well as multiple symbologies, at once.\n\nThat means you don't have to scan again and again to get multiple codes. This is a huge advantage over most handheld scanners. Keep in mind that if you scan for multiple symbologies, it'll take longer the more symbologies you have specified. So you want to setup the request with only the symbologies that are relevant to your use case.\n\nWith the expansion of the new symbologies for barcode scanning, Vision can play a particularly helpful role in the health sector. With an iPhone, you can analyze multiple codes at once, and thanks to its connectivity to the internet, pull up the information without needing a separate scanner.\n\nAnd thanks to the iPhone's strong low-light capabilities, you can scan codes, even in dark scenarios, without shooting off a laser or disturbing the patient while they are resting.\n\nNow, let's look at how Vision performs barcode detection.\n\n1D codes will get scanned as lines. That means you will likely get multiple detections for the same code. It is easy to de-duplicate them by looking at the payload, which is the real data that is included in the barcode.\n\n2D codes get scanned as a single unit. That means you get one bounding box back for the whole code. An example for a 2D code would be a QR code.\n\nEach barcode gets reported with its own observation. But as I mentioned before, 1D codes can return multiple observations, with the same content, but in different physical locations. The payload is the content of the barcode, that is, the data that is included in this machine-readable code. In particular for the payload of QR codes, you might want to use data detectors to analyze the encoded URL.\n\nNow, let's look at this in a little demo.\n\nAlright, here we have an Xcode playground, where you see that I have an image with all the barcodes in them. I use the VNDetectBarcodesRequest, and I set the Revision to 2. Now, as the symbologies, I just have codabar, and when we look at this, we see the codabar got highlighted in red.\n\nNow, I can change this to, let's say, QR.\n\nWhat happens now is that we run the request again, and we see that the QR code gets highlighted. But it's an array, so I can also specify other requests with it, let's say ean8. And when I do that, we'll now see that we have both, the ean8 and the QR code. But what if I want to get all of them? I simply pass in an empty array, and in that moment, all symbologies get read. And as you see, all highlighted right now with the code on the bottom. Let's go back to our slides.\n\nFrom barcodes, we are now moving on to look at text recognition. Vision introduced text recognition in 2019. It operates in two modes: Fast and Accurate. Since then, Vision has expanded its language support. Let's look at how text recognition works and where language plays a role. In the Fast path, we have a Latin-character recognizer. The Accurate path, on the other hand, uses a machine-learning-based recognizer that operates on words and lines.\n\nAfter the recognition is done, each path goes through a language correction stage. And, in the end, we get back the recognized text. The language selection affects the recognition stage. In the Fast path, it would mean that the different Latin character sets are supported, like the umlaut for German. In the Accurate path, a completely different model gets used when we have to recognize Chinese, as its structure is very different to Latin-based languages. That means if you need to read Chinese text, then it is important that Chinese is the primary language in the request. The language selection also influences language correction, as it picks the correct dictionary for its work.\n\nSo, what are the best practices when using languages in text recognition? Even though it might look like a fixed set of languages is supported, it is always better to query which languages are supported for a given request configuration using supportedRecognitionLanguages(). You can specify multiple languages, and, in that case, the order matters. When there is ambiguity, it gets resolved in the order of languages. In particular for the Accurate path, the first language decides which recognition model gets used. That means your use case dictates which languages you want to use in the request.\n\nLet's look at this in a little demo.\n\nSo, I have here now a revised version of our sample code, and you can see that I have an image with different languages of text in it. Now, I specified Revision 2, and I can see which languages are supported. We have English, French, and so on.\n\nNow, if I switch, for instance, back to Revision 1, we can see I only have English. And that is the same for the Fast as it is for the Accurate path. Now, let's go back to Revision 2.\n\nNotice that when I switch now, for instance, to German, I actually get the umlaut correctly in Gr√ºsse aus Cupertino.\n\nBut I don't have support in the Fast path for Chinese.\n\nIn the Accurate path, I can now pick Chinese.\n\nAnd now, we finally get the correct Chinese letters for \"Hello World.\" Let's go back to the slides.\n\nLast but not least, let's look at Document Detection.\n\nVision introduces a new request called VNDocumentSegmentationRequest. It's a machine-learning-based detector that we have trained on various types of documents, like sheets of paper, signs, notes, receipts, labels, et cetera.\n\nThe result of the request is a low resolution segmentation mask, where each pixel represents a confidence if that pixel is part of the detected document or not. In addition it provides the four corner points of the quadrilateral.\n\nOn devices with a Neural Engine, the request can run in realtime on a camera or video feed. The VNDocumentCamera in VisionKit is now using the request instead of the VNDetectRectanglesRequest on modern devices with a Neural Engine.\n\nSpeaking of the VNDetectRectanglesRequest, how do these two requests differ, as they both can be used to detect a document? The DetectDocumentsRequest is, as I mentioned, machine-learning-based and performs fastest on the Neural Engine. But it can also be used on the GPU or CPU, but it is not fast enough there for realtime performance.\n\nThe rectangle detector is a traditional computer vision algorithm that runs only on the CPU and can keep up with the realtime performance, as long as the CPU is not saturated with other tasks.\n\nThe document request is trained on a variety of documents, and they don't have to be all rectangles, which is one of its main strengths. The rectangle detector, on the other hand, works by finding edges and intersections that form a quadrilateral, which can be a challenge with obscured corners or folds in the document.\n\nThe documents requests provides a segmentation mask and the corner points, while the rectangle detector only provides corner points. And the document detector is trained to look for one document only. With the rectangle detector will return multiple rectangles. These rectangles can even be nested. Let's look at this a little bit more.\n\nAs I mentioned, the document detector finds one document, which we see here with the quadrilateral of the detected object. But the rectangle detector will deliver back multiple observations of all the rectangles it finds in the image, and I highlighted a few here. It's up to the app to decide which rectangle is the document. How about we try all this in a demo? All right, we wanted to create a little survey, how well we are doing at WWDC. Now, unfortunately, you are not with me, so I had to ask the camera team here to fill out the survey for you. So, I created a little app in which I can now scan our survey cards.\n\nAnd what do we get? QuickDraw for beginners felt outdated. Well, it is bit old by now.\n\nLet's go for the next one. Ah, Vision was entertaining and informative.\n\nAnd last but not least, Cobol, just what I needed. Somebody is in the wrong session here. Okay, now let's look how we did this in the code. So, I created again a little playground here because it's easier to build this stuff up for us. What you can already see is that I loaded up an image, and I used the CIImage, because I need to do some image manipulation on it. I created a requestHandler, and I used the new VNDetectDocument SegmentationRequest(). Once I perform the request, I get now the results back, and I created a little helper function that I used core image to use now as a perspective corrected image, and we get back just a cropped-out card in a perspective corrected form. So, that's easy. So, what do we have to do next? We need to detect the bar codes, detect the rectangles, and recognize the text.\n\nOnce we perform this request, we then have to scan the check boxes to see which ones were ticked. All right, I prepared this a little bit, so let's start with detecting the bar codes.\n\nAnd I'm using, as the symbologies, just the QR code. I loaded into the document title because I know that is-- the content of my QR code will be the title of what we get out of it. Next, we need to detect the rectangles. Again, we have a little piece of code rectangle for that.\n\nSo, I create two arrays. I want to get all the checkBoxImages, which is data needed for the analysis. And I get all the rectangles out. So, I used the VNDetectRectanglesRequest. Now, what I do here is I sort them in the vertical order so that I get the results in the correct order back.\n\nOK, now we need to recognize our text.\n\nThat is simple. We store all the resulting textBlocks, and we use the VNRecognizeTextRequest. So now, what we have to do is simply perform the request.\n\nAnd as you can see, I used the documentRequestHandler, which is the one that used the cropped-out image, and performed the requests on it. And if I go back up here, I can already see that I get my correct QR code, but something is not quite right with my rectangles. I don't get any rectangles. So, what do I have to do? Well, by default, the rectangles detector only looks for rectangles that are at least 20% of the image. So, we need to correct that. So, I go in and set the minimumSize to, let's say, something like 10%.\n\nAnd once we do that, we get a rectangle.\n\nOkay, well, that's only one. Well, the other thing with the rectangle detector is that I need to tell it how many it should return. By default, the rectangle detection will only return one, the most prominent rectangle. But I want to get all of them. I do this by setting the maximumObservations to 0. And once I have done that, I now get all of our checkboxes and the bar code, because that looks like a rectangle. Okay, so we are good. Now comes the last part, and I need to actually scan the checkboxes. So, for that, I actually prepared a little machine-learning demo.\n\nI have a model here that I trained earlier with Create ML. It's an image classifier, and all I did was I used some of these checkbox images, which were marked, and some of them are not marked, for my \"yes\" and \"no\" label. And I also gathered a few images that are neither of them. That's my NotIt.\n\nAgain, we can use this in our code.\n\nSo, what do we have? We create our request by loading the model and create our Create ML request. And then we iterate, over all the checkbox images, create an ImageRequestHandler from it, and perform our classification.\n\nNow, I can look at my top classification. If that is \"Yes,\" then I just find which text line lines up with the checkbox that I have, and what do we get, in the end? Vision was entertaining and informative. Let's go back to the slides.\n\nLet's recap on what we saw. Document analysis is a focus in the Vision API. Barcode detection in Vision is more versatile than a scanner, and we are introducing a new document segmentation detection. If you want to learn more about how to use OCR, please look at our session from WWDC 2019. The \"Vision and core image\" session from WWDC 2020 gives you additional insights in doing your own custom document analysis by preprocessing images and detecting contours. Thank you, and enjoy the rest of WWDC. [music]",
    "segments": []
  },
  "codeExamples": [
    {
      "timestamp": "6:18",
      "title": "Barcode Scan",
      "language": "swift",
      "code": "import Foundation\nimport Vision\n\nlet url = URL(fileReferenceLiteralResourceName: \"codeall_4.png\") as CFURL\n\nguard let imageSource = CGImageSourceCreateWithURL(url, nil),\n      let barcodeImage = CGImageSourceCreateImageAtIndex(imageSource, 0, nil) else {\n    fatalError(\"Unable to create barcode image.\")\n}\n\nlet imageRequestHandler = VNImageRequestHandler(cgImage: barcodeImage)\n\nlet detectBarcodesRequest = VNDetectBarcodesRequest()\ndetectBarcodesRequest.revision = VNDetectBarcodesRequestRevision2\ndetectBarcodesRequest.symbologies = [.codabar]\n\ntry imageRequestHandler.perform([detectBarcodesRequest])\n\nif let detectedBarcodes = detectBarcodesRequest.results {\n\n    drawBarcodes(detectedBarcodes, sourceImage: barcodeImage)\n    \n    detectedBarcodes.forEach {\n        print($0.payloadStringValue ?? \"\")\n    }\n}\n\n\n\n\npublic func createCGPathForTopLeftCCWQuadrilateral(_ topLeft: CGPoint,\n                                            _ bottomLeft: CGPoint,\n                                            _ bottomRight: CGPoint,\n                                            _ topRight: CGPoint,\n                                            _ transform: CGAffineTransform) -> CGPath\n{\n    let path = CGMutablePath()\n    path.move(to: topLeft, transform: transform)\n    path.addLine(to: bottomLeft, transform: transform)\n    path.addLine(to: bottomRight, transform: transform)\n    path.addLine(to: topRight, transform: transform)\n    path.addLine(to: topLeft, transform: transform)\n    path.closeSubpath()\n    return path\n}\n\n\npublic func drawBarcodes(_ observations: [VNBarcodeObservation], sourceImage: CGImage) -> CGImage? {\n    let size = CGSize(width: sourceImage.width, height: sourceImage.height)\n    let imageSpaceTransform = CGAffineTransform(scaleX:size.width, y:size.height)\n    let colorSpace = CGColorSpace.init(name: CGColorSpace.sRGB)\n    let cgContext = CGContext.init(data: nil, width: Int(size.width), height: Int(size.height), bitsPerComponent: 8, bytesPerRow: 8 * 4 * Int(size.width), space: colorSpace!, bitmapInfo: CGImageAlphaInfo.premultipliedLast.rawValue)!\n    cgContext.setStrokeColor(CGColor.init(srgbRed: 1.0,  green: 0.0,  blue: 0.0,  alpha: 0.7))\n    cgContext.setLineWidth(25.0)\n    cgContext.draw(sourceImage, in: CGRect(x: 0.0, y: 0.0, width: size.width, height: size.height))\n    \n    for currentObservation in observations {\n        let path = createCGPathForTopLeftCCWQuadrilateral(currentObservation.topLeft,\n                                                        currentObservation.bottomLeft,\n                                                        currentObservation.bottomRight,\n                                                        currentObservation.topRight,\n                                                        imageSpaceTransform)\n        cgContext.addPath(path)\n        cgContext.strokePath()\n    }\n    return cgContext.makeImage()\n}"
    },
    {
      "timestamp": "14:02",
      "title": "Survey Scan",
      "language": "swift",
      "code": "import Foundation\nimport CoreImage\nimport Vision\nimport CoreML\n\nguard var inputImage = CIImage(contentsOf: #fileLiteral(resourceName: \"IMG_0001.HEIC\"))\nelse { fatalError(\"image not found\") }\n\ninputImage\n\nlet requestHandler = VNImageRequestHandler(ciImage: inputImage)\nlet documentDetectionRequest = VNDetectDocumentSegmentationRequest()\ntry requestHandler.perform([documentDetectionRequest])\n\nguard let document = documentDetectionRequest.results?.first,\n      let documentImage = perspectiveCorrectedImage(from: inputImage, rectangleObservation: document) else {\n          fatalError(\"Unable to get document image.\")\n      }\n    \ndocumentImage\nlet documentRequestHandler = VNImageRequestHandler(ciImage: documentImage)\n\n/*\n TODO\n  Detect barcodes\n  Detect rectangles\n  Recognize text\n  Perform those requests\n  Scan checkboxes\n */\n\nvar documentTitle = \"Don't know yet\"\n\nlet barcodesDetection = VNDetectBarcodesRequest() { request, _ in\n    guard let result = request.results?.first as? VNBarcodeObservation,\n          let payload = result.payloadStringValue else { return }\n    documentTitle = \"\\(payload) was: \"\n}\nbarcodesDetection.symbologies = [.qr]\n\nvar checkBoxImages: [CIImage] = []\nvar rectangles: [VNRectangleObservation] = []\n\nlet rectanglesDetection = VNDetectRectanglesRequest { request, error in\n    rectangles = request.results as! [VNRectangleObservation]\n    // sort by vertical coordinates\n    rectangles.sort{$0.boundingBox.origin.y > $1.boundingBox.origin.y}\n    \n    for rectangle in rectangles {\n        guard let checkBoxImage = perspectiveCorrectedImage(from: documentImage, rectangleObservation: rectangle)\n        else { print(\"Could not extract document\"); return }\n        checkBoxImages.append(checkBoxImage)\n    }\n}\nrectanglesDetection.minimumSize = 0.1\nrectanglesDetection.maximumObservations = 0\n\nvar textBlocks: [VNRecognizedTextObservation] = []\n\nlet ocrRequest = VNRecognizeTextRequest { request, error in\n    textBlocks = request.results as! [VNRecognizedTextObservation]\n}\n\ndo {\n    try documentRequestHandler.perform([ocrRequest, rectanglesDetection, barcodesDetection])\n} catch {\n    print(error)\n}\n\n\nlet classificationRequest = createclassificationRequest()\n\nvar index = 0\nfor checkBoxImage in checkBoxImages {\n    let checkBoxRequestHandler = VNImageRequestHandler(ciImage: checkBoxImage)\n    do {\n        try checkBoxRequestHandler.perform([classificationRequest])\n        if let classifications = classificationRequest.results as? [VNClassificationObservation] {\n            if let topClassification = classifications.first\n            {\n                if topClassification.identifier == \"Yes\" && topClassification.confidence >= 0.9 {\n                    for currentText in textBlocks {\n                        if observationLinesUp(rectangles[index], with: currentText) {\n                            let foundTextObservation = currentText.topCandidates(1)\n                            documentTitle += foundTextObservation.first!.string + \" \"\n                        }\n                    }\n                }\n            }\n        }\n    } catch {\n        print(error)\n    }\n    index += 1\n}\n\nprint(documentTitle)\n\n\n\nextension CGPoint {\n    func scaled(to size: CGSize) -> CGPoint {\n        return CGPoint(x: self.x * size.width, y: self.y * size.height)\n    }\n}\nextension CGRect {\n    func scaled(to size: CGSize) -> CGRect {\n        return CGRect(\n            x: self.origin.x * size.width,\n            y: self.origin.y * size.height,\n            width: self.size.width * size.width,\n            height: self.size.height * size.height\n        )\n    }\n}\n\npublic func observationLinesUp(_ observation: VNRectangleObservation, with textObservation: VNRecognizedTextObservation ) -> Bool {\n    // calculate center\n    let midPoint =  CGPoint(x:textObservation.boundingBox.midX, y:observation.boundingBox.midY)\n    return textObservation.boundingBox.contains(midPoint)\n}\n\npublic func perspectiveCorrectedImage(from inputImage: CIImage, rectangleObservation: VNRectangleObservation ) -> CIImage? {\n    let imageSize = inputImage.extent.size\n    \n    // Verify detected rectangle is valid.\n    let boundingBox = rectangleObservation.boundingBox.scaled(to: imageSize)\n    guard inputImage.extent.contains(boundingBox)\n    else { print(\"invalid detected rectangle\"); return nil}\n    \n    // Rectify the detected image and reduce it to inverted grayscale for applying model.\n    let topLeft = rectangleObservation.topLeft.scaled(to: imageSize)\n    let topRight = rectangleObservation.topRight.scaled(to: imageSize)\n    let bottomLeft = rectangleObservation.bottomLeft.scaled(to: imageSize)\n    let bottomRight = rectangleObservation.bottomRight.scaled(to: imageSize)\n    let correctedImage = inputImage\n        .cropped(to: boundingBox)\n        .applyingFilter(\"CIPerspectiveCorrection\", parameters: [\n            \"inputTopLeft\": CIVector(cgPoint: topLeft),\n            \"inputTopRight\": CIVector(cgPoint: topRight),\n            \"inputBottomLeft\": CIVector(cgPoint: bottomLeft),\n            \"inputBottomRight\": CIVector(cgPoint: bottomRight)\n        ])\n    return correctedImage\n}\n\npublic func createclassificationRequest() -> VNCoreMLRequest\n{\n    let classificationRequest: VNCoreMLRequest = {\n        // Load the ML model through its generated class and create a Vision request for it.\n        do {\n            let coreMLModel = try MLModel(contentsOf: #fileLiteral(resourceName: \"CheckboxClassifier.mlmodelc\"))\n            let model = try VNCoreMLModel(for: coreMLModel)\n            \n            return VNCoreMLRequest(model: model)\n        } catch {\n            fatalError(\"can't load Vision ML model: \\(error)\")\n        }\n    }()\n    return classificationRequest\n}"
    }
  ],
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "Vision",
        "url": "https://developer.apple.com/documentation/Vision"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2021/10041/6/1CB4D0E9-CCA8-4C66-80DA-5887CF8F06C5/downloads/wwdc2021-10041_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2021/10041/6/1CB4D0E9-CCA8-4C66-80DA-5887CF8F06C5/downloads/wwdc2021-10041_sd.mp4?dl=1"
  },
  "relatedVideos": [
    {
      "id": "10324",
      "year": "2021",
      "title": "Thursday@WWDC21",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10324"
    },
    {
      "id": "10673",
      "year": "2020",
      "title": "Explore Computer Vision APIs",
      "url": "https://developer.apple.com/videos/play/wwdc2020/10673"
    },
    {
      "id": "234",
      "year": "2019",
      "title": "Text Recognition in Vision Framework",
      "url": "https://developer.apple.com/videos/play/wwdc2019/234"
    }
  ],
  "extractedAt": "2025-07-18T10:40:37.212Z"
}