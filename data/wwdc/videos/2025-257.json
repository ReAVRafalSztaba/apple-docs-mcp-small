{
  "id": "257",
  "year": "2025",
  "url": "https://developer.apple.com/videos/play/wwdc2025/257/",
  "title": "Optimize home electricity usage with EnergyKit",
  "speakers": [],
  "duration": "",
  "topics": [
    "System Services"
  ],
  "hasTranscript": true,
  "hasCode": true,
  "transcript": {
    "fullText": "Hello, I’m Dakshil and I’m excited to introduce to you EnergyKit.\n\nThe electricity powering your home comes from different sources throughout the day. These can include renewable energy, like solar and wind, or fossil fuels, like coal and natural gas. We started this journey by launching Grid Forecast, a feature in the Home app. It allows people in the contiguous U.S. to see times of day when electricity from relatively cleaner sources is available on the grid.\n\nWe also made the Energy category within the Home app more personal and actionable by integrating people’s home electricity usage directly into the experience. EnergyKit drives these features, and we are excited to make this framework available to you for residential applications.\n\nEnergyKit allows you to integrate insights about people’s local electricity grid into your app, helping them reduce or shift electricity usage and potentially save money. For example, if you are an electric vehicle manufacturer or a smart thermostat manufacturer, then EnergyKit can help you choose when to use electricity, prioritizing cleaner and potentially less expensive times. For instance, EnergyKit can help an electric vehicle manufacturer shift charging schedules to times when the grid is cleaner and potentially less expensive. In this talk, we will guide you through how to integrate EnergyKit into your app.\n\nYou will learn how to fetch electricity guidance, and adjust the charging schedules of electric vehicles managed by your app.\n\nPlus, we’ll show you how to create an amazing user experience using EnergyKit insights.\n\nLet’s get started with how to onboard people to EnergyKit.\n\nIntegrating EnergyKit into your app first requires people to opt in to a Clean Energy Charging experience, and make a selection for each location where they want to charge using cleaner electricity. In our sample app, we have a list of charging locations which represent where you charge an electric vehicle. We added a toggle to allow people to opt in to a Clean Energy Charging experience for their electric vehicle when charging at this location.\n\nAn EnergyVenue is a physical site where devices controlled by your app consume electricity from the grid, and where the owner has established a Home via the Home app or the EnergyKit onboarding flow. When they enable Clean Energy Charging, we retrieve a list of EnergyVenues near that location. If they select a venue, you should persist a mapping of the selected venue to the charging location until they opt out.\n\nIt is recommended that you store the unique identifier for the venue locally.\n\nFor each launch of your app, you should check that the selected venue exists. You can retrieve the selected venue by using the venue identifier that you saved earlier.\n\nNow that you have identified that the person wants to use Clean Energy Charging and has selected an EnergyVenue, the next step is to generate a Clean Energy Charging Schedule. To generate a Clean Energy Charging schedule, you require a forecast that will help guide the schedule.\n\nWe call this forecast Electricity Guidance. This guidance is generated by using a combination of the Home location, Grid information about the location, such as carbon emissions, or whether renewables are generating, and Utility account information, if available.\n\nThere are two types of guidance actions available: Reduce and Shift. The “Reduce” guidance action is used for devices, such as smart thermostats, which are designed to reduce electricity usage.\n\nThe “Shift” guidance action is used for devices, such as electric vehicles, which can shift their electricity usage from one time to another time, but use the same amount of electricity. Let's take a look at an example.\n\nThe illustration shows electricity guidance for an EnergyVenue.\n\nGuidance values are from 0 to 1 as represented by the Y axis, where lower values indicate periods where electricity is cleaner and potentially less expensive if rate plan information is available. In our example, a person has onboarded their utility account in the Home app, and is on a time of use rate plan where electricity is more expensive between the hours of 4 to 9pm.\n\nThe car is plugged in at around 6:30pm.\n\nYour charging preferences might know that they unplugged their car at around 9am or have a charging deadline of 9am.\n\nThis gives us a charging window from 6:30pm to 9am the next day.\n\nIf guidance is not applied to the charging schedule, the car may begin charging immediately at 6:30pm, which is not the most favorable from a cleanliness and cost perspective.\n\nInstead, we can select hours such that we can optimize the charging schedule to charge the vehicle during cleaner and potentially less expensive times.\n\nLet’s take a look at how we can fetch this Electricity Guidance at a selected EnergyVenue.\n\nWe start by adding a method called streamGuidance to our EnergyVenueManager.\n\nAs we get updates, we will store it in the guidance variable.\n\nWe need to create a query to retrieve the guidance for our use case.\n\nFor an electric vehicle, the suggested action type would be to shift electricity usage.\n\nWe are now ready to retrieve guidance for the EnergyVenue.\n\nElectricityGuidance has a sharedService helper that should be used to retrieve guidance. You get back an AsyncSequence, which is updated as EnergyKit receives updated Guidance.\n\nFor more information, check out the video \"Demystify concurrency in SwiftUI\".\n\nIf you do not need to continuously listen for updates, you can break out of the loop after the first fetch. You can call streamGuidance from a Task. If your app requires updates while in the background, you should call this from a Background Task handler. If your app has an interactive charging widget, you can also utilize that widget to keep guidance up to date while the app is not running. For more information, check out the video, “Finish tasks in the background”.\n\nYou can now iterate over the guidance values in order to determine better times to charge.\n\nEnergyKit Insights help provide electricity information in a format that is easy to present to people.\n\nYou can use the provided insights to inform people how much of the electricity used for charging their vehicle was during cleaner times, which can help reduce carbon emissions of their home electricity usage. The vehicle’s electricity usage is categorized by grid cleanliness and is reported in one of three categories: clean, reduce and avoid. You can also inform them about the electricity used during relatively less expensive times. The vehicle’s electricity usage is categorized by electricity rate plan when available and is reported in one of five categories: super off peak, off peak, partial peak, on peak, and critical peak.\n\nRate plan is also known as the rate tariff. The next question is: How do these insights work? Insights are influenced by a combination of factors. The algorithm you use to shift or reduce electricity based on the provided guidance determines whether the device under control consumes electricity during cleaner or less expensive times.\n\nThe state of the electricity grid where your device consumed electricity is determined by various factors such as electricity demand, renewable generators that are online, grid emissions, etc. If the person has onboarded their utility account in the Home app and they are on a time-of-use rate plan, the electricity usage can be attributed to the various time-of-use periods to get back the relative cost of using electricity.\n\nAnd the most important piece, how and when your device consumed electricity. This is determined by the behavior of your device, interaction by people, and how your app applied guidance to the device.\n\nFor an EV manufacturer, this would be the charging session behavior for the vehicle. In order to generate insights about your vehicle's charging with respect to the cleanliness and relative cost of electricity used, it is required that your app submits feedback to EnergyKit. We call this feedback LoadEvents. You should periodically create events as your vehicle charges and changes occur to its state of charge during the charging session. When a charging session begins, create an event which represents the state of the vehicle at the start of the session. As the vehicle charges, create events periodically. We recommend one event every 15 minutes when the vehicle is charging at a steady rate. If a significant event such as pausing the session, a change in the charging schedule due to a new guidance set being applied, or a rapid change in power consumption occurs, create events for the same. At the end of a session, close the session with an event that represents the final state of the vehicle. For EnergyKit to generate insights for the created events, you need to submit them to EnergyKit. You may submit events as they occur or in batches periodically, or even in a batch at the end of the charging session.\n\nWe recommend batch submitting events for performance. Do not submit events between charging sessions. Let’s take a look at how to create and submit these events. For a charging session, the most important pieces of information are: the state of charge of the battery, the power being consumed at a given instance, the cumulative energy consumed since the start of a charging session. When the vehicle starts charging, we consider that to be the start of the session.\n\nThis event represents the initial state of the vehicle at the start of the charging session. The guidance state indicates whether the session started because the charging schedule was following the electricity guidance represented by the guidance token.\n\nThis token is unique to the phone that retrieved the guidance which was in effect, and is to be used to create events on that phone. As charging progresses, the session is marked as active. Once the charging session has ended, the session is closed with an end event. This event represents the final state of the vehicle at the end of the charging session. In our sample app, we create LoadEvents and cache them until we are ready to submit as a batch. These batched events are submitted to the EnergyVenue at which the vehicle was charging. The events you submit are stored in accordance to Apple’s privacy policies with storage in Core Data on device and backed up with end-to-end encryption to CloudKit. This data is also shared with all people that already share the HomeKit Home associated to the EnergyVenue for which the events are submitted. We now finally have all the information needed to generate insights. To retrieve insights, we first create a query where we specify that we are interested in insights for cleanliness and relative cost if available. In our sample app, we are interested in displaying a summary of electricity consumption for a previous day. Once we have created the query, we can fetch insights for our vehicle at a venue where it was charging previously. We get back an AsyncStream and since we are interested in the insight for a particular day, we can filter the stream as per our requirement. The retrieved insight can now be used to create a summary. Your app is now integrated with EnergyKit. In this talk, we went over the building blocks of interacting with EnergyKit.\n\nFor onboarding, we looked at how people would interact with your app to select an EnergyVenue. We then went over how to use the selected EnergyVenue and to fetch electricity guidance, and use that to generate a charging schedule.\n\nAfter generating a charging schedule, as your vehicle charges, we went over the importance of submitting LoadEvents as feedback to EnergyKit to drive insight generation. Finally, we looked at how you can request insights based on the guidance retrieved and the feedback submitted by your app to build your user experience.\n\nYou can download the sample app that accompanies this talk and also access the documentation for EnergyKit at developer.apple.com.\n\nAt Apple, we are committed to protecting the environment and you can learn more about this at apple.com/2030 We are excited to see what amazing apps you build using EnergyKit.",
    "segments": []
  },
  "codeExamples": [
    {
      "timestamp": "3:13",
      "title": "Retrive an EnergyVenue",
      "language": "swift",
      "code": "// Retrieve an EnergyVenue\n\nimport EnergyKit\nimport Foundation\n\n@Observable final class EnergyVenueManager  {\n\n    let venue: EnergyVenue\n\n    init?(venueID: UUID) async {\n        guard let energyVenue = await EnergyVenue.venue(for: venueID) else {\n            return nil\n        }\n        venue = energyVenue\n    }\n}"
    },
    {
      "timestamp": "6:03",
      "title": "Fetch Electricity Guidance at a selected EnergyVenue",
      "language": "swift",
      "code": "// Fetch ElectricityGuidance\n\nimport EnergyKit\nimport Foundation\n\n@Observable final class EnergyVenueManager  {\n    // The current active guidance.\n    var guidance: ElectricityGuidance?\n\n    fileprivate func streamGuidance(\n        venueID: UUID,\n        update: (_ guidance: ElectricityGuidance) -> Void\n    ) async throws {\n        let query = ElectricityGuidance.Query(suggestedAction: .shift)\n        for try await currentGuidance in ElectricityGuidance.sharedService.guidance(\n            using: query,\n            at: venueID\n        ) {\n            update(currentGuidance)\n          \tbreak\n        }\n    }\n}"
    },
    {
      "timestamp": "7:00",
      "title": "Start monitoring Electricity Guidance",
      "language": "swift",
      "code": "// Fetch ElectricityGuidance\n\nimport EnergyKit\nimport Foundation\n\n@Observable final class EnergyVenueManager  {\n    // The task used to stream guidance.\n    private var streamGuidanceTask: Task<(), Error>?\n\n    ///Start streaming guidance and store the value in the observed property 'guidance'.\n    func startGuidanceMonitoring() {\n       streamGuidanceTask?.cancel()\n        streamGuidanceTask = Task.detached { [weak self] in\n            if let venueID = self?.venue.id {\n                try? await self?.streamGuidance(venueID: venueID) { guidance in\n                    self?.guidance = guidance\n                    if Task.isCancelled {\n                        return\n                    }\n                }\n            }\n        }\n    }\n}"
    },
    {
      "timestamp": "11:30",
      "title": "Update charging measurements",
      "language": "swift",
      "code": "// Update charging measurements\n\nimport EnergyKit\n\n// A controller that handles an electric vehicle\n@Observable class ElectricVehicleController {\n    fileprivate func chargingMeasurement() -> ElectricVehicleLoadEvent.ElectricalMeasurement {\n        let stateOfCharge = Int(configuration.state.stateOfCharge.rounded(.down))\n        let power = Measurement<UnitPower>(\n            value: configuration.properties.chargingPower * 1000000,\n            unit: .milliwatts\n        )\n        let energy = Measurement<UnitEnergy>(\n            value: configuration.state.cummulativeEnergy * 1000000,\n            unit: .EnergyKit.milliwattHours\n        )\n        return ElectricVehicleLoadEvent.ElectricalMeasurement(\n            stateOfCharge: stateOfCharge,\n            direction: .imported,\n            power: power,\n            energy: energy\n        )\n    }\n}"
    },
    {
      "timestamp": "11:50",
      "title": "Start a session",
      "language": "swift",
      "code": "// Start a session\n\nimport EnergyKit\n\n// A controller that handles an electric vehicle\n@Observable class ElectricVehicleController {\n    // The session\n    var session: ElectricVehicleLoadEvent.Session?\n\n    // The current guidance stored at the EV\n    var currentGuidance: ElectricityGuidance\n\n    // Whether the EV is following guidance\n    var isFollowingGuidance: Bool = true\n\n    fileprivate func beginSession() {\n        session = ElectricVehicleLoadEvent.Session(\n            id: UUID(),\n            state: .begin,\n            guidanceState: .init(\n                wasFollowingGuidance: isFollowingGuidance,\n                guidanceToken: currentGuidance.guidanceToken\n            )\n        )\n    }\n}"
    },
    {
      "timestamp": "12:25",
      "title": "Update a session",
      "language": "swift",
      "code": "// Update a session\n\nimport EnergyKit\n\n// A controller that handles an electric vehicle\n@Observable class ElectricVehicleController {\n    fileprivate func updateSession() {\n        if let session {\n            self.session = ElectricVehicleLoadEvent.Session(\n                id: session.id,\n                state: .active,\n                guidanceState: .init(\n                    wasFollowingGuidance:\n                    isFollowingGuidance,\n                    guidanceToken:\n                    currentGuidance.guidanceToken\n                )\n            )\n        }\n    }\n}"
    },
    {
      "timestamp": "12:31",
      "title": "End a session",
      "language": "swift",
      "code": "// End a session\n\nimport EnergyKit\n\n// A controller that handles an electric vehicle.\n@Observable class ElectricVehicleController {\n    fileprivate func endSession() {\n        if let session {\n            self.session = ElectricVehicleLoadEvent.Session(\n                id: session.id,\n                state: .end,\n                guidanceState: .init(\n                    wasFollowingGuidance:\n                    isFollowingGuidance,\n                    guidanceToken:\n                    currentGuidance.guidanceToken\n                )\n            )\n        }\n    }\n}"
    },
    {
      "timestamp": "12:43",
      "title": "Create a load event",
      "language": "swift",
      "code": "// Create a ElectricVehicleLoadEvent\n\n@Observable class ElectricVehicleController {\n    fileprivate func createLoadEvent(\n        sessionState: ElectricVehicleLoadEvent.Session.State\n    ) {\n        switch sessionState {\n        case .begin:\n            beginSession()\n        case .active:\n            updateSession()\n        case .end:\n            endSession()\n        @unknown default:\n            fatalError()\n        }\n        if let session {\n            let event = ElectricVehicleLoadEvent(\n                timestamp: configuration.state.timestamp,\n                measurement: chargingMeasurement(),\n                session: session,\n                deviceID: configuration.properties.vehicleID\n            )\n           events.append(event)\n        }\n    }\n}"
    },
    {
      "timestamp": "12:50",
      "title": "Submit events",
      "language": "swift",
      "code": "// Submit events\n\nimport EnergyKit\n\n// A controller that handles an electric vehicle\n@Observable class ElectricVehicleController {\n    // EnergyVenue\n    // The venue at which the EV uses energy\n    var currentVenue: EnergyVenue\n\n    // Electric EV Events\n    // The list of generated EV load events\n    var events = [ElectricVehicleLoadEvent]()\n    \n    func submitEvents() async throws {\n        try await currentVenue.submitEvents(events)\n    }\n}"
    },
    {
      "timestamp": "13:25",
      "title": "Create an insight query",
      "language": "swift",
      "code": "// Create an insight query\n\nimport EnergyKit\n\n@Observable final class EnergyVenueManager  {\n    func createInsightsQuery(on date: Date) -> ElectricityInsightQuery {\n        return ElectricityInsightQuery(\n            options: .cleanliness.union(.tariff),\n            range: self.dayInterval(date: date),\n            granularity: .daily,\n            flowDirection: .imported\n        )\n    }\n}"
    },
    {
      "timestamp": "13:43",
      "title": "Request insights",
      "language": "swift",
      "code": "// Request an insights\n\nimport EnergyKit\n\n@Observable final class EnergyVenueManager  {\n    func generateInsights(for vehicleIdentifier: String, on date: Date) async throws ->     ElectricityInsightRecord<Measurement<UnitEnergy>>? {\n        let query = createInsightsQuery(on: date)\n        return try await ElectricityInsightService.shared.energyInsights(\n            forDeviceID: vehicleIdentifier,\n            using: query,\n            atVenue: self.venue.id\n        ).first { record in\n            return record.range.start == query.range.start\n        }\n    }\n}"
    }
  ],
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "Optimizing home electricity usage",
        "url": "https://developer.apple.com/documentation/EnergyKit/optimizing-home-electricity-usage"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2025/257/5/af3f4fb6-a561-4208-8035-3f6a77252946/downloads/wwdc2025-257_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2025/257/5/af3f4fb6-a561-4208-8035-3f6a77252946/downloads/wwdc2025-257_sd.mp4?dl=1"
  },
  "relatedVideos": [
    {
      "id": "266",
      "year": "2025",
      "title": "Explore concurrency in SwiftUI",
      "url": "https://developer.apple.com/videos/play/wwdc2025/266"
    },
    {
      "id": "227",
      "year": "2025",
      "title": "Finish tasks in the background",
      "url": "https://developer.apple.com/videos/play/wwdc2025/227"
    }
  ],
  "extractedAt": "2025-07-18T11:00:40.187Z"
}