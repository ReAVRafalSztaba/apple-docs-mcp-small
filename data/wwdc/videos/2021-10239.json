{
  "id": "10239",
  "year": "2021",
  "url": "https://developer.apple.com/videos/play/wwdc2021/10239/",
  "title": "Reduce network delays for your app",
  "speakers": [],
  "duration": "",
  "topics": [
    "System Services"
  ],
  "hasTranscript": true,
  "hasCode": true,
  "transcript": {
    "fullText": "♪ Bass music playing ♪  ♪ Stuart Cheshire: Welcome to \"Reduce network delays for your app\".\n\nMy name is Stuart Cheshire.\n\nI'm going to talk about factors that contribute to making network apps feel slow today and then I'll hand over to my colleague Vidhi Goel to tell you about the techniques and APIs you can use to make your network app more responsive.\n\nLet's start by talking about something you may have already seen in the WWDC beta of iOS.\n\nIf you look in Developer settings, you will see a new item in the Networking section called Responsiveness.\n\nWhile upload throughput, download throughput, and idle ping time are all interesting, the main factor that affects the responsiveness of your network app is the network's responsiveness under working conditions, not idle conditions.\n\nThe typical internet speed test idle ping time measurement tells you how well your internet connection works when you're not using it.\n\nWhat matters is how well your internet connection works when you are using it.\n\nTap on Test.\n\nIt will warn you that it will generate network traffic, it will measure your network for a few seconds, and then it will tell you how well your network is performing under working conditions.\n\nThe tool reports network responsiveness in round trips per minute, or RPM, instead of milliseconds.\n\nWe created this new RPM metric because milliseconds are a fairly abstract concept to a lot of people.\n\nPeople are also more familiar with metrics where higher is better.\n\nThe RPM metric produces numbers in the range from a few hundred RPM to a few thousand RPM, just like the RPM of your car engine.\n\nThere's also a command-line version of this test tool on macOS called NetworkQuality.\n\nYou might think that your home or work network has a great ping time, but that's when it's idle.\n\nRun this network quality test for yourself -- on your iPhone or Mac -- and you might find that when your network is being used, its responsiveness becomes a lot worse.\n\nAnd I do mean a lot worse.\n\nYour network might have an idle round-trip time of 20 milliseconds, which sounds pretty good, but you might find that under working conditions the round-trip time goes up to 600 milliseconds or more.\n\nThat's 30 times worse.\n\nNetwork responsiveness under working conditions is what matters for your app's user experience.\n\nWe all see this problem all the time, but especially with audio and video freezes, and dropouts during video conferencing.\n\nHigh network delays hurt all apps, but we've got used to that, so we notice it more when it affects video conferencing.\n\nWhen we have problems with our video conferences, we think we'll fix it by upgrading our internet connection.\n\nPeople have gone from a few megabits per second to gigabit and above, yet the problems still happen.\n\nA few megabits per second should be plenty for video conferencing, so why do we still have these problems? When buffers in the network are excessively large, when they fill up, they don't improve throughput, but they do add delay.\n\nWe normally think of the internet operating like this, with packets flowing speedily through the network.\n\nBut if we look inside the cloud, we'll see that it really works more like this.\n\nThe packet you see coming out of the network is not the one that you saw go in.\n\nPackets spend a lot of time sitting in excessively large buffers in the network.\n\nThis phenomenon of excessively large buffers is called bufferbloat, and until now it hasn't been widely measured, despite the effect it has on everyday network use.\n\nThe good news is that there are modern queue management algorithms, like CoDel -- the Controlled Delay queueing algorithm -- that eliminate bufferbloat.\n\nWhen the network keeps queues short, the time a packet spends waiting in the network is dramatically reduced.\n\nIt's possible to get high throughput and low delay at the same time.\n\nIt's not an either/or choice. It's not a zero-sum game.\n\nWe're working with the industry to deploy smarter queue management algorithms and improve network responsiveness under working conditions.\n\nBut for now, if you want to give a great user experience, you will want to make your apps cope with the internet as it is today.\n\nBufferbloat is a large component of the network delays your application will experience, but it's not the only source of delay.\n\nThere's software and hardware processing time.\n\nAs CPUs get ever faster, this processing time continues to shrink.\n\nThere's the actual data transmission time.\n\nAs data rates increase from kilobits to megabits to gigabits per second, transmission time continues to shrink.\n\nThen there's the time delay due to buffering in the network.\n\nAs I said, we're working with the industry on reducing these delays.\n\nBut there's always going to be the speed-of-light signal propagation delay.\n\nBack in the 1990s, the Stanford-to-MIT ping time, round-trip, coast-to-coast, across the United States, was already under 100 milliseconds.\n\nThat's pretty close to the speed-of-light limit already, so it's not going to get much better.\n\nWe're working on reducing the other three delays, but the speed-of-light delay will never go away, so this is why it’s important to design your apps taking network round-trip times into account.\n\nWhen we're talking about taking network round-trip times into account, what kind of apps are we talking about? Everyone knows that video conferencing is severely affected by high network delays.\n\nEveryone knows that online games are severely affected by high network delays.\n\nBut this affects all apps that use the network.\n\nI'm talking about getting weather forecasts, stock quotes, driving directions.\n\nThis affects web browsing.\n\nIt affects skipping ahead while watching a streaming video.\n\nThink about how many apps include some animated spinning delay indicator while the app is waiting for the network.\n\nMaybe your app.\n\nWe show that \"please wait\" indicator so that the user doesn't think the app has hung.\n\nIt's great that we put so much effort into giving the user something to look at while they wait for the slow network, but we should also put equal effort into reducing the time they spend waiting.\n\nIf you have an app where you ever show a delay indicator while waiting for data from the network, there are techniques you can use to reduce those wait times.\n\nThe time an app waits for network data is a function of how long it takes for one network round trip, and how many network round trips your app requires.\n\nAs an app developer, there's not a lot you can do to improve the underlying network round-trip time, but you can control how many round trips your app requires.\n\nLet me introduce my colleague, Vidhi Goel, to tell you how you can do that.\n\nVidhi Goel: Thanks, Stuart.\n\nHi, I am Vidhi, and today I'd like to talk to you about what you can do as a developer to reduce network delays in your app.\n\nApp responsiveness is inversely proportional to the number of network round trips.\n\nLet me show you how you can reduce these network round trips by adopting the modern networking protocols and make your apps super snappy.\n\nTo speed up your apps, adopt the modern networking protocols such as HTTP/3 & QUIC, TCP Fast Open, TLS 1.3, and Multipath TCP.\n\nWith these techniques, your app can potentially achieve multiple round-trip reductions in delivering data to your user.\n\nServer side support is required for all of these modern protocols, so check with your provider about their readiness.\n\nWe are happy to tell you that all of these technologies are available on iOS and macOS.\n\nLet's look into each of these technologies.\n\nFirst up, we have HTTP/3 and QUIC which are enabled by default in iOS 15 and macOS Monterey.\n\nQUIC is a transport protocol which can set up a connection much faster than TCP and TLS.\n\nBy reducing the head-of-line blocking, QUIC can significantly reduce delays in delivering data to your user.\n\nAnd here is the best part: if you are already using URLSession, you’re all set.\n\nIf you provide your own application layer using the Network framework APIs and want to take advantage of QUIC, simply create an NWConnection with QUIC parameters and set a TLS Application-Layer protocol or ALPN.\n\nPlease check out the \"Accelerate networking with HTTP/3 and QUIC\" session to learn more about how to use these technologies in your app.\n\nQUIC is useful in many scenarios.\n\nHowever, TCP may still be the right choice for some applications.\n\nWhen using TCP, you can eliminate an entire round trip by sending the app data along with the TCP handshake.\n\nTCP Fast Open is supported in Network framework and Sockets.\n\nTo use it with NWConnections, there are two options: the first option is to allow Fast Open on your connection and in this case, the app will provide the initial data to be sent out with the handshake.\n\nTo enable this, set the allowFastOpen parameter to true and create your connection.\n\nAnd then, before calling start, you would call send with your initial data.\n\nWhen using TCP Fast Open, you have to be careful that you only send idempotent requests with the handshake.\n\nIdempotent basically means that the data is safe to be replayed over the network.\n\nThere is another way to use TCP Fast Open that does not require your app to send its own initial data.\n\nIf your app is using TLS over TCP, you can choose to send the TLS handshake message as the initial data.\n\nTo enable this, go to your TCP-specific options and set enableFastOpen to true.\n\nThe recommended way to use TCP Fast Open is via the Network framework API, but if your app is built over Sockets, then you would call the connectx API with the respective flags to specify that you want to send idempotent data with the handshake.\n\nI mentioned idempotent a couple of times.\n\nLet me explain what it means and why it is important to send only idempotent requests with the handshake.\n\nAn idempotent and replay-safe operation is one that has no additional effect if it is performed more than once.\n\nFor example, when the user goes to the developer.apple.com web page, the HTTP GET request for this web page is sent out with the TCP handshake.\n\nIf the acknowledgment for this request was either delayed or dropped in the network, the device will resend the HTTP GET request which may get routed to a different server.\n\nAnd this time the acknowledgement arrives along with the HTTP response.\n\nAs the HTTP GET request does not have any additional effect when it is resent over the network, it is considered as an idempotent request.\n\nNow, let's say the user is trying to buy a new iPhone 12.\n\nThe HTTP request sent for this operation is not an idempotent request.\n\nIt could result in multiple transactions if the request goes to a different server each time when the data is replayed over the network.\n\nKeeping that in mind, let's talk about TLS 1.3.\n\nTLS 1.3 removes an entire round trip from the handshake as compared to TLS 1.2.\n\nIt also provides stronger security.\n\nIt is enabled by default since iOS 13.4 for URLSession and NWConnection.\n\nThe TLS 1.3 protocol defines early data support, which can save yet another round trip by sending idempotent requests along with the TLS handshake message.\n\nLet's switch gears and look at Multipath TCP which works a bit differently in reducing network delays.\n\nMultipath TCP allows a single TCP connection to continue as the device switches from one network to another.\n\nTo get the low latency feature of Multipath TCP, use the interactive mode API.\n\nIt will save all the round trips needed to establish a new connection, and the system will automatically choose the faster network path for your data packets.\n\nTo opt in from the client, set the multipathServiceType property to interactive on your URLSession configuration or on your NWParameters.\n\nTo give you an idea of how many round trips you can save with these modern technologies, let's start with a reference point.\n\nLet's say your app is currently running TLS 1.2 over TCP.\n\nIn this case it will take four round trips to get the first byte to your user.\n\nIf your server switches from TLS 1.2 to TLS 1.3, your connections will eliminate an entire round trip.\n\nIf you enable TCP Fast Open on your connection, you will save yet another round trip.\n\nIn iOS 15, HTTP/3 over QUIC provides a reduction to two round trips.\n\nThe QUIC protocol also defines early data support, which could enable a further reduction to one round trip.\n\nBased on our measurements at Apple, it is common for the users to see round-trip times that sometimes spike up as high as 600 milliseconds.\n\nLet's see what that means for your app.\n\nFour round trips at 600 milliseconds means your user is waiting almost two and a half seconds for the data to arrive.\n\nThat's a huge amount of time to wait and stare at the network spinner.\n\nBy adopting the modern networking protocols, you can reduce that time to first byte from 2.4 seconds to about half a second.\n\nThe user will definitively notice the difference when the data arrives a whole second and a half earlier.\n\nEvery developer who wants great network performance should pay attention to the number of round trips.\n\nThis is where the big wins are.\n\nAll the technologies that I've talked about help to reduce network delays in your app in real-world network conditions.\n\nIf you test your app on 5G, LTE, or fast Wi-Fi networks, your app responsiveness might seem fine to you.\n\nBut your users aren't always using your app in the best network conditions.\n\nTo simulate realistic networks, Network Link Conditioner tool is available for iOS from the Developer settings menu.\n\nFor macOS, you can download it from the Apple Developer website.\n\nThis tool is a reliable and repeatable way to test your app in different network conditions that your users may experience in their day-to-day life.\n\nIf you recall, Stuart mentioned earlier that you can't do much about reducing your network round-trip time.\n\nWell, that's not entirely true.\n\nLet me explain how you can reduce the network round-trip time when you correctly inform the system about your app traffic.\n\nMost apps have a mix of traffic that they send or receive.\n\nThere is a lot of data that is exchanged from the user's device when running a bunch of apps.\n\nIn real-world networks, like a home or office Wi-Fi, a number of devices share the same network.\n\nThese devices simultaneously send and receive significant amount of data while using a set of apps.\n\nTo avoid building up long queues in this shared network, it is crucial that you classify your app data appropriately so that the system can manage your traffic efficiently in order to maintain low network delays.\n\nAnd when you allow the system to maintain low network delays, it makes your app's foreground traffic faster and hence the data that matters most to the users is delivered quickly.\n\nLet me illustrate this with an example.\n\nMany apps prefetch content like graphics, audio files, et cetera, to make it available for later use.\n\nWhen the app is prefetching a substantial amount of data, this is what the network might look like.\n\nThe bottleneck queue can become full.\n\nIf at this point, the user initiates a network activity -- like viewing their profile page -- the response for this request will be queued at the end of the network queue, and it may take seconds before the profile is shown.\n\nThis would not be a good user experience.\n\nNow, let's look at what happens to the network when we mark these nonuser initiated prefetching tasks as background.\n\nMarking these non user initiated transfers as background will dramatically reduce the size of the network queue which will then become available for other foreground data.\n\nThus, any foreground data -- that is, the green packets -- will be delivered instantly for a quick, delightful experience.\n\nIn iOS 15 and macOS Monterey, the background service type has improved dramatically.\n\nWe have added new congestion control algorithms for background uploads and downloads.\n\nThese new algorithms not only reduce network delays significantly, for better user experience, but also ensure that the background transfers finish in nearly the same time as other traffic.\n\nLet's look at the networking APIs that you can adopt to take advantage of the background service type.\n\nWhen your app is in the foreground and performing non-user-initiated transfers, you would use the default URLSession and set the network service type to background on your URL requests.\n\nAgain, this allows the system to maintain low network delays.\n\nAnd for NWConnection, you would set the service class to background on your NWParameters.\n\nIf your app starts a long-running transfer, whether it is user initiated or not, you would create a background URLSession to continue running even when your app is suspended.\n\nFor time-insensitive tasks, you can set the isDiscretionary property to true.\n\nThis will allow the system to wait for optimal conditions to perform the transfer.\n\nWe've talked about how your app can help in keeping the network queues short.\n\nAnother source of delay can be on the sending device itself.\n\nHistorically, networking stacks have used very large send buffers.\n\nThis adds a lot of unnecessary delay, sometimes in the order of seconds, before the packet even enters the network.\n\nWe fixed this for URLSession and NWConnection way back in 2015.\n\nBut most servers on the internet run on Linux and use BSD Sockets.\n\nContact your server operators to ensure that they are using the TCP not sent low watermark socket option to reduce the delays at the source.\n\nFor your next steps, Adopt the modern networking protocols to eliminate multiple round trips.\n\nUse the background mode for prefetching assets, bulk transfers, and non urgent tasks.\n\nTest your app's performance in different network conditions.\n\nNetwork Link Conditioner is an excellent tool for doing that.\n\nKeeping network delays low improves the responsiveness of your app and enhances the overall user experience.\n\nThanks for watching and have a great WWDC! ♪",
    "segments": []
  },
  "codeExamples": [
    {
      "timestamp": "9:28",
      "title": "Fast open with TCP handshake",
      "language": "swift",
      "code": "/* Allow fast open on the connection parameters */\nparameters.allowFastOpen = true\n\nlet connection = NWConnection(to: endpoint, using: parameters)\n\n/* Call send with idempotent initial data before starting the connection */\nconnection.send(content: initialData, completion: .idempotent)\nconnection.start(queue: myQueue)"
    },
    {
      "timestamp": "11:01",
      "title": "Sockets with fast open",
      "language": "swift",
      "code": "connectx(fd, ..., CONNECT_DATA_IDEMPOTENT | CONNECT_RESUME_ON_READ_WRITE, ...); // delay SYN\nwrite(fd, ...); // SYN goes out with first data segment"
    },
    {
      "timestamp": "13:35",
      "title": "Save round-trips when switching networks with Multipath TCP",
      "language": "swift",
      "code": "// Multipath TCP\n// Save multiple round-trips when switching networks\n\n// On URLSessionConfiguration\nlet configuration = URLSessionConfiguration.default\nconfiguration.multipathServiceType = .interactive\n\n// On NWParameters\nlet parameters = NWParameters.tcp\nparameters.multipathServiceType = .interactive"
    },
    {
      "timestamp": "20:09",
      "title": "Background service type, App in foreground",
      "language": "swift",
      "code": "//Use default  URLSession, set background on URLRequest\nvar request = URLRequest(url: myurl)\nrequest.networkServiceType = .background\n\n//Set service class on parameters to apply to the  NWConnection\nlet parameters = NWParameters.tls\nparameters.serviceClass = .background"
    },
    {
      "timestamp": "20:10",
      "title": "Time insensitive tasks running in background",
      "language": "swift",
      "code": "//Configure background URL Session\n\nlazy var urlSession: URLSession = {\n    let configuration = URLSessionConfiguration.background(withIdentifier: \"MySession\")\n    configuration.isDiscretionary = true\n    return URLSession(configuration: configuration, delegate: self, delegateQueue: nil)\n}()"
    }
  ],
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2021/10239/4/8C138558-C5F3-4328-AA26-1F2D924B69F9/downloads/wwdc2021-10239_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2021/10239/4/8C138558-C5F3-4328-AA26-1F2D924B69F9/downloads/wwdc2021-10239_sd.mp4?dl=1"
  },
  "relatedVideos": [
    {
      "id": "10078",
      "year": "2022",
      "title": "Reduce networking delays for a more responsive app",
      "url": "https://developer.apple.com/videos/play/wwdc2022/10078"
    },
    {
      "id": "10094",
      "year": "2021",
      "title": "Accelerate networking with HTTP/3 and QUIC",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10094"
    },
    {
      "id": "10212",
      "year": "2021",
      "title": "Analyze HTTP traffic in Instruments",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10212"
    },
    {
      "id": "713",
      "year": "2019",
      "title": "Advances in Networking, Part 2",
      "url": "https://developer.apple.com/videos/play/wwdc2019/713"
    },
    {
      "id": "715",
      "year": "2018",
      "title": "Introducing Network.framework: A modern alternative to Sockets",
      "url": "https://developer.apple.com/videos/play/wwdc2018/715"
    },
    {
      "id": "719",
      "year": "2015",
      "title": "Your App and Next Generation Networks",
      "url": "https://developer.apple.com/videos/play/wwdc2015/719"
    }
  ],
  "extractedAt": "2025-07-18T11:02:52.437Z"
}