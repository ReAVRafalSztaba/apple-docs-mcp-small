{
  "id": "228",
  "year": "2025",
  "url": "https://developer.apple.com/videos/play/wwdc2025/228/",
  "title": "Supercharge device connectivity with Wi-Fi Aware",
  "speakers": [],
  "duration": "",
  "topics": [
    "Privacy & Security",
    "System Services"
  ],
  "hasTranscript": true,
  "hasCode": true,
  "transcript": {
    "fullText": "Hi, I’m Swetank. I'm an engineer on the Wi-Fi team. And today, I’ll be introducing the Wi-Fi Aware framework and show how you can use it to supercharge device-to-device interactions in your apps. First, I’ll set the foundation with a quick overview of Wi-Fi Aware. Next, I’ll dive into how you can integrate Wi-Fi Aware in your app.\n\nThen, I’ll cover how devices can securely discover and pair using the DeviceDiscoveryUI and AccessorySetupKit frameworks. After pairing, I’ll discuss how devices can set up Wi-Fi Aware connections using the Network framework. Once connected, I’ll look at how to monitor and optimize performance of Wi-Fi Aware connections. Finally, I’ll talk about some important next steps. Let’s start with an overview. Wi-Fi Aware enables direct device-to-device communication. Unlike traditional models that rely on routers or central servers, this is truly peer-to-peer.\n\nThese connections are dynamic and on-demand. Devices can find each other and form secure links at runtime. Perfect for local ephemeral experiences like file sharing or setting up an accessory.\n\nWi-Fi Aware operates alongside your regular Wi-Fi connection. That means devices stay connected to the internet and your local network while simultaneously using Wi-Fi Aware. And Wi-Fi Aware is a global standard maintained by the Wi-Fi Alliance. It’s cross-platform, interoperable, and can be adopted by any device manufacturer.\n\nWith Wi-Fi Aware, you can unlock new experiences and allow your apps to seamlessly discover and connect to nearby devices. Some examples include: media streaming, high-speed file transfer, accessory control, screen sharing, and if needed, you can do all of these simultaneously.\n\nIntroducing Wi-Fi Aware, a new framework that enables these experiences on iPhone and iPad. With the Wi-Fi Aware framework, your app can connect to other Apple devices, 3rd-party devices, and even accessories.\n\nWhen using Wi-Fi Aware, your connections are fully authenticated and encrypted at the Wi-Fi layer, can support high throughput and low latency, and co-exist with connections to other nearby devices at the same time.\n\nTo use Wi-Fi Aware, your app only needs to handle two high-level flows. The first flow is pairing a device.\n\nPairing is a one-time setup process that establishes trust and facilitates secure communication. The second flow is connecting paired devices. The system automatically secures the connection between devices, including key exchange and link encryption, so you don’t need to manage security protocols at all. And once paired, your app can securely reconnect whenever your devices are in close proximity and actively running your application.\n\nThis makes connecting back to the device seamless, fast, and secure.\n\nNow let’s see how you can set up your app to use Wi-Fi Aware. We will start with discussing a central concept for Wi-Fi Aware: services.\n\nServices are used for discovering devices and connecting to them. Think of services as specific functionality that your app either provides or consumes from other devices. Before we move on to declaring services in your app, let’s first understand a few key conventions for services.\n\nA service is identified by its name.\n\nService names must be unique, only consist of letters, numbers, and dashes, and not be longer than 15 characters.\n\nThere are two parts in a full service name.\n\nA unique name, followed by a protocol, which can either be tcp for services using TCP, or udp for services using any other protocol.\n\nTo prevent collisions between your apps service names and those used by other apps, you can register service names with IANA.\n\nNext, let's talk about service roles. Wi-Fi Aware allows for two possible roles for a given service. The first is Publisher, where your app hosts the service and acts as a server, listening for incoming connections from other devices.\n\nThe second is Subscriber, where your app uses the service and acts as the client, browsing for other devices to connect to.\n\nYour application can simultaneously operate as both publisher and subscriber if required for your use cases.\n\nYour application’s Info.plist specifies the services it intends to use. To do this, add the WiFiAwareServices key.\n\nThis is a dictionary where keys are service names and the corresponding value is the configuration for that service.\n\nIn this example, the app declares two services: file service and drone service.\n\nEach service has a dictionary of configuration properties.\n\nTo make a service Publishable, include the Publishable key. And to make it Subscribable, include the Subscribable key. In this case, file service is declared to be both Publishable and Subscribable. This is common when building app-to-app use cases.\n\nIn contrast, drone service is only subscribable, which is a common scenario when developing an app to talk to an accessory. Keep in mind that your app will only be able to publish or subscribe services that have been declared in the Info.plist. Now let's jump into some code and see how to access device capabilities and services that were declared in the Info.plist.\n\nBefore an application uses Wi-Fi Aware, it should first check if it is supported on the device.\n\nThis can be done by checking the supportedFeatures property of WACapabilities.\n\nPublishable services defined in the Info.plist are made available through WAPublishableService. In the example here, a static property, fileService, is defined for convenient access to the service later on. Subscribable services are accessed via WASubscribableService. For convenience, two static properties are defined to refer to fileService and droneService for later use.\n\nNow that you know how to add Wi-Fi Aware services to your app, let’s talk about how you can pair Wi-Fi Aware devices. Let’s start by discussing what the pairing flow looks like to a person using your app. As discussed previously, your app will pair Wi-Fi Aware devices prior to using them. Your app can trigger the pairing flow by calling APIs to show the system pairing UI. For the person using your app, pairing then follows a simple process.\n\nFirst, the person will be prompted to select a device from a list of nearby devices matching the parameters provided by your app.\n\nThen, the person will authorize the pairing by entering a PIN code provided by the other device.\n\nFinally, the system will complete pairing and let the person know when it succeeds. This will make the device available to your app. Once available, your app can make connections to that device on demand without needing to invoke the pairing flow again.\n\nThere are two system frameworks available for pairing devices: DeviceDiscoveryUI and AccessorySetupKit.\n\nDeviceDiscoveryUI is for making connections between apps and from an app to another device. It supports pairing with both Apple and third-party devices. AccessorySetupKit is for accessory makers to quickly onboard their accessory. It is the recommended framework for hardware accessory makers. Let’s talk about DeviceDiscoveryUI in more detail.\n\nA person using DeviceDiscoveryUI would start by pressing a button in your app's UI to add or select a device. On the publisher side, your app will call APIs to present the advertiser UI, as seen on the left. On another device, your app will call APIs to present the device picker UI, as seen on the right.\n\nThe browser UI will find nearby devices that match your Wi-Fi Aware service and present them for the person to choose. If the person selects an unpaired device, the system will automatically start the pairing flow.\n\nWhen pairing is needed, the incoming request and a PIN code is displayed on the publisher side and entered on the subscriber side.\n\nOnce the person confirms the PIN, the system pairs the devices. Upon completion, your app can make a connection to the other device.\n\nNow that we have seen the DeviceDiscoveryUI flow, let's look at some code.\n\nOn the listener side, your app will create a DevicePairingView by passing it the service to advertise.\n\nOn the browser side, your app will create a DevicePicker view by passing it the service to discover.\n\nWhen a discovered device is tapped, DeviceDiscoveryUI will render connectable network endpoint to your app. If required, DeviceDiscoveryUI will perform pairing before providing the network endpoint.\n\nIf you are an accessory maker, then AccessorySetupKit is the recommended method to pair with your app. If your accessory uses multiple transports, such as Bluetooth and Wi-Fi Aware, AccessorySetupKit will pair and set up both at the same time. Let's take a look at the pairing flow when using AccessorySetupKit with Wi-Fi Aware. A person using AccessorySetupKit would start by pressing a button in your app’s UI to add or select a device. Your app will fill out a discovery descriptor, specifying the service and filters to use for discovering devices. It then presents the AccessorySetupKit UI.\n\nAccessorySetupKit will find the nearby devices that match your service and discovery filter and present them in the UI. The person then selects the device they wish to set up.\n\nDuring the setup, the person enters a PIN to confirm the Wi-Fi Aware pairing. The PIN is displayed on the publisher and entered on the subscriber side.\n\nThe system then performs the pairing on behalf of the app.\n\nNow that we have seen the AccessorySetupKit flow, let’s look at the code. To pair Wi-Fi Aware devices with AccessorySetupKit, first create an ASDiscoveryDescriptor where you provide the service name and filters for device properties like model and vendor. Then present the AccessorySetupKit UI by creating an ASAccessorySession and calling showPicker on it. The system will take care of the discovery and pairing process. When the pairing is complete, a new ASAccessory will be returned, which represents the newly paired device. This contains a ASAccessoryWiFiAwarePairedDeviceID, which is the ID of the paired device. Your app can use this ID to look up the corresponding WAPairedDevice via the Wi-Fi Aware framework. The device can be used to initiate connection using the Network framework.\n\nFor more information on AccessorySetupKit, see the WWDC24 session “Meet AccessorySetupKit.” Now that I've covered how to pair devices, let's explore how your app can access the list of pair devices.\n\nWi-Fi Aware represents a pair device as a WAPairedDevice struct. You can get the list of devices using the allDevices API on WAPairedDevice.\n\nYou can access device properties like vendor and model name, which are learned during pairing.\n\nThe API can either win all devices or the ones that match a provided filter.\n\nFor example, to get all devices matching Example Inc as the vendor name, create a filter as shown here.\n\nThe list of paired devices for your app can change at any time. For instance, if a device is removed from the settings, your app can listen to these changes and update the UI and other state accordingly. The framework provides an easy way to do this by vending an async sequence through WaPairedDevice.allDevices.\n\nNote that APIs discussed here vend all paired devices available to your app, regardless of whether they are currently reachable or not. Having covered the first high level flow: pairing, let us now focus on the second flow, wherein your application will establish connections with paired devices. Before looking at the code, let’s first understand the high level flow for making a Wi-Fi Aware connection. Making a connection requires two devices. One device publishes the service and listens for connections from specific pair devices.\n\nThe other device subscribes to the service and browses for specific pair devices to connect to. To conserve power, listening and browsing should be limited to the duration necessary for your use case.\n\nOnce the browser discovers the service and device combination you provided, it will vend connectable network endpoints to the app. Next, your application will review the endpoints and establish connections with one or more of them.\n\nThe listener receives the connection request and forwards it to your app, completing the connection. At this point, data can be exchanged.\n\nLet’s explore how to use the Network framework in your application to establish a Wi-Fi Aware connection.\n\nBefore publishing or subscribing, your app needs to select the paired devices of interest.\n\nIn the example here, publisher creates a filter for devices with names starting with My Device.\n\nSimilarly, the subscribers filter is selecting devices with vendor names starting with Example Inc.\n\nThe necessary parameters are now available to start listener and browser instances using the Network framework.\n\nTo construct a NetworkListener, provide the service object and device filter created earlier.\n\nThe NetworkListener created in this manner will only accept connections for the specified service and pair devices that match the provided filter.\n\nIn addition to Wi-Fi Aware parameters, your application can configure network parameters and set up the state update handler.\n\nSimilarly, the NetworkBrowser is created using the service and device filter from earlier.\n\nThis browser will only discover paired devices that are advertising the service and match the filter.\n\nHaving successfully created a listener and a browser, your app can now establish a connection.\n\nTo begin accepting incoming connections on the listener, invoke the run operation on the listener object.\n\nStarting the listener makes your app discoverable to other devices.\n\nTo start subscribing for services on the browser, invoke the run operation on the browser object.\n\nStarting the browser discovers nearby devices offering the service.\n\nThe browser will return the list of discovered devices as network endpoints to your app.\n\nYour app will then review the discovered endpoints and decide if the endpoint of interest is present.\n\nUse the NetworkConnection API to start connections to the desired endpoint.\n\nWhen the connection is set up, the listener will receive a callback for the new connection, providing it to your app. Your application can now exchange data using Network framework APIs. To conserve wireless resources and power, stop the listener and browser once all the required connections have been made.\n\nI have covered all the steps required to make a Wi-Fi Aware connection. Next, let’s look at how to optimize connection performance for the best possible app experience. Optimizing performance requires balancing throughput, latency, and power consumption. In most cases, the system will apply reasonable defaults. However, if needed, your app can adjust certain connection parameters.\n\nOne is the Wi-Fi Aware Performance Mode, which influences the Wi-Fi Aware duty cycle.\n\nThe second is the Traffic Service Class, which sets the priority for packet transmission.\n\nThis defaults to best effort but can be set to interactive video or voice for lower latency.\n\nIf you have low-priority data, utilize the background service class to avoid interfering with other traffic.\n\nTypically, bulk performance mode is used with best effort or background service class. This combination results in lower power consumption, but higher latency.\n\nOn the other hand, real time is used with interactive voice or video service class. This provides lower latency, but more power consumption. Before you decide to use real time mode, consider carefully if it’s required for your use case, as it can negatively impact battery drain. In addition to offering tunable settings for connection performance, Wi-Fi Aware framework also provides an on-demand performance report for each network connection. The performance report includes metrics on signal strength, throughput, and latency. Use this feedback to tune your app’s performance. As Wi-Fi connection strength, environmental interference, and device capabilities can vary significantly in the real world, be sure to test how your app performs in busy Wi-Fi environments. Additionally, incorporate connection feedback from network protocols like TCP in your app.\n\nLet’s delve into some code and see how you can put the tunable parameters to use. As mentioned earlier, Wi-Fi Aware connections default to bulk performance mode coupled with the best effort service class. If profiling suggests your use case benefits from another configuration, you can set the parameters on the publisher and the connection instance on the subscriber to configure the performance mode and service class.\n\nIn this example, the publisher is set to use real-time performance mode and interactive video traffic service class.\n\nOn the subscriber side, the same configuration is needed on the NetworkConnection object that is created by your App.\n\nTo monitor your app’s Wi-Fi Aware connection, access the current path and read the performance report. Your app can then take actions based on this report and refine the overall user experience.\n\nNow that I’ve covered all the things you need to build an app using Wi-Fi Aware, I can't wait to see what you come up with. But before we go, let’s talk about some important next steps. If you are a hardware manufacturer, developing a Wi-Fi Aware capable device, refer to the accessory design guidelines to ensure interoperability with Apple devices. The guidelines document is available on the Apple Developer website. Following the guide allows your device to reliably discover and pair with Apple devices, maintain strong security, and maximize connection performance.\n\nThe guide is the best resource for building consistent, high quality Wi-Fi Aware experiences.\n\nWe encourage you to review the Wi-Fi Aware framework documentation for additional details. A sample app is also available which shows how to build an app using Wi-Fi Aware and how different performance configurations impact our behavior.\n\nFinally, if you are building a Wi-Fi Aware device, the interoperability guide can help you to create the best possible experience for your users.\n\nThanks for watching.",
    "segments": []
  },
  "codeExamples": [
    {
      "timestamp": "6:57",
      "title": "Access capabilities and services",
      "language": "swift",
      "code": "import WiFiAware\n\n// Check if Wi-Fi Aware is supported on your device\nguard WACapabilities.supportedFeatures.contains(.wifiAware) else { return }\n\n// Publishable service declared in Info.plist\nextension WAPublishableService {\n    public static var fileService: WAPublishableService {\n        allServices[\"_file-service._tcp\"]!\n    }\n}\n\n// Subscribable services declared in Info.plist\nextension WASubscribableService {\n    public static var fileService: WASubscribableService {\n        allServices[\"_file-service._tcp\"]!\n    }\n    public static var droneService: WASubscribableService {\n        allServices[\"_drone-service._udp\"]!\n    }\n}"
    },
    {
      "timestamp": "10:33",
      "title": "Pair with DeviceDiscoveryUI",
      "language": "swift",
      "code": "import DeviceDiscoveryUI\nimport WiFiAware\nimport SwiftUI\n\n// Listener (Publisher) Device\n// Invoke Listener UI\nDevicePairingView(.wifiAware(.connecting(to: .fileService, from: .selected([])))) {\n    // Provide a view to display to user before launching System UI\n} fallback: {\n    // Provide a view in case of error\n}\n\n// Browser (Subscriber) Device\n// Invoke Browser UI\nDevicePicker(.wifiAware(.connecting(to: .selected([]), from: .fileService))) { endpoint in\n    // Process the paired network endpoint\n} label: {\n    // Provide a view to display to user before launching System UI\n} fallback: {\n    // Provide a view in case of error\n}"
    },
    {
      "timestamp": "12:29",
      "title": "Pair with AccessorySetupKit",
      "language": "swift",
      "code": "import AccessorySetupKit\n\n// Configure ASDiscoveryDescriptor (Subscriber)\nlet descriptor = ASDiscoveryDescriptor()\ndescriptor.wifiAwareServiceName = \"_drone-service._udp\"\ndescriptor.wifiAwareModelNameMatch = .init(string: \"Example Model\")\ndescriptor.wifiAwareVendorNameMatch = .init(string: \"Example Inc\", compareOptions: .literal)\nlet item = ASPickerDisplayItem(name: \"My Drone\",\n                               productImage: UIImage(named: \"DroneProductImage\")!,\n                               descriptor: descriptor)\n\n// Create and activate session\nlet session = ASAccessorySession()\nsession.activate(on: sessionQueue) { event in\n    // Closure will execute when device is added with event: .accessoryAdded\n    // ASAccessoryWiFiAwarePairedDeviceID can be used to lookup a WAPairedDevice\n}\n// Present Picker UI\nsession.showPicker(for: [item]) { error in\n    // Handle error\n}"
    },
    {
      "timestamp": "13:51",
      "title": "Access paired devices",
      "language": "swift",
      "code": "import Foundation\nimport WiFiAware\n\n// WAPairedDevice\nvar device: WAPairedDevice // Get using WAPairedDevice.allDevices\n\n// Access WAPairedDevice properties\nlet pairingName = device.pairingInfo?.pairingName\nlet vendorName = device.pairingInfo?.vendorName\nlet modelName = device.pairingInfo?.modelName\n\n// Create a filter to select devices of interest\nlet filter = #Predicate<WAPairedDevice> {\n    $0.pairingInfo?.vendorName.starts(with: \"Example Inc\") ?? false\n}\n\n// Get all paired devices, matching the filter, at the current moment\n// A new snapshot of all paired devices each time a device is added, changed, or removed\nfor try await devices in WAPairedDevice.allDevices(matching: filter) {\n    // Process new snapshot of all paired devices\n}"
    },
    {
      "timestamp": "16:23",
      "title": "Filter paired devices",
      "language": "swift",
      "code": "import Foundation\nimport WiFiAware\n\n// Listener (Publisher) Device\n// Specify the paired devices of interest for the use case\nlet deviceFilter = #Predicate<WAPairedDevice> {\n    $0.name?.starts(with: \"My Device\") ?? false\n}\n\n// Browser (Subscriber) Device\n// Specify the paired devices of interest for the use case\nlet deviceFilter = #Predicate<WAPairedDevice> {\n    $0.pairingInfo?.vendorName.starts(with: \"Example Inc\") ?? false\n}"
    },
    {
      "timestamp": "16:54",
      "title": "Create listener and browser",
      "language": "swift",
      "code": "import WiFiAware\nimport Network\n\n// Listener (Publisher) Device: Construct a NetworkListener\nlet listener = try NetworkListener(for:\n        .wifiAware(.connecting(to: .fileService, from: .matching(deviceFilter))),\n    using: .parameters {\n        TLS()\n    })\n    .onStateUpdate { listener, state in\n        // Process state update\n    }\n\n// Browser (Subscriber) Device: Construct a NetworkBrowser\nlet browser = NetworkBrowser(for:\n        .wifiAware(.connecting(to: .matching(deviceFilter), from: .fileService))\n    )\n    .onStateUpdate { browser, state in\n        // Process state update\n    }"
    },
    {
      "timestamp": "17:44",
      "title": "Establish a connection",
      "language": "swift",
      "code": "// Listener (Publisher) Device: Start NetworkListener\ntry await listener.run { connection in  // Radio resources in use\n    // Closure executes for each incoming connection\n    connection.onStateUpdate { connection, state in\n        // Process state update\n    }\n}\n\n// Browser (Subscriber) Device: Start NetworkBrowser\nlet endpoint = try await browser.run { waEndpoints in // Radio resources in use\n        // Review endpoints, decide whether to return or skip\n        if let endpoint = self.endpoint(in: waEndpoints) { return .finish(endpoint) }\n        else { return .continue }\n    }\n// Create the connection\nlet connection = NetworkConnection(to: endpoint, using: .parameters {\n        TLS()\n    })\n    .onStateUpdate { connection, state in\n        // Process state update\n    }"
    },
    {
      "timestamp": "21:11",
      "title": "Tune performance",
      "language": "swift",
      "code": "// Listener (Publisher) Device\n// Configure .realtime + .interactiveVideo on NetworkListener\nlet listener = try NetworkListener(for:\n        .wifiAware(.connecting(to: .fileService, from: .matching(deviceFilter))),\n    using: .parameters {\n        TLS()\n    }\n    .wifiAware { $0.performanceMode = .realtime }\n    .serviceClass(.interactiveVideo))\n\n// Browser (Subscriber) Device\n// Configure .realtime + .interactiveVideo on NetworkConnection\nlet connection = NetworkConnection(to: endpoint, using: .parameters {\n        TLS()\n    }\n    .wifiAware { $0.performanceMode = .realtime }\n    .serviceClass(.interactiveVideo))\n\n// Listener (Publisher) Device & Browser (Subscriber) Device\n// Read performance report\nlet performanceReport = try await connection.currentPath?.wifiAware?.performance"
    }
  ],
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "Wi-Fi Aware",
        "url": "https://developer.apple.com/documentation/WiFiAware"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2025/228/4/b7b10ed3-bcfe-4935-919a-1b7faef02d2b/downloads/wwdc2025-228_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2025/228/4/b7b10ed3-bcfe-4935-919a-1b7faef02d2b/downloads/wwdc2025-228_sd.mp4?dl=1"
  },
  "relatedVideos": [
    {
      "id": "10203",
      "year": "2024",
      "title": "Meet AccessorySetupKit",
      "url": "https://developer.apple.com/videos/play/wwdc2024/10203"
    }
  ],
  "extractedAt": "2025-07-18T10:42:22.336Z"
}