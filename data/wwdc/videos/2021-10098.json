{
  "id": "10098",
  "year": "2021",
  "url": "https://developer.apple.com/videos/play/wwdc2021/10098/",
  "title": "Showcase app data in Spotlight",
  "speakers": [],
  "duration": "",
  "topics": [
    "SwiftUI & UI Frameworks",
    "System Services"
  ],
  "hasTranscript": true,
  "hasCode": true,
  "transcript": {
    "fullText": "♪ Bass music playing ♪  ♪ David Stites: Hi, and welcome to \"Showcase app data in Spotlight\".\n\nMy name is David Stites, and I am an engineer on the Core Data team.\n\nIn this session, I am excited to show you how to add Spotlight indexing in your app using NSCoreDataCoreSpotlightDelegate.\n\nThe agenda for this session is to learn about the NSCoreDataCoreSpotlightDelegate object and why you should use it, setup a simple implementation, learn how to customize that implementation, and lastly, validate the code by adding full-text search.\n\nFirst, let's look at Core Data and Spotlight.\n\nPeople are going to create and store a lot of great and important content in your app.\n\nAs their use of your app and the size of their data set increases, they're going to want to be able to quickly find that data both inside the app using standard search methods and outside the app, for example, in Spotlight search.\n\nWouldn't it be great to have data inside your app show up in Spotlight? Well, this is where Core Data can help you.\n\nThe NSCoreDataCore SpotlightDelegate object does all the heavy lifting and provides a set of APIs that quickly and efficiently indexes content provided by your app.\n\nYou just have to turn it on! Once indexed, search results will also appear in the Spotlight search user interface outside your app.\n\nThe Spotlight delegate automatically processes changes to your graph's managed objects and then updates the Spotlight index accordingly.\n\nIn addition, it provides robust index management capabilities to interact with the private, on-device-only index and allows you to tailor the index results to your liking.\n\nIn fact, any content that is in your persistent store is eligible to be indexed.\n\nThe reasons to use the Spotlight delegate are threefold: (1) the Spotlight delegate maintains feature parity with Core Spotlight APIs, (2) it removes a lot of necessary implementation code, and (3) it provides a great additional feature set that we'll be discussing later in this session.\n\nTo illustrate my previous point, this is a very simple implementation using the Core Spotlight APIs that only adds items to a search index and reduces it to... this! Two lines! Simple, easy to read and maintain.\n\nI mean, come on, who doesn't prefer less code? Let's take a look at how to get setup and running right away.\n\nThis simple example will cover deciding what to index and creating the delegate.\n\nThroughout this session, I will be referring to an app called Tags that I wrote for myself, which is a simple photo tagging application.\n\nThis sample app will incorporate many of the APIs I am discussing today.\n\nPrior to adding Spotlight support, you can see that all the tag and photo data is trapped inside Tags as there are no Spotlight search query results for \"Natural Bridges State Park\".\n\nLet's change that! The first step in any implementation using the NSCoreDataCoreSpotlightDelegate is to decide what you're going to index in Spotlight.\n\nWhat gets indexed in Spotlight is completely up to you.\n\nIn Tags, I've decided to index the userSpecifiedName attribute on the entity Photo and the name attribute on the entity Tag.\n\nTo prepare the model for indexing, I've opened the project's Core Data model in Xcode, selected each attribute I want to index, and have ticked the Index in Spotlight checkbox in the attributes inspector.\n\nOur work continues in the Core Data model editor, as it's required to set the Core Data Spotlight display name.\n\nThe Core Data Spotlight display name is an NSExpression.\n\nAt indexing time, this expression is evaluated with each managed object that has properties indexed by Spotlight and the result is saved.\n\nLater, when the Spotlight search user interface is shown, these stored results are used as the “display name” for the search result.\n\nWhat is an NSExpression? Well, an expression can be as simple as evaluating a key path, in this case Tag.name.\n\nThis object has quite a few more tricks it can do besides evaluating key paths, however.\n\nIn this example, it is doing some math for you.\n\nThe expression can be even more complex, such as calculating the standard deviation of a set of numbers.\n\nIn Tags, the Spotlight display name is set to userSpecifiedName on the entity Photo, and name on the entity Tag.\n\nNow that the model is prepared for indexing, let's create the Spotlight delegate.\n\nBeginning in iOS 15 and macOS Monterey, the initializer forStoreWith: model: is now deprecated.\n\nThe new way initialize a Spotlight delegate is using forStoreWith: coordinator:.\n\nBy adopting the new designated initializer, it is no longer required to add an instance of the Spotlight delegate to the store options prior to adding the store to the coordinator.\n\nHowever, you must call startSpotlightIndexing for the Spotlight delegate to start its work.\n\nI want to call out a couple requirements to using the NSCoreDataCoreSpotlightDelegate.\n\nThe store type of the store to be indexed must be SQLite and must have persistent history tracking enabled.\n\nAnd with that, you're done! That's it! You don't need to do anything else and your data will be indexed in Spotlight.\n\nI just demonstrated how easy it is to add Spotlight indexing to my Tags app.\n\nNow that I've described the basics, let's customize that implementation a bit.\n\nThe first way to customize the implementation is by defining a domain and index name.\n\nTo start off, I'll define a class, TagsSpotlightDelegate, which is a subclass of NSCoreDataCoreSpotlightDelegate.\n\nNow, I'll override domainName and indexName with an implementation.\n\nOverriding these selectors tells Spotlight where to store the indexed data and allows you to better identify it later, especially if you have multiple indices.\n\nIf you do not override domainIdentifier, the default domain identifier is the store identifier.\n\nIf you do not override indexName, the default index name is nil.\n\nThe next step in customizing the Spotlight delegate is defining an attribute set.\n\nIn the setup portion of this session, the NSCoreDataCore SpotlightDelegate object defined the attribute set returned to Spotlight for us, simply by ticking the check box Index in Spotlight.\n\nNow, I am going to demonstrate exactly how to specify the attributes that will be used for indexing.\n\nSpecifying which attributes that should be indexed allows more explicit control over what's indexed and how it's searched for.\n\nTo do that, use CSSearchableItemAttributeSet.\n\nAn attribute set contains a number of predefined properties allowing you to specify the metadata to display about the specified managed object when it appears as a search result.\n\nThe attributes you choose depend completely on your domain.\n\nYou can use predefined properties available in CSSearchableItemAttributeSet or you can define your own properties.\n\nThe Tags app uses the predefined properties keywords, displayName, and thumbnailData.\n\nIt's important to note that you should only modify an attribute set on one thread at a time as concurrent access to the properties in an attribute set has undefined behavior.\n\nBack in the TagsSpotlightDelegate class, let's see how this works by overriding attributeSet (for object:).\n\nIn the override implementation, begin by determining if the object is a Photo type object.\n\nNext, initialize an attributeSet with the content type .image.\n\nThen, set the properties identifier, displayName, and thumbnailData on the attribute set using the appropriate attributes from the Photo object.\n\nNow, append tags from the Photo object tag set to the keywords array on the attribute set.\n\nIt is worth mentioning at this point that if your model indexes a relationship, attributeSet (for object:) must be overridden so that it defines what about that relationship in particular is indexed.\n\nLastly, return the attribute set.\n\nSince the model is also indexing Tag objects, the code needs to handle the case of a Tag.\n\nFor that, create an attribute set with the contentType .text, set the display name to the name of the tag, and then return the attribute set.\n\nAs a last step, remove the Core Data Spotlight display name that was set in the model editor in a previous step.\n\nLet's go further and define an event loop for starting and stopping indexing.\n\nEarlier, when we setup the Spotlight delegate, startSpotlightIndexing was called immediately after creating the Spotlight delegate.\n\nTo give you precise control over when the NSCoreDataCoreSpotlightDelegate is performing indexing work, stopSpotlightIndexing has also been added to the framework.\n\nUsing these two selectors in concert gives you the ability to start and stop indexing work as necessary, say, in the case where your app is performing intense CPU or disk activity operations.\n\nNow, let's add some support for being notified when index updates complete.\n\nWhen a change occurs to an entity or entities that is indexed in Spotlight, that index is updated asynchronously.\n\nIn iOS 15 and macOS Monterey, the Core Data framework has added index update notifications.\n\nTo be informed when the index update is complete, subscribe to NSCoreDataCoreSpotlightDelegate .indexDidUpdateNotification, which is posted by the Spotlight delegate.\n\nThese notifications will be posted after processing a call to save: on NSManagedObjectContext or after the completion of batch operations.\n\nLet's see this in action.\n\nFirst, check to see if indexing is enabled.\n\nIf it is, then register for the indexDidUpdateNotification.\n\nThen, in the handler, inspect the notification, which will have a userInfo dictionary that contains two key-value pairs, similar to a remote change notification: an NSString UUID of the store that for which the Spotlight delegate updated its index, and the persistent history token of the store for which the Spotlight delegate updated its index.\n\nYou can use both of these keys to determine if the store you're interested in has been indexed up to the latest persistent history token.\n\nIf indexing is not enabled, you can remove yourself as an observer from the notifications.\n\nPrior to this year, the only way to delete data indexed by your app was to either implement the Core Spotlight APIs to remove the index entries or delete the entire client graph in Core Data.\n\nCrucially, new in iOS 15 and macOS Monterey, Core Data has given the developer a new way to manage the Spotlight index without deleting the client graph, which is a great win for user privacy! First, the code will stop indexing.\n\nThen, call deleteSpotlightIndex.\n\nLastly, handle any resulting error in the completion handler.\n\nNote that calling this method may return errors from lower-layer dependencies, such as Core Data and Core Spotlight, and you should be prepared to handle those.\n\nNow that I've shown you how to customize an implementation of the Spotlight delegate, let's validate our setup by adding full-text search to the Tags app using the Core Spotlight APIs.\n\nThe results will be what was previously indexed.\n\nStart by defining an extension for PhotosViewController that adopts the UISearchResultsUpdating protocol and a function updateSearchResults (for controller).\n\nThe Tags user interface has a UISearchController.\n\nWe'll get the user input from that search controller's search bar.\n\nIf the user input is empty, fetch all the images from our data provider and then reload the collection view as there is no search query.\n\nNow let's handle the case where there is a search query.\n\nTo start, sanitize the user input string by escaping it.\n\nNext, define a query string using the user's sanitized input string.\n\nQuery strings operate on the values associated with a property in a CSSearchableItemAttributeSet object.\n\nIn this case, the code will be operating on the Keywords attribute that was set in a previous step.\n\nIn the search query, the modifiers c, d, and w are being used.\n\nc is for case insensitive.\n\nd is for diacritic insensitive.\n\nAnd w is for a word-based search.\n\nNow, create a CSSearchQuery object by specifying the formatted query string that was just created and an array of attribute names that correspond to properties defined by CSSearchableItemAttributeSet.\n\nThis search query object manages the criteria to apply when searching app content that you have previously indexed using the Spotlight delegate APIs.\n\nFollowing that, set the foundItemsHandler.\n\nThis handler will be called repetitively with items that match the search query previously defined.\n\nIn the completionHandler for the query, which will be called once, check for an error and potentially perform some error handling.\n\nAbsent an error, dispatch a block onto the main queue to use our data provider to perform a fetch for the items Spotlight found and load them in the user interface.\n\nLastly, and most importantly, don't forget to start the query.\n\nNow that the Tags app has a Spotlight delegate indexing its content, the data has been freed from within the app! When I go to Spotlight, and I search for a tag I have previously added, it returns two results: the tag name itself and the specific photo that I tagged with the keyword \"Natural Bridges State Park\".\n\nWrapping up, we've learned about the NSCoreDataCoreSpotlightDelegate and how it can help your users find their content inside your app and outside your app in Spotlight search, setup the Spotlight delegate quickly and easily to start indexing without a huge code burden, and customized our Spotlight delegate using some of the new APIs available to you this release.\n\nI hope you've found this information useful and that you'll consider adopting NSCoreDataCoreSpotlightDelegate in your project to help users find their content.\n\nHave a great WWDC! ♪",
    "segments": []
  },
  "codeExamples": [
    {
      "timestamp": "2:40",
      "title": "Creating a NSCoreDataCoreSpotlightDelegate",
      "language": "swift",
      "code": "let spotlightDelegate = NSCoreDataCoreSpotlightDelegate(forStoreWith: description,\n                                                        coordinator: coordinator)\nspotlightDelegate.startSpotlightIndexing()"
    },
    {
      "timestamp": "5:24",
      "title": "Adding a NSCoreDataCoreSpotlightDelegate to a CoreDataStack",
      "language": "swift",
      "code": "import Foundation\nimport CoreData\n\nclass CoreDataStack {\n    private (set) var spotlightIndexer: TagsSpotlightDelegate?\n    \n    lazy var persistentContainer: NSPersistentContainer = {\n        let container = NSPersistentContainer(name: \"Tags\")\n\n        guard let description = container.persistentStoreDescriptions.first else {\n            fatalError(\"###\\(#function): Failed to retrieve a persistent store description.\")\n        }\n\n        description.type = NSSQLiteStoreType\n        description.setOption(true as NSNumber, forKey: NSPersistentStoreRemoteChangeNotificationPostOptionKey)\n        description.setOption(true as NSNumber, forKey: NSPersistentHistoryTrackingKey)\n                \n        container.loadPersistentStores(completionHandler: { (_, error) in\n            guard let error = error as NSError? else { return }\n            fatalError(\"###\\(#function): Failed to load persistent stores:\\(error)\")\n        })\n        \n        spotlightIndexer = TagsSpotlightDelegate(forStoreWith: description,\n                                                 coordinator: container.persistentStoreCoordinator)\n\n        container.viewContext.mergePolicy = NSMergeByPropertyObjectTrumpMergePolicy\n        \n        container.viewContext.automaticallyMergesChangesFromParent = true\n        do {\n            try container.viewContext.setQueryGenerationFrom(.current)\n        } catch {\n            fatalError(\"###\\(#function): Failed to pin viewContext to the current generation:\\(error)\")\n        }\n        \n        return container\n    }()\n}"
    },
    {
      "timestamp": "6:24",
      "title": "Creating TagsSpotlightDelegate",
      "language": "swift",
      "code": "class TagsSpotlightDelegate: NSCoreDataCoreSpotlightDelegate {\n    override func domainIdentifier() -> String {\n        return \"com.example.apple-samplecode.tags\"\n    }\n\n    override func indexName() -> String? {\n        return \"tags-index\"\n    }\n  \n    override func attributeSet(for object: NSManagedObject) -> CSSearchableItemAttributeSet? {\n        if let photo = object as? Photo {\n            let attributeSet = CSSearchableItemAttributeSet(contentType: .image)\n            attributeSet.identifier = photo.uniqueName\n            attributeSet.displayName = photo.userSpecifiedName\n            attributeSet.thumbnailData = photo.thumbnail?.data\n            for case let tag as Tag in photo.tags ?? [] {\n                if let name = tag.name {\n                    if attributeSet.keywords != nil {\n                        attributeSet.keywords?.append(name)\n                    } else {\n                        attributeSet.keywords = [name]\n                    }\n                }\n            }\n            return attributeSet\n        } else if let object as? Tag {\n            let attributeSet = CSSearchableItemAttributeSet(contentType: .text)\n            attributeSet.displayName = tag.name\n            return attributeSet\n        }\n        return nil\n    }\n}"
    },
    {
      "timestamp": "9:51",
      "title": "Customizing PhotosViewController with Spotlight delegate functionality",
      "language": "swift",
      "code": "class PhotosViewController: UICollectionViewController {\n    @IBOutlet var generateDefaultPhotosItem: UIBarButtonItem!\n    @IBOutlet var deleteSpotlightIndexItem: UIBarButtonItem!\n    @IBOutlet var startStopIndexingItem: UIBarButtonItem!\n    \n    private var isTagging = false\n    private var spotlightFoundItems = [CSSearchableItem]()\n    private static let defaultSectionNumber = 0\n    private var searchQuery: CSSearchQuery?\n    var spotlightUpdateObserver: NSObjectProtocol?\n\n    private lazy var spotlightIndexer: TagsSpotlightDelegate = {\n        let appDelegate = UIApplication.shared.delegate as? AppDelegate\n        return appDelegate!.coreDataStack.spotlightIndexer!\n    }()\n  \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        // ...\n\n        toggleSpotlightIndexing(enabled: true)\n    }\n  \n    @IBAction func deleteSpotlightIndex(_ sender: Any) {\n        toggleSpotlightIndexing(enabled: false)\n\n        spotlightIndexer.deleteSpotlightIndex(completionHandler: { (error) in\n            if let err = error {\n                print(\"Encountered error while deleting Spotlight index data, \\(err.localizedDescription)\")\n            } else {\n                print(\"Finished deleting Spotlight index data.\")\n            }\n        })\n    }\n\n    @IBAction func toggleSpotlightIndexingEnabled(_ sender: Any) {\n        if spotlightIndexer.isIndexingEnabled == true {\n            toggleSpotlightIndexing(enabled: false)\n        } else {\n            toggleSpotlightIndexing(enabled: true)\n        }\n    }\n\n    private func toggleSpotlightIndexing(enabled: Bool) {\n        if enabled {\n            spotlightIndexer.startSpotlightIndexing()\n            startStopIndexingItem.image = UIImage(systemName: \"pause\")\n        } else {\n            spotlightIndexer.stopSpotlightIndexing()\n            startStopIndexingItem.image = UIImage(systemName: \"play\")\n        }\n\n        let center = NotificationCenter.default\n        if spotlightIndexer.isIndexingEnabled && spotlightUpdateObserver == nil {\n            let queue = OperationQueue.main\n            spotlightUpdateObserver = center.addObserver(forName: NSCoreDataCoreSpotlightDelegate.indexDidUpdateNotification,\n                                                         object: nil,\n                                                         queue: queue) { (notification) in\n                let userInfo = notification.userInfo\n                let storeID = userInfo?[NSStoreUUIDKey] as? String\n                let token = userInfo?[NSPersistentHistoryTokenKey] as? NSPersistentHistoryToken\n                if let storeID = storeID, let token = token {\n                    print(\"Store with identifier \\(storeID) has completed \",\n                          \"indexing and has processed history token up through \\(String(describing: token)).\")\n                }\n            }\n        } else {\n            if spotlightUpdateObserver == nil {\n                return\n            }\n            center.removeObserver(spotlightUpdateObserver as Any)\n        }\n    }\n}"
    },
    {
      "timestamp": "13:13",
      "title": "Adding full-text search to PhotosViewController",
      "language": "swift",
      "code": "extension PhotosViewController: UISearchResultsUpdating {\n    func updateSearchResults(for searchController: UISearchController) {\n        guard let userInput = searchController.searchBar.text, !userInput.isEmpty else {\n            dataProvider.performFetch(predicate: nil)\n            reloadCollectionView()\n            return\n        }\n        \n        let escapedString = userInput.replacingOccurrences(of: \"\\\\\", with: \"\\\\\\\\\").replacingOccurrences(of: \"\\\"\", with: \"\\\\\\\"\")\n        let queryString = \"(keywords == \\\"\" + escapedString + \"*\\\"cwdt)\"\n        \n        searchQuery = CSSearchQuery(queryString: queryString, attributes: [\"displayName\", \"keywords\"])\n\n        // Set a handler for results. This will be a called 0 or more times.\n        searchQuery?.foundItemsHandler = { items in\n            DispatchQueue.main.async {\n                self.spotlightFoundItems += items\n            }\n        }\n        \n        // Set a completion handler. This will be called once.\n        searchQuery?.completionHandler = { error in\n            guard error == nil else {\n                print(\"CSSearchQuery completed with error: \\(error!).\")\n                return\n            }\n\n            DispatchQueue.main.async {\n                self.dataProvider.performFetch(searchableItems: self.spotlightFoundItems)\n                self.reloadCollectionView()\n                self.spotlightFoundItems.removeAll()\n            }\n        }\n\n        // Start the query.\n        searchQuery?.start()\n    }\n}"
    }
  ],
  "resources": {
    "resourceLinks": [
      {
        "title": "Design",
        "url": "https://developer.apple.com/design/"
      },
      {
        "title": "Showcase App Data in Spotlight",
        "url": "https://developer.apple.com/documentation/CoreData/showcase-app-data-in-spotlight"
      },
      {
        "title": "Documentation",
        "url": "https://developer.apple.com/documentation/"
      },
      {
        "title": "Forums",
        "url": "https://developer.apple.com/forums/"
      },
      {
        "title": "Apple Design Awards",
        "url": "https://developer.apple.com/design/awards/"
      }
    ],
    "hdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2021/10098/5/E1444CD9-0588-4D3B-8AFA-EB590BA9CD23/downloads/wwdc2021-10098_hd.mp4?dl=1",
    "sdVideo": "https://devstreaming-cdn.apple.com/videos/wwdc/2021/10098/5/E1444CD9-0588-4D3B-8AFA-EB590BA9CD23/downloads/wwdc2021-10098_sd.mp4?dl=1"
  },
  "relatedVideos": [
    {
      "id": "10017",
      "year": "2021",
      "title": "Bring Core Data concurrency to Swift and SwiftUI",
      "url": "https://developer.apple.com/videos/play/wwdc2021/10017"
    }
  ],
  "extractedAt": "2025-07-18T10:55:03.208Z"
}